{"version":3,"file":"mapbox-gl-draw-snap-mode.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA8B,qBAAID,IAElCD,EAA2B,qBAAIC,GAChC,CATD,CASGK,MAAM,I,2BCTT,IAAIC,EAAQ,EAAQ,KA4BpB,SAASC,EAAYC,GACjB,IAAIC,EAAO,EACX,GAAID,GAAUA,EAAOE,OAAS,EAAG,CAC7BD,GAAQE,KAAKC,IAAIC,EAASL,EAAO,KACjC,IAAK,IAAIM,EAAI,EAAGA,EAAIN,EAAOE,OAAQI,IAC/BL,GAAQE,KAAKC,IAAIC,EAASL,EAAOM,IAEzC,CACA,OAAOL,CACX,CAiBA,SAASI,EAASL,GACd,IAAIO,EAAIC,EAAQC,EAAYC,EAAaC,EAAYL,EACrDL,EAAO,EACPW,EAAeZ,EAAOE,OAEtB,GAAIU,EAAe,EAAG,CAClB,IAAKN,EAAI,EAAGA,EAAIM,EAAcN,IACtBA,IAAMM,EAAe,GACrBH,EAAaG,EAAe,EAC5BF,EAAcE,EAAc,EAC5BD,EAAa,GACNL,IAAMM,EAAe,GAC5BH,EAAaG,EAAe,EAC5BF,EAAc,EACdC,EAAa,IAEbF,EAAaH,EACbI,EAAcJ,EAAE,EAChBK,EAAaL,EAAE,GAEnBC,EAAKP,EAAOS,GACZD,EAAKR,EAAOU,GAEZT,IAAUY,EADLb,EAAOW,GACK,IAAME,EAAIN,EAAG,KAAQJ,KAAKW,IAAKD,EAAIL,EAAG,KAG3DP,EAAOA,EAAOH,EAAMiB,OAASjB,EAAMiB,OAAS,CAChD,CAEA,OAAOd,CACX,CAEA,SAASY,EAAIG,GACT,OAAOA,EAAIb,KAAKc,GAAK,GACzB,CAtFAvB,EAAOD,QAAQyB,SAGf,SAASA,EAASF,GACd,IAAcV,EAAVL,EAAO,EACX,OAAQe,EAAEG,MACN,IAAK,UACD,OAAOpB,EAAYiB,EAAEI,aACzB,IAAK,eACD,IAAKd,EAAI,EAAGA,EAAIU,EAAEI,YAAYlB,OAAQI,IAClCL,GAAQF,EAAYiB,EAAEI,YAAYd,IAEtC,OAAOL,EACX,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,kBACD,OAAO,EACX,IAAK,qBACD,IAAKK,EAAI,EAAGA,EAAIU,EAAEK,WAAWnB,OAAQI,IACjCL,GAAQiB,EAASF,EAAEK,WAAWf,IAElC,OAAOL,EAEnB,EAvBAP,EAAOD,QAAQ6B,KAAOjB,C,UCHtBX,EAAOD,QAoBP,SAAmB8B,GACf,IAAKA,IAAOA,EAAGJ,KAAM,OAAO,KAC5B,IAAIA,EAAOK,EAAMD,EAAGJ,MACpB,IAAKA,EAAM,OAAO,KAElB,GAAa,aAATA,EACA,MAAO,CACHA,KAAM,oBACNM,SAAU,CAAC,CACPN,KAAM,UACNO,WAAY,CAAC,EACbR,SAAUK,KAGf,GAAa,YAATJ,EACP,MAAO,CACHA,KAAM,oBACNM,SAAU,CAACF,IAEZ,GAAa,sBAATJ,EACP,OAAOI,CAEf,EAxCA,IAAIC,EAAQ,CACRG,MAAO,WACPC,WAAY,WACZC,WAAY,WACZC,gBAAiB,WACjBC,QAAS,WACTC,aAAc,WACdC,mBAAoB,WACpBC,QAAS,UACTC,kBAAmB,oB,6BCTvB,IAAIC,EAAS,EAAQ,KAerB,SAASC,EAAKC,GACV,IAAIC,EAAS,CAACC,IAAUA,KAAWA,KAAWA,KAe9C,OAdAJ,EAAOK,UAAUH,GAAS,SAAUI,GAC5BH,EAAO,GAAKG,EAAM,KAClBH,EAAO,GAAKG,EAAM,IAElBH,EAAO,GAAKG,EAAM,KAClBH,EAAO,GAAKG,EAAM,IAElBH,EAAO,GAAKG,EAAM,KAClBH,EAAO,GAAKG,EAAM,IAElBH,EAAO,GAAKG,EAAM,KAClBH,EAAO,GAAKG,EAAM,GAE1B,IACOH,CACX,CACAF,EAAc,QAAIA,EAClB5C,EAAQ,EAAU4C,C,2BCgElB,SAASM,EAAQC,EAAMlB,EAAYmB,QACf,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIC,EAAO,CAAE3B,KAAM,WASnB,OARmB,IAAf0B,EAAQE,IAAYF,EAAQE,MAC5BD,EAAKC,GAAKF,EAAQE,IAElBF,EAAQR,OACRS,EAAKT,KAAOQ,EAAQR,MAExBS,EAAKpB,WAAaA,GAAc,CAAC,EACjCoB,EAAK5B,SAAW0B,EACTE,CACX,CAoDA,SAASE,EAAM5B,EAAaM,EAAYmB,GAEpC,QADgB,IAAZA,IAAsBA,EAAU,CAAC,IAChCzB,EACD,MAAM,IAAI6B,MAAM,2BAEpB,IAAKC,MAAMC,QAAQ/B,GACf,MAAM,IAAI6B,MAAM,gCAEpB,GAAI7B,EAAYlB,OAAS,EACrB,MAAM,IAAI+C,MAAM,+CAEpB,IAAKG,EAAShC,EAAY,MAAQgC,EAAShC,EAAY,IACnD,MAAM,IAAI6B,MAAM,oCAMpB,OAAON,EAJI,CACPxB,KAAM,QACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA4CA,SAASQ,EAAQjC,EAAaM,EAAYmB,QACtB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAK,IAAIS,EAAK,EAAGC,EAAgBnC,EAAakC,EAAKC,EAAcrD,OAAQoD,IAAM,CAC3E,IAAIhC,EAAOiC,EAAcD,GACzB,GAAIhC,EAAKpB,OAAS,EACd,MAAM,IAAI+C,MAAM,+DAEpB,IAAK,IAAIO,EAAI,EAAGA,EAAIlC,EAAKA,EAAKpB,OAAS,GAAGA,OAAQsD,IAE9C,GAAIlC,EAAKA,EAAKpB,OAAS,GAAGsD,KAAOlC,EAAK,GAAGkC,GACrC,MAAM,IAAIP,MAAM,8CAG5B,CAKA,OAAON,EAJI,CACPxB,KAAM,UACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA4CA,SAASY,EAAWrC,EAAaM,EAAYmB,GAEzC,QADgB,IAAZA,IAAsBA,EAAU,CAAC,GACjCzB,EAAYlB,OAAS,EACrB,MAAM,IAAI+C,MAAM,yDAMpB,OAAON,EAJI,CACPxB,KAAM,aACNC,YAAaA,GAEIM,EAAYmB,EACrC,CAkDA,SAASa,EAAkBjC,EAAUoB,QACjB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIc,EAAK,CAAExC,KAAM,qBAQjB,OAPI0B,EAAQE,KACRY,EAAGZ,GAAKF,EAAQE,IAEhBF,EAAQR,OACRsB,EAAGtB,KAAOQ,EAAQR,MAEtBsB,EAAGlC,SAAWA,EACPkC,CACX,CAmBA,SAASC,EAAgBxC,EAAaM,EAAYmB,GAM9C,YALgB,IAAZA,IAAsBA,EAAU,CAAC,GAK9BF,EAJI,CACPxB,KAAM,kBACNC,YAAaA,GAEIM,EAAYmB,EACrC,CAmBA,SAASgB,EAAWzC,EAAaM,EAAYmB,GAMzC,YALgB,IAAZA,IAAsBA,EAAU,CAAC,GAK9BF,EAJI,CACPxB,KAAM,aACNC,YAAaA,GAEIM,EAAYmB,EACrC,CAoBA,SAASiB,EAAa1C,EAAaM,EAAYmB,GAM3C,YALgB,IAAZA,IAAsBA,EAAU,CAAC,GAK9BF,EAJI,CACPxB,KAAM,eACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA6DA,SAASkB,EAAgBC,EAASC,QAChB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASzE,EAAQ0E,QAAQF,GAC7B,IAAKC,EACD,MAAM,IAAIjB,MAAMgB,EAAQ,qBAE5B,OAAOD,EAAUE,CACrB,CAYA,SAASE,EAAgBC,EAAUJ,QACjB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASzE,EAAQ0E,QAAQF,GAC7B,IAAKC,EACD,MAAM,IAAIjB,MAAMgB,EAAQ,qBAE5B,OAAOI,EAAWH,CACtB,CAuCA,SAASI,EAAiBN,GAEtB,OAAkB,KADJA,GAAW,EAAI7D,KAAKc,KACTd,KAAKc,EAClC,CAoEA,SAASmC,EAASmB,GACd,OAAQC,MAAMD,IAAgB,OAARA,IAAiBrB,MAAMC,QAAQoB,EACzD,CA9nBAE,OAAOC,eAAejF,EAAS,aAAc,CAAEkF,OAAO,IAUtDlF,EAAQmF,YAAc,UAOtBnF,EAAQ0E,QAAU,CACdU,YAAmC,IAAtBpF,EAAQmF,YACrBE,YAAmC,IAAtBrF,EAAQmF,YACrBG,QAAStF,EAAQmF,YAAc,OAC/BI,KAA4B,QAAtBvF,EAAQmF,YACdK,OAA8B,MAAtBxF,EAAQmF,YAChBM,WAAYzF,EAAQmF,YAAc,IAClCO,WAAY1F,EAAQmF,YAAc,IAClCQ,OAAQ3F,EAAQmF,YAChBS,OAAQ5F,EAAQmF,YAChBU,MAAO7F,EAAQmF,YAAc,SAC7BW,YAAmC,IAAtB9F,EAAQmF,YACrBY,YAAmC,IAAtB/F,EAAQmF,YACrBa,cAAehG,EAAQmF,YAAc,KACrCZ,QAAS,EACT0B,MAA6B,OAAtBjG,EAAQmF,aAQnBnF,EAAQkG,aAAe,CACnBd,YAAa,IACbC,YAAa,IACbC,QAAS,EAAI,OACbC,KAAM,QACNC,OAAQ,MACRC,WAAY,KACZC,WAAY,KACZC,OAAQ,EACRC,OAAQ,EACRC,MAAO,EAAI,SACXC,YAAa,IACbC,YAAa,IACbC,cAAe,EAAI,KACnBzB,QAAS,EAAIvE,EAAQmF,YACrBc,MAAO,WAQXjG,EAAQmG,YAAc,CAClBC,MAAO,UACPhB,YAAa,IACbC,YAAa,IACbE,KAAM,aACNc,SAAU,KACVb,OAAQ,eACRC,WAAY,KACZC,WAAY,KACZC,OAAQ,EACRC,OAAQ,EACRC,MAAO,OACPC,YAAa,IACbC,YAAa,IACbE,MAAO,aAmCXjG,EAAQkD,QAAUA,EAmClBlD,EAAQyB,SAnBR,SAAkBC,EAAMC,EAAa2E,GAEjC,YADiB,IAAbA,IAAuBA,EAAW,CAAC,GAC/B5E,GACJ,IAAK,QACD,OAAO6B,EAAM5B,GAAaF,SAC9B,IAAK,aACD,OAAOuC,EAAWrC,GAAaF,SACnC,IAAK,UACD,OAAOmC,EAAQjC,GAAaF,SAChC,IAAK,aACD,OAAO2C,EAAWzC,GAAaF,SACnC,IAAK,kBACD,OAAO0C,EAAgBxC,GAAaF,SACxC,IAAK,eACD,OAAO4C,EAAa1C,GAAaF,SACrC,QACI,MAAM,IAAI+B,MAAM9B,EAAO,eAEnC,EAqCA1B,EAAQuD,MAAQA,EA2BhBvD,EAAQuG,OANR,SAAgB5E,EAAaM,EAAYmB,GAErC,YADgB,IAAZA,IAAsBA,EAAU,CAAC,GAC9Ba,EAAkBtC,EAAY6E,KAAI,SAAUjG,GAC/C,OAAOgD,EAAMhD,EAAQ0B,EACzB,IAAImB,EACR,EAqCApD,EAAQ4D,QAAUA,EAyBlB5D,EAAQyG,SANR,SAAkB9E,EAAaM,EAAYmB,GAEvC,YADgB,IAAZA,IAAsBA,EAAU,CAAC,GAC9Ba,EAAkBtC,EAAY6E,KAAI,SAAUjG,GAC/C,OAAOqD,EAAQrD,EAAQ0B,EAC3B,IAAImB,EACR,EA8BApD,EAAQgE,WAAaA,EA0BrBhE,EAAQ0G,YANR,SAAqB/E,EAAaM,EAAYmB,GAE1C,YADgB,IAAZA,IAAsBA,EAAU,CAAC,GAC9Ba,EAAkBtC,EAAY6E,KAAI,SAAUjG,GAC/C,OAAOyD,EAAWzD,EAAQ0B,EAC9B,IAAImB,EACR,EAoCApD,EAAQiE,kBAAoBA,EA0B5BjE,EAAQmE,gBAAkBA,EA0B1BnE,EAAQoE,WAAaA,EA2BrBpE,EAAQqE,aAAeA,EA2BvBrE,EAAQ2G,mBARR,SAA4B/E,EAAYK,EAAYmB,GAMhD,YALgB,IAAZA,IAAsBA,EAAU,CAAC,GAK9BF,EAJI,CACPxB,KAAM,qBACNE,WAAYA,GAEKK,EAAYmB,EACrC,EAuBApD,EAAQ4G,MARR,SAAe9B,EAAK+B,GAEhB,QADkB,IAAdA,IAAwBA,EAAY,GACpCA,KAAeA,GAAa,GAC5B,MAAM,IAAIrD,MAAM,uCAEpB,IAAIsD,EAAapG,KAAKqG,IAAI,GAAIF,GAAa,GAC3C,OAAOnG,KAAKkG,MAAM9B,EAAMgC,GAAcA,CAC1C,EAoBA9G,EAAQsE,gBAAkBA,EAmB1BtE,EAAQ2E,gBAAkBA,EAc1B3E,EAAQgH,gBAHR,SAAyBpC,EAAUJ,GAC/B,OAAOK,EAAiBF,EAAgBC,EAAUJ,GACtD,EAiBAxE,EAAQiH,iBAPR,SAA0BC,GACtB,IAAIC,EAAQD,EAAU,IAItB,OAHIC,EAAQ,IACRA,GAAS,KAENA,CACX,EAaAnH,EAAQ6E,iBAAmBA,EAY3B7E,EAAQoH,iBAJR,SAA0B9B,GAEtB,OADcA,EAAU,IACN5E,KAAKc,GAAM,GACjC,EAmBAxB,EAAQqH,cARR,SAAuB5G,EAAQ6G,EAAcC,GAGzC,QAFqB,IAAjBD,IAA2BA,EAAe,mBAC5B,IAAdC,IAAwBA,EAAY,gBAClC9G,GAAU,GACZ,MAAM,IAAI+C,MAAM,oCAEpB,OAAOc,EAAgBK,EAAgBlE,EAAQ6G,GAAeC,EAClE,EA0BAvH,EAAQwH,YAhBR,SAAqBhH,EAAM8G,EAAcC,GAGrC,QAFqB,IAAjBD,IAA2BA,EAAe,eAC5B,IAAdC,IAAwBA,EAAY,gBAClC/G,GAAQ,GACV,MAAM,IAAIgD,MAAM,kCAEpB,IAAIiE,EAAczH,EAAQmG,YAAYmB,GACtC,IAAKG,EACD,MAAM,IAAIjE,MAAM,0BAEpB,IAAIkE,EAAc1H,EAAQmG,YAAYoB,GACtC,IAAKG,EACD,MAAM,IAAIlE,MAAM,uBAEpB,OAAQhD,EAAOiH,EAAeC,CAClC,EAgBA1H,EAAQ2D,SAAWA,EAenB3D,EAAQ2H,SAHR,SAAkBC,GACd,QAASA,GAASA,EAAMC,cAAgB7C,MAC5C,EAuCAhF,EAAQ8H,aAhBR,SAAsBlF,GAClB,IAAKA,EACD,MAAM,IAAIY,MAAM,oBAEpB,IAAKC,MAAMC,QAAQd,GACf,MAAM,IAAIY,MAAM,yBAEpB,GAAoB,IAAhBZ,EAAKnC,QAAgC,IAAhBmC,EAAKnC,OAC1B,MAAM,IAAI+C,MAAM,2CAEpBZ,EAAKmF,SAAQ,SAAUjD,GACnB,IAAKnB,EAASmB,GACV,MAAM,IAAItB,MAAM,iCAExB,GACJ,EA+BAxD,EAAQgI,WARR,SAAoB1E,GAChB,IAAKA,EACD,MAAM,IAAIE,MAAM,kBAEpB,IAAiD,IAA7C,CAAC,SAAU,UAAUyE,eAAe3E,GACpC,MAAM,IAAIE,MAAM,kCAExB,C,6BChtBAwB,OAAOC,eAAejF,EAAS,aAA/B,CAA+CkF,OAAO,IAEtD,IAAIgD,EAAU,EAAQ,KAmCtB,SAASlF,EAAUH,EAASsF,EAAUC,GAEpC,GAAgB,OAAZvF,EA4BJ,IA3BA,IAAIkB,EACFsE,EACAC,EACA7G,EACA8G,EACAhI,EACAiI,EAGAC,EAFAC,EAAa,EACbC,EAAa,EAEbjH,EAAOmB,EAAQnB,KACfkH,EAA+B,sBAATlH,EACtBmH,EAAqB,YAATnH,EACZoH,EAAOF,EAAsB/F,EAAQb,SAASvB,OAAS,EAchDsI,EAAe,EAAGA,EAAeD,EAAMC,IAAgB,CAS9DR,GAHAE,KALAD,EAA0BI,EACtB/F,EAAQb,SAAS+G,GAActH,SAC/BoH,EACAhG,EAAQpB,SACRoB,IAEiC,uBAAjC2F,EAAwB9G,MAGxB8G,EAAwB5G,WAAWnB,OACnC,EAEJ,IAAK,IAAIuI,EAAY,EAAGA,EAAYT,EAAOS,IAAa,CACtD,IAAIC,EAAoB,EACpBC,EAAgB,EAMpB,GAAiB,QALjBzH,EAAWgH,EACPD,EAAwB5G,WAAWoH,GACnCR,GAGJ,CACAjI,EAASkB,EAASE,YAClB,IAAIwH,EAAW1H,EAASC,KAQxB,OANAgH,GACEN,GACc,YAAbe,GAAuC,iBAAbA,EAEvB,EADA,EAGEA,GACN,KAAK,KACH,MACF,IAAK,QACH,IAOQ,IANNhB,EACE5H,EACAoI,EACAI,EACAE,EACAC,GAGF,OAAO,EACTP,IACAM,IACA,MACF,IAAK,aACL,IAAK,aACH,IAAKlF,EAAI,EAAGA,EAAIxD,EAAOE,OAAQsD,IAAK,CAClC,IAOQ,IANNoE,EACE5H,EAAOwD,GACP4E,EACAI,EACAE,EACAC,GAGF,OAAO,EACTP,IACiB,eAAbQ,GAA2BF,GACjC,CACiB,eAAbE,GAA2BF,IAC/B,MACF,IAAK,UACL,IAAK,kBACH,IAAKlF,EAAI,EAAGA,EAAIxD,EAAOE,OAAQsD,IAAK,CAClC,IAAKsE,EAAI,EAAGA,EAAI9H,EAAOwD,GAAGtD,OAASiI,EAAYL,IAAK,CAClD,IAOQ,IANNF,EACE5H,EAAOwD,GAAGsE,GACVM,EACAI,EACAE,EACAC,GAGF,OAAO,EACTP,GACF,CACiB,oBAAbQ,GAAgCF,IACnB,YAAbE,GAAwBD,GAC9B,CACiB,YAAbC,GAAwBF,IAC5B,MACF,IAAK,eACH,IAAKlF,EAAI,EAAGA,EAAIxD,EAAOE,OAAQsD,IAAK,CAElC,IADAmF,EAAgB,EACXb,EAAI,EAAGA,EAAI9H,EAAOwD,GAAGtD,OAAQ4H,IAAK,CACrC,IAAKC,EAAI,EAAGA,EAAI/H,EAAOwD,GAAGsE,GAAG5H,OAASiI,EAAYJ,IAAK,CACrD,IAOQ,IANNH,EACE5H,EAAOwD,GAAGsE,GAAGC,GACbK,EACAI,EACAE,EACAC,GAGF,OAAO,EACTP,GACF,CACAO,GACF,CACAD,GACF,CACA,MACF,IAAK,qBACH,IAAKlF,EAAI,EAAGA,EAAItC,EAASG,WAAWnB,OAAQsD,IAC1C,IAEE,IADAf,EAAUvB,EAASG,WAAWmC,GAAIoE,EAAUC,GAG5C,OAAO,EACX,MACF,QACE,MAAM,IAAI5E,MAAM,yBAjGW,CAmGjC,CACF,CACF,CA0GA,SAAS4F,EAASvG,EAASsF,GACzB,IAAItH,EACJ,OAAQgC,EAAQnB,MACd,IAAK,oBACH,IAAKb,EAAI,EAAGA,EAAIgC,EAAQb,SAASvB,SACqB,IAAhD0H,EAAStF,EAAQb,SAASnB,GAAGoB,WAAYpB,GADNA,KAGzC,MACF,IAAK,UACHsH,EAAStF,EAAQZ,WAAY,GAGnC,CAoFA,SAASoH,EAAYxG,EAASsF,GAC5B,GAAqB,YAAjBtF,EAAQnB,KACVyG,EAAStF,EAAS,QACb,GAAqB,sBAAjBA,EAAQnB,KACjB,IAAK,IAAIb,EAAI,EAAGA,EAAIgC,EAAQb,SAASvB,SACM,IAArC0H,EAAStF,EAAQb,SAASnB,GAAIA,GADSA,KAIjD,CA6GA,SAASyI,EAASzG,EAASsF,GACzB,IAAItH,EACFkD,EACAwF,EACA9H,EACA8G,EACAC,EACAC,EACAe,EACAC,EACAC,EACAX,EAAe,EACfH,EAAuC,sBAAjB/F,EAAQnB,KAC9BmH,EAA6B,YAAjBhG,EAAQnB,KACpBoH,EAAOF,EAAsB/F,EAAQb,SAASvB,OAAS,EAczD,IAAKI,EAAI,EAAGA,EAAIiI,EAAMjI,IAAK,CA4BzB,IA3BA2H,EAA0BI,EACtB/F,EAAQb,SAASnB,GAAGY,SACpBoH,EACAhG,EAAQpB,SACRoB,EACJ2G,EAAoBZ,EAChB/F,EAAQb,SAASnB,GAAGoB,WACpB4G,EACAhG,EAAQZ,WACR,CAAC,EACLwH,EAAcb,EACV/F,EAAQb,SAASnB,GAAG+B,KACpBiG,EACAhG,EAAQD,UACR+G,EACJD,EAAYd,EACR/F,EAAQb,SAASnB,GAAGyC,GACpBuF,EACAhG,EAAQS,QACRqG,EAIJpB,GAHAE,IAAuBD,GACc,uBAAjCA,EAAwB9G,MAGxB8G,EAAwB5G,WAAWnB,OACnC,EAEC8I,EAAI,EAAGA,EAAIhB,EAAOgB,IAMrB,GAAiB,QALjB9H,EAAWgH,EACPD,EAAwB5G,WAAW2H,GACnCf,GAgBJ,OAAQ/G,EAASC,MACf,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACH,IAOQ,IANNyG,EACE1G,EACAsH,EACAS,EACAC,EACAC,GAGF,OAAO,EACT,MAEF,IAAK,qBACH,IAAK3F,EAAI,EAAGA,EAAItC,EAASG,WAAWnB,OAAQsD,IAC1C,IAOQ,IANNoE,EACE1G,EAASG,WAAWmC,GACpBgF,EACAS,EACAC,EACAC,GAGF,OAAO,EAEX,MAEF,QACE,MAAM,IAAIlG,MAAM,8BA/ClB,IAOQ,IANN2E,EACE,KACAY,EACAS,EACAC,EACAC,GAGF,OAAO,EA0CbX,GACF,CACF,CAyGA,SAASa,EAAY/G,EAASsF,GAC5BmB,EAASzG,GAAS,SAAUpB,EAAUsH,EAAc9G,EAAYW,EAAMU,GAEpE,IAiBI6F,EAjBAzH,EAAoB,OAAbD,EAAoB,KAAOA,EAASC,KAC/C,OAAQA,GACN,KAAK,KACL,IAAK,QACL,IAAK,aACL,IAAK,UACH,OAKQ,IAJNyG,EACED,EAAQhF,QAAQzB,EAAUQ,EAAY,CAAEW,KAAMA,EAAMU,GAAIA,IACxDyF,EACA,SAIJ,EAMJ,OAAQrH,GACN,IAAK,aACHyH,EAAW,QACX,MACF,IAAK,kBACHA,EAAW,aACX,MACF,IAAK,eACHA,EAAW,UAIf,IACE,IAAIF,EAAoB,EACxBA,EAAoBxH,EAASE,YAAYlB,OACzCwI,IACA,CACA,IACI9F,EAAO,CACTzB,KAAMyH,EACNxH,YAHeF,EAASE,YAAYsH,IAKtC,IAEE,IADAd,EAASD,EAAQhF,QAAQC,EAAMlB,GAAa8G,EAAcE,GAG1D,OAAO,CACX,CACF,GACF,CA0GA,SAASY,EAAYhH,EAASsF,GAC5ByB,EAAY/G,GAAS,SAAUK,EAAS6F,EAAcE,GACpD,IAAIa,EAAe,EAGnB,GAAK5G,EAAQzB,SAAb,CAEA,IAAIC,EAAOwB,EAAQzB,SAASC,KAC5B,GAAa,UAATA,GAA6B,eAATA,EAAxB,CAGA,IAAIqI,EACAC,EAAuB,EACvBC,EAAqB,EACrBC,EAAgB,EACpB,OAyCQ,IAxCNlH,EACEE,GACA,SACEiH,EACAxB,EACAyB,EACAC,EACAnB,GAGA,QACqBS,IAAnBI,GACAhB,EAAeiB,GACfK,EAAsBJ,GACtBf,EAAgBgB,EAOhB,OALAH,EAAiBI,EACjBH,EAAuBjB,EACvBkB,EAAqBI,EACrBH,EAAgBhB,OAChBY,EAAe,GAGjB,IAAIQ,EAAiBpC,EAAQlE,WAC3B,CAAC+F,EAAgBI,GACjBjH,EAAQjB,YAEV,IAOQ,IANNkG,EACEmC,EACAvB,EACAE,EACAC,EACAY,GAGF,OAAO,EACTA,IACAC,EAAiBI,CACnB,UAxCJ,CAPqD,CAHxB,CAsD/B,GACF,CAkHA,SAASI,EAAS1H,EAASsF,GAEzB,IAAKtF,EAAS,MAAM,IAAIW,MAAM,uBAE9BoG,EAAY/G,GAAS,SAAUK,EAAS6F,EAAcE,GACpD,GAAyB,OAArB/F,EAAQzB,SAAZ,CACA,IAAIC,EAAOwB,EAAQzB,SAASC,KACxBnB,EAAS2C,EAAQzB,SAASE,YAC9B,OAAQD,GACN,IAAK,aACH,IAAiE,IAA7DyG,EAASjF,EAAS6F,EAAcE,EAAmB,EAAG,GACxD,OAAO,EACT,MACF,IAAK,UACH,IACE,IAAIC,EAAgB,EACpBA,EAAgB3I,EAAOE,OACvByI,IAEA,IAMQ,IALNf,EACED,EAAQlE,WAAWzD,EAAO2I,GAAgBhG,EAAQjB,YAClD8G,EACAE,EACAC,GAGF,OAAO,EAtBsB,CA0BvC,GACF,CAqTAlJ,EAAQwK,SAt6BR,SAAkB3H,GAChB,IAAItC,EAAS,GAIb,OAHAyC,EAAUH,GAAS,SAAUI,GAC3B1C,EAAOkK,KAAKxH,EACd,IACO1C,CACT,EAi6BAP,EAAQgD,UAAYA,EACpBhD,EAAQ0K,YA3oCR,SAAqB7H,EAASsF,EAAUwC,EAAcvC,GACpD,IAAIwC,EAAgBD,EAwBpB,OAvBA3H,EACEH,GACA,SACEsH,EACAxB,EACAI,EACAE,EACAC,GAGE0B,EADiB,IAAfjC,QAAqCgB,IAAjBgB,EACNR,EAEAhC,EACdyC,EACAT,EACAxB,EACAI,EACAE,EACAC,EAEN,GACAd,GAEKwC,CACT,EAknCA5K,EAAQqJ,YAAcA,EACtBrJ,EAAQ6K,cAn8BR,SAAuBhI,EAASsF,EAAUwC,GACxC,IAAIC,EAAgBD,EAMpB,OALAtB,EAAYxG,GAAS,SAAUiI,EAAgB/B,GAE3C6B,EADmB,IAAjB7B,QAAuCY,IAAjBgB,EACRG,EACG3C,EAASyC,EAAeE,EAAgB/B,EAC/D,IACO6B,CACT,EA47BA5K,EAAQ+K,UAnFR,SAAmBlI,EAASO,GAG1B,GADAA,EAAUA,GAAW,CAAC,GACjB8E,EAAQP,SAASvE,GAAU,MAAM,IAAII,MAAM,sBAChD,IAOI/B,EAPAsH,EAAe3F,EAAQ2F,cAAgB,EACvCE,EAAoB7F,EAAQ6F,mBAAqB,EACjDC,EAAgB9F,EAAQ8F,eAAiB,EACzCP,EAAavF,EAAQuF,YAAc,EAGnC1G,EAAamB,EAAQnB,WAGzB,OAAQY,EAAQnB,MACd,IAAK,oBACCqH,EAAe,IACjBA,EAAelG,EAAQb,SAASvB,OAASsI,GAC3C9G,EAAaA,GAAcY,EAAQb,SAAS+G,GAAc9G,WAC1DR,EAAWoB,EAAQb,SAAS+G,GAActH,SAC1C,MACF,IAAK,UACHQ,EAAaA,GAAcY,EAAQZ,WACnCR,EAAWoB,EAAQpB,SACnB,MACF,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACHA,EAAWoB,EACX,MACF,QACE,MAAM,IAAIW,MAAM,sBAIpB,GAAiB,OAAb/B,EAAmB,OAAO,KAC9B,IAAIlB,EAASkB,EAASE,YACtB,OAAQF,EAASC,MACf,IAAK,QACH,OAAOwG,EAAQ3E,MAAMhD,EAAQ0B,EAAYmB,GAC3C,IAAK,aAGH,OAFI6F,EAAoB,IACtBA,EAAoB1I,EAAOE,OAASwI,GAC/Bf,EAAQ3E,MAAMhD,EAAO0I,GAAoBhH,EAAYmB,GAC9D,IAAK,aAEH,OADIuF,EAAa,IAAGA,EAAapI,EAAOE,OAASkI,GAC1CT,EAAQ3E,MAAMhD,EAAOoI,GAAa1G,EAAYmB,GACvD,IAAK,UAIH,OAHI8F,EAAgB,IAAGA,EAAgB3I,EAAOE,OAASyI,GACnDP,EAAa,IACfA,EAAapI,EAAO2I,GAAezI,OAASkI,GACvCT,EAAQ3E,MAAMhD,EAAO2I,GAAeP,GAAa1G,EAAYmB,GACtE,IAAK,kBAKH,OAJI6F,EAAoB,IACtBA,EAAoB1I,EAAOE,OAASwI,GAClCN,EAAa,IACfA,EAAapI,EAAO0I,GAAmBxI,OAASkI,GAC3CT,EAAQ3E,MAAMhD,EAAO0I,GAAmBN,GAAa1G,EAAYmB,GAC1E,IAAK,eAQH,OAPI6F,EAAoB,IACtBA,EAAoB1I,EAAOE,OAASwI,GAClCC,EAAgB,IAClBA,EAAgB3I,EAAO0I,GAAmBxI,OAASyI,GACjDP,EAAa,IACfA,EACEpI,EAAO0I,GAAmBC,GAAezI,OAASkI,GAC/CT,EAAQ3E,MACbhD,EAAO0I,GAAmBC,GAAeP,GACzC1G,EACAmB,GAGN,MAAM,IAAII,MAAM,qBAClB,EAQAxD,EAAQgL,YArNR,SAAqBnI,EAASO,GAG5B,GADAA,EAAUA,GAAW,CAAC,GACjB8E,EAAQP,SAASvE,GAAU,MAAM,IAAII,MAAM,sBAChD,IAOI/B,EAPAsH,EAAe3F,EAAQ2F,cAAgB,EACvCE,EAAoB7F,EAAQ6F,mBAAqB,EACjDC,EAAgB9F,EAAQ8F,eAAiB,EACzCY,EAAe1G,EAAQ0G,cAAgB,EAGvC7H,EAAamB,EAAQnB,WAGzB,OAAQY,EAAQnB,MACd,IAAK,oBACCqH,EAAe,IACjBA,EAAelG,EAAQb,SAASvB,OAASsI,GAC3C9G,EAAaA,GAAcY,EAAQb,SAAS+G,GAAc9G,WAC1DR,EAAWoB,EAAQb,SAAS+G,GAActH,SAC1C,MACF,IAAK,UACHQ,EAAaA,GAAcY,EAAQZ,WACnCR,EAAWoB,EAAQpB,SACnB,MACF,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACHA,EAAWoB,EACX,MACF,QACE,MAAM,IAAIW,MAAM,sBAIpB,GAAiB,OAAb/B,EAAmB,OAAO,KAC9B,IAAIlB,EAASkB,EAASE,YACtB,OAAQF,EAASC,MACf,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aAEH,OADIoI,EAAe,IAAGA,EAAevJ,EAAOE,OAASqJ,EAAe,GAC7D5B,EAAQlE,WACb,CAACzD,EAAOuJ,GAAevJ,EAAOuJ,EAAe,IAC7C7H,EACAmB,GAEJ,IAAK,UAIH,OAHI8F,EAAgB,IAAGA,EAAgB3I,EAAOE,OAASyI,GACnDY,EAAe,IACjBA,EAAevJ,EAAO2I,GAAezI,OAASqJ,EAAe,GACxD5B,EAAQlE,WACb,CACEzD,EAAO2I,GAAeY,GACtBvJ,EAAO2I,GAAeY,EAAe,IAEvC7H,EACAmB,GAEJ,IAAK,kBAKH,OAJI6F,EAAoB,IACtBA,EAAoB1I,EAAOE,OAASwI,GAClCa,EAAe,IACjBA,EAAevJ,EAAO0I,GAAmBxI,OAASqJ,EAAe,GAC5D5B,EAAQlE,WACb,CACEzD,EAAO0I,GAAmBa,GAC1BvJ,EAAO0I,GAAmBa,EAAe,IAE3C7H,EACAmB,GAEJ,IAAK,eAQH,OAPI6F,EAAoB,IACtBA,EAAoB1I,EAAOE,OAASwI,GAClCC,EAAgB,IAClBA,EAAgB3I,EAAO0I,GAAmBxI,OAASyI,GACjDY,EAAe,IACjBA,EACEvJ,EAAO0I,GAAmBC,GAAezI,OAASqJ,EAAe,GAC9D5B,EAAQlE,WACb,CACEzD,EAAO0I,GAAmBC,GAAeY,GACzCvJ,EAAO0I,GAAmBC,GAAeY,EAAe,IAE1D7H,EACAmB,GAGN,MAAM,IAAII,MAAM,qBAClB,EAwHAxD,EAAQ4J,YAAcA,EACtB5J,EAAQiL,cAvkBR,SAAuBpI,EAASsF,EAAUwC,GACxC,IAAIC,EAAgBD,EAmBpB,OAlBAf,EACE/G,GACA,SAAUiI,EAAgB/B,EAAcE,GAMpC2B,EAJiB,IAAjB7B,GACsB,IAAtBE,QACiBU,IAAjBgB,EAEgBG,EAEA3C,EACdyC,EACAE,EACA/B,EACAE,EAEN,IAEK2B,CACT,EAmjBA5K,EAAQsJ,SAAWA,EACnBtJ,EAAQkL,WAluBR,SAAoBrI,EAASsF,EAAUwC,GACrC,IAAIC,EAAgBD,EAuBpB,OAtBArB,EACEzG,GACA,SACEsI,EACApC,EACAS,EACAC,EACAC,GAGEkB,EADmB,IAAjB7B,QAAuCY,IAAjBgB,EACRQ,EAEAhD,EACdyC,EACAO,EACApC,EACAS,EACAC,EACAC,EAEN,IAEKkB,CACT,EA0sBA5K,EAAQuK,SAAWA,EACnBvK,EAAQoL,WAjRR,SAAoBvI,EAASsF,EAAUwC,GACrC,IAAIC,EAAgBD,EAgBpB,OAfAJ,EACE1H,GACA,SAAUwI,EAAatC,EAAcE,EAAmBC,GAEpD0B,EADmB,IAAjB7B,QAAuCY,IAAjBgB,EACRU,EAEAlD,EACdyC,EACAS,EACAtC,EACAE,EACAC,EAEN,IAEK0B,CACT,EAgQA5K,EAAQoJ,SAAWA,EACnBpJ,EAAQsL,WAviCR,SAAoBzI,EAASsF,EAAUwC,GACrC,IAAIC,EAAgBD,EAOpB,OANAvB,EAASvG,GAAS,SAAU0I,EAAmBxC,GAE3C6B,EADmB,IAAjB7B,QAAuCY,IAAjBgB,EACRY,EAEApD,EAASyC,EAAeW,EAAmBxC,EAC/D,IACO6B,CACT,EA+hCA5K,EAAQ6J,YAAcA,EACtB7J,EAAQwL,cAhaR,SAAuB3I,EAASsF,EAAUwC,GACxC,IAAIC,EAAgBD,EAChBc,GAAU,EAwBd,OAvBA5B,EACEhH,GACA,SACEyH,EACAvB,EACAE,EACAC,EACAY,GAGEc,GADc,IAAZa,QAAsC9B,IAAjBgB,EACPL,EAEAnC,EACdyC,EACAN,EACAvB,EACAE,EACAC,EACAY,GAEJ2B,GAAU,CACZ,IAEKb,CACT,C,sBCjgCA3K,EAAOD,QAAU,SAAS0L,EAAMC,EAAGC,GACjC,GAAID,IAAMC,EAAG,OAAO,EAEpB,GAAID,GAAKC,GAAiB,iBAALD,GAA6B,iBAALC,EAAe,CAC1D,GAAID,EAAE9D,cAAgB+D,EAAE/D,YAAa,OAAO,EAE5C,IAAIpH,EAAQI,EAAGgL,EACf,GAAIpI,MAAMC,QAAQiI,GAAI,CAEpB,IADAlL,EAASkL,EAAElL,SACGmL,EAAEnL,OAAQ,OAAO,EAC/B,IAAKI,EAAIJ,EAAgB,GAARI,KACf,IAAK6K,EAAMC,EAAE9K,GAAI+K,EAAE/K,IAAK,OAAO,EACjC,OAAO,CACT,CAIA,GAAI8K,EAAE9D,cAAgBiE,OAAQ,OAAOH,EAAEI,SAAWH,EAAEG,QAAUJ,EAAEK,QAAUJ,EAAEI,MAC5E,GAAIL,EAAEM,UAAYjH,OAAOkH,UAAUD,QAAS,OAAON,EAAEM,YAAcL,EAAEK,UACrE,GAAIN,EAAEQ,WAAanH,OAAOkH,UAAUC,SAAU,OAAOR,EAAEQ,aAAeP,EAAEO,WAIxE,IADA1L,GADAoL,EAAO7G,OAAO6G,KAAKF,IACLlL,UACCuE,OAAO6G,KAAKD,GAAGnL,OAAQ,OAAO,EAE7C,IAAKI,EAAIJ,EAAgB,GAARI,KACf,IAAKmE,OAAOkH,UAAUE,eAAeC,KAAKT,EAAGC,EAAKhL,IAAK,OAAO,EAEhE,IAAKA,EAAIJ,EAAgB,GAARI,KAAY,CAC3B,IAAIyL,EAAMT,EAAKhL,GAEf,IAAK6K,EAAMC,EAAEW,GAAMV,EAAEU,IAAO,OAAO,CACrC,CAEA,OAAO,CACT,CAGA,OAAOX,GAAIA,GAAKC,GAAIA,CACtB,C,gBC7CA,IAAIW,EAAQ,EAAQ,KAChBrE,EAAU,EAAQ,KAClBsE,EAAO,EAAQ,KACfC,EAAW,SACXpD,EAAcmD,EAAKnD,YAGnBpF,GAFYuI,EAAKxJ,UACPkF,EAAQtE,QACEsE,EAAQjE,mBAahC,SAASyI,EAAaC,GAClB,IAAIC,EAAO,IAAIL,EAAMI,GAsLrB,OA5KAC,EAAKC,OAAS,SAAU3J,GACpB,GAAqB,YAAjBA,EAAQxB,KAAoB,MAAM,IAAI8B,MAAM,mBAEhD,OADAN,EAAQN,KAAOM,EAAQN,KAAOM,EAAQN,KAAO6J,EAASvJ,GAC/CqJ,EAAML,UAAUW,OAAOR,KAAKjM,KAAM8C,EAC7C,EAcA0J,EAAKE,KAAO,SAAU9K,GAClB,IAAI8K,EAAO,GAgBX,OAdIrJ,MAAMC,QAAQ1B,GACdA,EAAS+F,SAAQ,SAAU7E,GACvB,GAAqB,YAAjBA,EAAQxB,KAAoB,MAAM,IAAI8B,MAAM,oBAChDN,EAAQN,KAAOM,EAAQN,KAAOM,EAAQN,KAAO6J,EAASvJ,GACtD4J,EAAKrC,KAAKvH,EACd,IAGAmG,EAAYrH,GAAU,SAAUkB,GAC5B,GAAqB,YAAjBA,EAAQxB,KAAoB,MAAM,IAAI8B,MAAM,oBAChDN,EAAQN,KAAOM,EAAQN,KAAOM,EAAQN,KAAO6J,EAASvJ,GACtD4J,EAAKrC,KAAKvH,EACd,IAEGqJ,EAAML,UAAUY,KAAKT,KAAKjM,KAAM0M,EAC3C,EAaAF,EAAKG,OAAS,SAAU7J,EAAS8J,GAC7B,GAAqB,YAAjB9J,EAAQxB,KAAoB,MAAM,IAAI8B,MAAM,mBAEhD,OADAN,EAAQN,KAAOM,EAAQN,KAAOM,EAAQN,KAAO6J,EAASvJ,GAC/CqJ,EAAML,UAAUa,OAAOV,KAAKjM,KAAM8C,EAAS8J,EACtD,EASAJ,EAAKK,MAAQ,WACT,OAAOV,EAAML,UAAUe,MAAMZ,KAAKjM,KACtC,EAYAwM,EAAKM,OAAS,SAAUrK,GACpB,IAAIb,EAAWuK,EAAML,UAAUgB,OAAOb,KAAKjM,KAAMA,KAAK+M,OAAOtK,IAC7D,OAAOoB,EAAkBjC,EAC7B,EAYA4K,EAAKQ,SAAW,SAAUvK,GACtB,OAAO0J,EAAML,UAAUkB,SAASf,KAAKjM,KAAMA,KAAK+M,OAAOtK,GAC3D,EASA+J,EAAKS,IAAM,WACP,IAAIrL,EAAWuK,EAAML,UAAUmB,IAAIhB,KAAKjM,MACxC,OAAO6D,EAAkBjC,EAC7B,EASA4K,EAAKU,OAAS,WACV,OAAOf,EAAML,UAAUoB,OAAOjB,KAAKjM,KACvC,EA6BAwM,EAAKW,SAAW,SAAUC,GACtB,OAAOjB,EAAML,UAAUqB,SAASlB,KAAKjM,KAAMoN,EAC/C,EASAZ,EAAKO,OAAS,SAAUtK,GACpB,IAAID,EACJ,GAAIC,EAAQD,KAAMA,EAAOC,EAAQD,UAC5B,GAAIa,MAAMC,QAAQb,IAA+B,IAAnBA,EAAQpC,OAAcmC,EAAOC,OAC3D,GAAIY,MAAMC,QAAQb,IAA+B,IAAnBA,EAAQpC,OAAcmC,EAAO,CAACC,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,SACxG,GAAqB,YAAjBA,EAAQnB,KAAoBkB,EAAO6J,EAAS5J,OAChD,IAAqB,sBAAjBA,EAAQnB,KACZ,MAAM,IAAI8B,MAAM,mBAD0BZ,EAAO6J,EAAS5J,EACzB,CAEtC,MAAO,CACH4K,KAAM7K,EAAK,GACX8K,KAAM9K,EAAK,GACX+K,KAAM/K,EAAK,GACXgL,KAAMhL,EAAK,GAEnB,EACOgK,CACX,CAEA3M,EAAOD,QAAU0M,EACjBzM,EAAOD,QAAP,QAAyB0M,C,kBC/M2CzM,EAAOD,QAAwF,WAAW,aAAa,SAAS6N,EAAEA,EAAEC,EAAEC,EAAEpC,EAAEqC,IAAI,SAASH,EAAEI,EAAEH,EAAEC,EAAEpC,EAAEqC,GAAG,KAAKrC,EAAEoC,GAAG,CAAC,GAAGpC,EAAEoC,EAAE,IAAI,CAAC,IAAIG,EAAEvC,EAAEoC,EAAE,EAAEI,EAAEL,EAAEC,EAAE,EAAEzF,EAAE5H,KAAK0N,IAAIF,GAAGG,EAAE,GAAG3N,KAAK4N,IAAI,EAAEhG,EAAE,GAAGiG,EAAE,GAAG7N,KAAK8N,KAAKlG,EAAE+F,GAAGH,EAAEG,GAAGH,IAAIC,EAAED,EAAE,EAAE,GAAG,EAAE,GAA+EL,EAAEI,EAAEH,EAA9EpN,KAAK+N,IAAIV,EAAErN,KAAKgO,MAAMZ,EAAEK,EAAEE,EAAEH,EAAEK,IAAM7N,KAAKiO,IAAIhD,EAAEjL,KAAKgO,MAAMZ,GAAGI,EAAEC,GAAGE,EAAEH,EAAEK,IAAcP,EAAE,CAAC,IAAIY,EAAEX,EAAEH,GAAGe,EAAEd,EAAEe,EAAEnD,EAAE,IAAI9K,EAAEoN,EAAEF,EAAED,GAAGE,EAAEC,EAAEtC,GAAGiD,GAAG,GAAG/N,EAAEoN,EAAEF,EAAEpC,GAAGkD,EAAEC,GAAG,CAAC,IAAIjO,EAAEoN,EAAEY,EAAEC,GAAGD,IAAIC,IAAId,EAAEC,EAAEY,GAAGD,GAAG,GAAGC,IAAI,KAAKb,EAAEC,EAAEa,GAAGF,GAAG,GAAGE,GAAG,CAAC,IAAId,EAAEC,EAAEF,GAAGa,GAAG/N,EAAEoN,EAAEF,EAAEe,GAAGjO,EAAEoN,IAAIa,EAAEnD,GAAGmD,GAAGhB,IAAIC,EAAEe,EAAE,GAAGhB,GAAGgB,IAAInD,EAAEmD,EAAE,EAAE,CAAC,CAA9Z,CAAgajB,EAAEC,EAAEC,GAAG,EAAEpC,GAAGkC,EAAEpN,OAAO,EAAEuN,GAAGC,EAAE,CAAC,SAASpN,EAAEgN,EAAEhN,EAAEoN,GAAG,IAAIH,EAAED,EAAEhN,GAAGgN,EAAEhN,GAAGgN,EAAEI,GAAGJ,EAAEI,GAAGH,CAAC,CAAC,SAASG,EAAEJ,EAAEhN,GAAG,OAAOgN,EAAEhN,GAAG,EAAEgN,EAAEhN,EAAE,EAAE,CAAC,CAAC,IAAIiN,EAAE,SAASD,QAAG,IAASA,IAAIA,EAAE,GAAGzN,KAAK2O,YAAYrO,KAAK+N,IAAI,EAAEZ,GAAGzN,KAAK4O,YAAYtO,KAAK+N,IAAI,EAAE/N,KAAKuO,KAAK,GAAG7O,KAAK2O,cAAc3O,KAAK6M,OAAO,EAAE,SAASc,EAAEF,EAAEhN,EAAEoN,GAAG,IAAIA,EAAE,OAAOpN,EAAEoH,QAAQ4F,GAAG,IAAI,IAAIC,EAAE,EAAEA,EAAEjN,EAAEJ,OAAOqN,IAAI,GAAGG,EAAEJ,EAAEhN,EAAEiN,IAAI,OAAOA,EAAE,OAAO,CAAC,CAAC,SAASnC,EAAEkC,EAAEhN,GAAGmN,EAAEH,EAAE,EAAEA,EAAEqB,SAASzO,OAAOI,EAAEgN,EAAE,CAAC,SAASG,EAAEH,EAAEhN,EAAEoN,EAAEH,EAAEC,GAAGA,IAAIA,EAAEa,EAAE,OAAOb,EAAEN,KAAK,IAAIM,EAAEL,KAAK,IAAIK,EAAEJ,MAAK,IAAKI,EAAEH,MAAK,IAAK,IAAI,IAAIjC,EAAE9K,EAAE8K,EAAEsC,EAAEtC,IAAI,CAAC,IAAIqC,EAAEH,EAAEqB,SAASvD,GAAGuC,EAAEH,EAAEF,EAAEsB,KAAKrB,EAAEE,GAAGA,EAAE,CAAC,OAAOD,CAAC,CAAC,SAASG,EAAEL,EAAEhN,GAAG,OAAOgN,EAAEJ,KAAK/M,KAAKiO,IAAId,EAAEJ,KAAK5M,EAAE4M,MAAMI,EAAEH,KAAKhN,KAAKiO,IAAId,EAAEH,KAAK7M,EAAE6M,MAAMG,EAAEF,KAAKjN,KAAK+N,IAAIZ,EAAEF,KAAK9M,EAAE8M,MAAME,EAAED,KAAKlN,KAAK+N,IAAIZ,EAAED,KAAK/M,EAAE+M,MAAMC,CAAC,CAAC,SAASM,EAAEN,EAAEhN,GAAG,OAAOgN,EAAEJ,KAAK5M,EAAE4M,IAAI,CAAC,SAASnF,EAAEuF,EAAEhN,GAAG,OAAOgN,EAAEH,KAAK7M,EAAE6M,IAAI,CAAC,SAASW,EAAER,GAAG,OAAOA,EAAEF,KAAKE,EAAEJ,OAAOI,EAAED,KAAKC,EAAEH,KAAK,CAAC,SAASa,EAAEV,GAAG,OAAOA,EAAEF,KAAKE,EAAEJ,MAAMI,EAAED,KAAKC,EAAEH,KAAK,CAAC,SAAS0B,EAAEvB,EAAEhN,GAAG,OAAOgN,EAAEJ,MAAM5M,EAAE4M,MAAMI,EAAEH,MAAM7M,EAAE6M,MAAM7M,EAAE8M,MAAME,EAAEF,MAAM9M,EAAE+M,MAAMC,EAAED,IAAI,CAAC,SAASyB,EAAExB,EAAEhN,GAAG,OAAOA,EAAE4M,MAAMI,EAAEF,MAAM9M,EAAE6M,MAAMG,EAAED,MAAM/M,EAAE8M,MAAME,EAAEJ,MAAM5M,EAAE+M,MAAMC,EAAEH,IAAI,CAAC,SAASkB,EAAEf,GAAG,MAAM,CAACqB,SAASrB,EAAEyB,OAAO,EAAEH,MAAK,EAAG1B,KAAK,IAAIC,KAAK,IAAIC,MAAK,IAAKC,MAAK,IAAK,CAAC,SAASiB,EAAEhO,EAAEoN,EAAEH,EAAEC,EAAEpC,GAAG,IAAI,IAAIqC,EAAE,CAACC,EAAEH,GAAGE,EAAEvN,QAAQ,MAAMqN,EAAEE,EAAEuB,QAAQtB,EAAED,EAAEuB,QAAQxB,GAAG,CAAC,IAAIG,EAAED,EAAEvN,KAAKuO,MAAMnB,EAAEG,GAAGF,EAAE,GAAGA,EAAEF,EAAEhN,EAAEqN,EAAED,EAAEH,EAAEnC,GAAGqC,EAAEvD,KAAKwD,EAAEC,EAAEA,EAAEJ,EAAE,CAAC,CAAC,OAAOA,EAAE5B,UAAUmB,IAAI,WAAW,OAAOjN,KAAKoP,KAAKpP,KAAKqP,KAAK,GAAG,EAAE3B,EAAE5B,UAAUgB,OAAO,SAASW,GAAG,IAAIhN,EAAET,KAAKqP,KAAKxB,EAAE,GAAG,IAAIoB,EAAExB,EAAEhN,GAAG,OAAOoN,EAAE,IAAI,IAAIH,EAAE1N,KAAK+M,OAAOY,EAAE,GAAGlN,GAAG,CAAC,IAAI,IAAI8K,EAAE,EAAEA,EAAE9K,EAAEqO,SAASzO,OAAOkL,IAAI,CAAC,IAAIqC,EAAEnN,EAAEqO,SAASvD,GAAGuC,EAAErN,EAAEsO,KAAKrB,EAAEE,GAAGA,EAAEqB,EAAExB,EAAEK,KAAKrN,EAAEsO,KAAKlB,EAAExD,KAAKuD,GAAGoB,EAAEvB,EAAEK,GAAG9N,KAAKoP,KAAKxB,EAAEC,GAAGF,EAAEtD,KAAKuD,GAAG,CAACnN,EAAEkN,EAAEwB,KAAK,CAAC,OAAOtB,CAAC,EAAEH,EAAE5B,UAAUkB,SAAS,SAASS,GAAG,IAAIhN,EAAET,KAAKqP,KAAK,IAAIJ,EAAExB,EAAEhN,GAAG,OAAM,EAAG,IAAI,IAAIoN,EAAE,GAAGpN,GAAG,CAAC,IAAI,IAAIiN,EAAE,EAAEA,EAAEjN,EAAEqO,SAASzO,OAAOqN,IAAI,CAAC,IAAIC,EAAElN,EAAEqO,SAASpB,GAAGnC,EAAE9K,EAAEsO,KAAK/O,KAAK+M,OAAOY,GAAGA,EAAE,GAAGsB,EAAExB,EAAElC,GAAG,CAAC,GAAG9K,EAAEsO,MAAMC,EAAEvB,EAAElC,GAAG,OAAM,EAAGsC,EAAExD,KAAKsD,EAAE,CAAC,CAAClN,EAAEoN,EAAEsB,KAAK,CAAC,OAAM,CAAE,EAAEzB,EAAE5B,UAAUY,KAAK,SAASe,GAAG,IAAIA,IAAIA,EAAEpN,OAAO,OAAOL,KAAK,GAAGyN,EAAEpN,OAAOL,KAAK4O,YAAY,CAAC,IAAI,IAAInO,EAAE,EAAEA,EAAEgN,EAAEpN,OAAOI,IAAIT,KAAKyM,OAAOgB,EAAEhN,IAAI,OAAOT,IAAI,CAAC,IAAI6N,EAAE7N,KAAKsP,OAAO7B,EAAE8B,QAAQ,EAAE9B,EAAEpN,OAAO,EAAE,GAAG,GAAGL,KAAKqP,KAAKP,SAASzO,OAAO,GAAGL,KAAKqP,KAAKH,SAASrB,EAAEqB,OAAOlP,KAAKwP,WAAWxP,KAAKqP,KAAKxB,OAAO,CAAC,GAAG7N,KAAKqP,KAAKH,OAAOrB,EAAEqB,OAAO,CAAC,IAAIxB,EAAE1N,KAAKqP,KAAKrP,KAAKqP,KAAKxB,EAAEA,EAAEH,CAAC,CAAC1N,KAAKyP,QAAQ5B,EAAE7N,KAAKqP,KAAKH,OAAOrB,EAAEqB,OAAO,GAAE,EAAG,MAAMlP,KAAKqP,KAAKxB,EAAE,OAAO7N,IAAI,EAAE0N,EAAE5B,UAAUW,OAAO,SAASgB,GAAG,OAAOA,GAAGzN,KAAKyP,QAAQhC,EAAEzN,KAAKqP,KAAKH,OAAO,GAAGlP,IAAI,EAAE0N,EAAE5B,UAAUe,MAAM,WAAW,OAAO7M,KAAKqP,KAAKb,EAAE,IAAIxO,IAAI,EAAE0N,EAAE5B,UAAUa,OAAO,SAASc,EAAEhN,GAAG,IAAIgN,EAAE,OAAOzN,KAAK,IAAI,IAAI6N,EAAEH,EAAEnC,EAAEqC,EAAE5N,KAAKqP,KAAKvB,EAAE9N,KAAK+M,OAAOU,GAAGM,EAAE,GAAG7F,EAAE,GAAG0F,GAAGG,EAAE1N,QAAQ,CAAC,GAAGuN,IAAIA,EAAEG,EAAEoB,MAAMzB,EAAEK,EAAEA,EAAE1N,OAAO,GAAGwN,EAAE3F,EAAEiH,MAAM5D,GAAE,GAAIqC,EAAEmB,KAAK,CAAC,IAAId,EAAEN,EAAEF,EAAEG,EAAEkB,SAASrO,GAAG,IAAI,IAAIwN,EAAE,OAAOL,EAAEkB,SAASY,OAAOzB,EAAE,GAAGF,EAAE1D,KAAKuD,GAAG5N,KAAK2P,UAAU5B,GAAG/N,IAAI,CAACuL,GAAGqC,EAAEmB,OAAOC,EAAEpB,EAAEE,GAAGJ,GAAGG,IAAID,EAAEF,EAAEoB,SAASjB,GAAGtC,GAAE,GAAIqC,EAAE,MAAMG,EAAE1D,KAAKuD,GAAG1F,EAAEmC,KAAKwD,GAAGA,EAAE,EAAEH,EAAEE,EAAEA,EAAEA,EAAEkB,SAAS,GAAG,CAAC,OAAO9O,IAAI,EAAE0N,EAAE5B,UAAUiB,OAAO,SAASU,GAAG,OAAOA,CAAC,EAAEC,EAAE5B,UAAU8D,YAAY,SAASnC,EAAEhN,GAAG,OAAOgN,EAAEJ,KAAK5M,EAAE4M,IAAI,EAAEK,EAAE5B,UAAU+D,YAAY,SAASpC,EAAEhN,GAAG,OAAOgN,EAAEH,KAAK7M,EAAE6M,IAAI,EAAEI,EAAE5B,UAAUoB,OAAO,WAAW,OAAOlN,KAAKqP,IAAI,EAAE3B,EAAE5B,UAAUqB,SAAS,SAASM,GAAG,OAAOzN,KAAKqP,KAAK5B,EAAEzN,IAAI,EAAE0N,EAAE5B,UAAUsD,KAAK,SAAS3B,EAAEhN,GAAG,IAAI,IAAIoN,EAAE,GAAGJ,GAAGA,EAAEsB,KAAKtO,EAAE4J,KAAKyF,MAAMrP,EAAEgN,EAAEqB,UAAUjB,EAAExD,KAAKyF,MAAMjC,EAAEJ,EAAEqB,UAAUrB,EAAEI,EAAEsB,MAAM,OAAO1O,CAAC,EAAEiN,EAAE5B,UAAUwD,OAAO,SAAS7B,EAAEhN,EAAEoN,EAAEH,GAAG,IAAIC,EAAEC,EAAEC,EAAEpN,EAAE,EAAEqN,EAAE9N,KAAK2O,YAAY,GAAGf,GAAGE,EAAE,OAAOvC,EAAEoC,EAAEa,EAAEf,EAAE8B,MAAM9O,EAAEoN,EAAE,IAAI7N,KAAK+M,QAAQY,EAAED,IAAIA,EAAEpN,KAAKuO,KAAKvO,KAAK0N,IAAIJ,GAAGtN,KAAK0N,IAAIF,IAAIA,EAAExN,KAAKuO,KAAKjB,EAAEtN,KAAKqG,IAAImH,EAAEJ,EAAE,MAAMC,EAAEa,EAAE,KAAKO,MAAK,EAAGpB,EAAEuB,OAAOxB,EAAE,IAAIK,EAAEzN,KAAKuO,KAAKjB,EAAEE,GAAG5F,EAAE6F,EAAEzN,KAAKuO,KAAKvO,KAAK8N,KAAKN,IAAIW,EAAEhB,EAAEhN,EAAEoN,EAAE3F,EAAElI,KAAK4P,aAAa,IAAI,IAAI3B,EAAExN,EAAEwN,GAAGJ,EAAEI,GAAG/F,EAAE,CAAC,IAAIiG,EAAE7N,KAAKiO,IAAIN,EAAE/F,EAAE,EAAE2F,GAAGY,EAAEhB,EAAEQ,EAAEE,EAAEJ,EAAE/N,KAAK6P,aAAa,IAAI,IAAIb,EAAEf,EAAEe,GAAGb,EAAEa,GAAGjB,EAAE,CAAC,IAAIkB,EAAE3O,KAAKiO,IAAIS,EAAEjB,EAAE,EAAEI,GAAGR,EAAEmB,SAASzE,KAAKrK,KAAKsP,OAAO7B,EAAEuB,EAAEC,EAAEvB,EAAE,GAAG,CAAC,CAAC,OAAOnC,EAAEoC,EAAE3N,KAAK+M,QAAQY,CAAC,EAAED,EAAE5B,UAAUiE,eAAe,SAAStC,EAAEhN,EAAEoN,EAAEH,GAAG,KAAKA,EAAErD,KAAK5J,IAAIA,EAAEsO,MAAMrB,EAAErN,OAAO,IAAIwN,GAAG,CAAC,IAAI,IAAIF,EAAE,IAAIpC,EAAE,IAAIqC,OAAE,EAAOE,EAAE,EAAEA,EAAErN,EAAEqO,SAASzO,OAAOyN,IAAI,CAAC,IAAIC,EAAEtN,EAAEqO,SAAShB,GAAG5F,EAAE+F,EAAEF,GAAGI,GAAGa,EAAEvB,EAAEwB,EAAElB,GAAGzN,KAAK+N,IAAIY,EAAE1B,KAAKyB,EAAEzB,MAAMjN,KAAKiO,IAAIU,EAAE5B,KAAK2B,EAAE3B,QAAQ/M,KAAK+N,IAAIY,EAAEzB,KAAKwB,EAAExB,MAAMlN,KAAKiO,IAAIU,EAAE3B,KAAK0B,EAAE1B,OAAOpF,GAAGiG,EAAE5C,GAAGA,EAAE4C,EAAER,EAAEzF,EAAEyF,EAAEzF,EAAEyF,EAAEC,EAAEG,GAAGI,IAAI5C,GAAGrD,EAAEyF,IAAIA,EAAEzF,EAAE0F,EAAEG,EAAE,CAACtN,EAAEmN,GAAGnN,EAAEqO,SAAS,EAAE,CAAC,IAAIE,EAAEC,EAAE,OAAOxO,CAAC,EAAEiN,EAAE5B,UAAU2D,QAAQ,SAAShC,EAAEhN,EAAEoN,GAAG,IAAIH,EAAEG,EAAEJ,EAAEzN,KAAK+M,OAAOU,GAAGE,EAAE,GAAGpC,EAAEvL,KAAK+P,eAAerC,EAAE1N,KAAKqP,KAAK5O,EAAEkN,GAAG,IAAIpC,EAAEuD,SAASzE,KAAKoD,GAAGK,EAAEvC,EAAEmC,GAAGjN,GAAG,GAAGkN,EAAElN,GAAGqO,SAASzO,OAAOL,KAAK2O,aAAa3O,KAAKgQ,OAAOrC,EAAElN,GAAGA,IAAIT,KAAKiQ,oBAAoBvC,EAAEC,EAAElN,EAAE,EAAEiN,EAAE5B,UAAUkE,OAAO,SAASvC,EAAEhN,GAAG,IAAIoN,EAAEJ,EAAEhN,GAAGiN,EAAEG,EAAEiB,SAASzO,OAAOsN,EAAE3N,KAAK4O,YAAY5O,KAAKkQ,iBAAiBrC,EAAEF,EAAED,GAAG,IAAIE,EAAE5N,KAAKmQ,kBAAkBtC,EAAEF,EAAED,GAAGI,EAAEU,EAAEX,EAAEiB,SAASY,OAAO9B,EAAEC,EAAEiB,SAASzO,OAAOuN,IAAIE,EAAEoB,OAAOrB,EAAEqB,OAAOpB,EAAEiB,KAAKlB,EAAEkB,KAAKxD,EAAEsC,EAAE7N,KAAK+M,QAAQxB,EAAEuC,EAAE9N,KAAK+M,QAAQtM,EAAEgN,EAAEhN,EAAE,GAAGqO,SAASzE,KAAKyD,GAAG9N,KAAKwP,WAAW3B,EAAEC,EAAE,EAAEJ,EAAE5B,UAAU0D,WAAW,SAAS/B,EAAEhN,GAAGT,KAAKqP,KAAKb,EAAE,CAACf,EAAEhN,IAAIT,KAAKqP,KAAKH,OAAOzB,EAAEyB,OAAO,EAAElP,KAAKqP,KAAKN,MAAK,EAAGxD,EAAEvL,KAAKqP,KAAKrP,KAAK+M,OAAO,EAAEW,EAAE5B,UAAUqE,kBAAkB,SAAS1C,EAAEhN,EAAEoN,GAAG,IAAI,IAAIH,EAAEC,EAAEpC,EAAEuC,EAAEC,EAAE7F,EAAEiG,EAAEa,EAAE,IAAIC,EAAE,IAAIT,EAAE/N,EAAE+N,GAAGX,EAAEpN,EAAE+N,IAAI,CAAC,IAAIC,EAAEb,EAAEH,EAAE,EAAEe,EAAExO,KAAK+M,QAAQ2B,EAAEd,EAAEH,EAAEe,EAAEX,EAAE7N,KAAK+M,QAAQqD,GAAGzC,EAAEc,EAAElD,EAAEmD,EAAEZ,OAAE,EAAOC,OAAE,EAAO7F,OAAE,EAAOiG,OAAE,EAAOL,EAAExN,KAAK+N,IAAIV,EAAEN,KAAK9B,EAAE8B,MAAMU,EAAEzN,KAAK+N,IAAIV,EAAEL,KAAK/B,EAAE+B,MAAMpF,EAAE5H,KAAKiO,IAAIZ,EAAEJ,KAAKhC,EAAEgC,MAAMY,EAAE7N,KAAKiO,IAAIZ,EAAEH,KAAKjC,EAAEiC,MAAMlN,KAAK+N,IAAI,EAAEnG,EAAE4F,GAAGxN,KAAK+N,IAAI,EAAEF,EAAEJ,IAAIsC,EAAEpC,EAAEQ,GAAGR,EAAES,GAAG0B,EAAEpB,GAAGA,EAAEoB,EAAE1C,EAAEc,EAAES,EAAEoB,EAAEpB,EAAEoB,EAAEpB,GAAGmB,IAAIpB,GAAGqB,EAAEpB,IAAIA,EAAEoB,EAAE3C,EAAEc,EAAE,CAAC,OAAOd,GAAGG,EAAEpN,CAAC,EAAEiN,EAAE5B,UAAUoE,iBAAiB,SAASzC,EAAEhN,EAAEoN,GAAG,IAAIH,EAAED,EAAEsB,KAAK/O,KAAK4P,YAAY7B,EAAEJ,EAAEF,EAAEsB,KAAK/O,KAAK6P,YAAY3H,EAAElI,KAAKsQ,eAAe7C,EAAEhN,EAAEoN,EAAEH,GAAG1N,KAAKsQ,eAAe7C,EAAEhN,EAAEoN,EAAEF,IAAIF,EAAEqB,SAASyB,KAAK7C,EAAE,EAAEA,EAAE5B,UAAUwE,eAAe,SAAS7C,EAAEhN,EAAEoN,EAAEH,GAAGD,EAAEqB,SAASyB,KAAK7C,GAAG,IAAI,IAAIC,EAAE3N,KAAK+M,OAAOxB,EAAEqC,EAAEH,EAAE,EAAEhN,EAAEkN,GAAGI,EAAEH,EAAEH,EAAEI,EAAEpN,EAAEoN,EAAEF,GAAGzF,EAAEiG,EAAE5C,GAAG4C,EAAEJ,GAAGE,EAAExN,EAAEwN,EAAEJ,EAAEpN,EAAEwN,IAAI,CAAC,IAAIe,EAAEvB,EAAEqB,SAASb,GAAGH,EAAEvC,EAAEkC,EAAEsB,KAAKpB,EAAEqB,GAAGA,GAAG9G,GAAGiG,EAAE5C,EAAE,CAAC,IAAI,IAAI0D,EAAEpB,EAAEpN,EAAE,EAAEwO,GAAGxO,EAAEwO,IAAI,CAAC,IAAIT,EAAEf,EAAEqB,SAASG,GAAGnB,EAAEC,EAAEN,EAAEsB,KAAKpB,EAAEa,GAAGA,GAAGtG,GAAGiG,EAAEJ,EAAE,CAAC,OAAO7F,CAAC,EAAEwF,EAAE5B,UAAUmE,oBAAoB,SAASxC,EAAEhN,EAAEoN,GAAG,IAAI,IAAIH,EAAEG,EAAEH,GAAG,EAAEA,IAAII,EAAErN,EAAEiN,GAAGD,EAAE,EAAEC,EAAE5B,UAAU6D,UAAU,SAASlC,GAAG,IAAI,IAAIhN,EAAEgN,EAAEpN,OAAO,EAAEwN,OAAE,EAAOpN,GAAG,EAAEA,IAAI,IAAIgN,EAAEhN,GAAGqO,SAASzO,OAAOI,EAAE,GAAGoN,EAAEJ,EAAEhN,EAAE,GAAGqO,UAAUY,OAAO7B,EAAEhG,QAAQ4F,EAAEhN,IAAI,GAAGT,KAAK6M,QAAQtB,EAAEkC,EAAEhN,GAAGT,KAAK+M,OAAO,EAAEW,CAAC,CAAzuMjN,E,UCAnFZ,EAAOD,QAAQsB,OAAS,QACxBrB,EAAOD,QAAQ4Q,WAAa,EAAE,cAC9B3Q,EAAOD,QAAQ6Q,aAAe,Y,GCD1BC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBrH,IAAjBsH,EACH,OAAOA,EAAajR,QAGrB,IAAIC,EAAS6Q,EAAyBE,GAAY,CAGjDhR,QAAS,CAAC,GAOX,OAHAkR,EAAoBF,GAAU3E,KAAKpM,EAAOD,QAASC,EAAQA,EAAOD,QAAS+Q,GAGpE9Q,EAAOD,OACf,CCrBA+Q,EAAoBlC,EAAI,CAAC7O,EAASmR,KACjC,IAAI,IAAI7E,KAAO6E,EACXJ,EAAoB7C,EAAEiD,EAAY7E,KAASyE,EAAoB7C,EAAElO,EAASsM,IAC5EtH,OAAOC,eAAejF,EAASsM,EAAK,CAAE8E,YAAY,EAAMC,IAAKF,EAAW7E,IAE1E,ECNDyE,EAAoB7C,EAAI,CAACoD,EAAKC,IAAUvM,OAAOkH,UAAUE,eAAeC,KAAKiF,EAAKC,GCClFR,EAAoBjD,EAAK9N,IACH,oBAAXwR,QAA0BA,OAAOC,aAC1CzM,OAAOC,eAAejF,EAASwR,OAAOC,YAAa,CAAEvM,MAAO,WAE7DF,OAAOC,eAAejF,EAAS,aAAc,CAAEkF,OAAO,GAAO,E,gyCCJ9D,MAkHA,EAlHoB,SAASwM,EAAMC,GAEjC,MAAMC,EAAW,CACfC,KAAM,GACNC,MAAO,GACPC,UAAW,GACXC,UAAW,GACXC,QAAS,GACTC,SAAU,GACVC,QAAS,GACTC,MAAO,GACPC,WAAY,GACZC,UAAW,GACXC,SAAU,GACVC,IAAK,IAGDC,EAAM,CACV,EAAAC,CAAGC,EAAOC,EAAUC,GAClB,QAAwBlJ,IAApBiI,EAASe,GACX,MAAM,IAAInP,MAAM,uBAAuBmP,KAEzCf,EAASe,GAAOlI,KAAK,CACnBmI,WACAC,MAEJ,EACA,MAAAC,CAAOxP,GACLqO,EAAYoB,MAAMC,eAAe1P,EACnC,GAGI2P,EAAW,SAAUC,EAAWP,GACpC,MAAMQ,EAAUvB,EAASsB,GACzB,IAAIE,EAAUD,EAAQ1S,OACtB,KAAO2S,KAAW,CAChB,MAAMC,EAASF,EAAQC,GACvB,GAAIC,EAAOT,SAASD,GAAQ,CACPU,EAAOR,GAAGxG,KAAKoG,EAAKE,IAErChB,EAAYoB,MAAMD,SAEpBnB,EAAY2B,GAAGC,mBAKf,KACF,CACF,CACF,EAIA,OAFA7B,EAAK8B,MAAMnH,KAAKoG,GAET,CACLK,OAAQpB,EAAKoB,OACb,IAAAhK,GACM4I,EAAK5I,MAAM4I,EAAK5I,MACtB,EACA,KAAA2K,GACM/B,EAAK+B,QACP/B,EAAK+B,QACL9B,EAAYoB,MAAMD,SAEtB,EACA,eAAAY,GACMhC,EAAKgC,iBACPhC,EAAKgC,iBAET,EACA,iBAAAC,GACMjC,EAAKiC,mBACPjC,EAAKiC,mBAET,EACA,IAAA9B,CAAKc,GACHM,EAAS,OAAQN,EACnB,EACA,KAAAb,CAAMa,GACJM,EAAS,QAASN,EACpB,EACA,SAAAZ,CAAUY,GACRM,EAAS,YAAaN,EACxB,EACA,SAAAX,CAAUW,GACRM,EAAS,YAAaN,EACxB,EACA,OAAAV,CAAQU,GACNM,EAAS,UAAWN,EACtB,EACA,QAAAT,CAASS,GACPM,EAAS,WAAYN,EACvB,EACA,OAAAR,CAAQQ,GACNM,EAAS,UAAWN,EACtB,EACA,KAAAP,CAAMO,GACJM,EAAS,QAASN,EACpB,EACA,UAAAN,CAAWM,GACTM,EAAS,aAAcN,EACzB,EACA,SAAAL,CAAUK,GACRM,EAAS,YAAaN,EACxB,EACA,QAAAJ,CAASI,GACPM,EAAS,WAAYN,EACvB,EACA,GAAAH,CAAIG,GACFM,EAAS,MAAON,EAClB,EAEJ,E,aCjHO,MAAMiB,EAAU,CACrBC,OAAQ,kBACRC,aAAc,gBACdC,eAAgB,iBAChBC,eAAgB,+BAChBC,oBAAqB,sBACrBC,uBAAwB,yBACxBC,qBAAsB,uBACtBC,qBAAsB,uBACtBC,gCAAiC,yBACjCC,kCAAmC,2BACnCC,cAAe,sBACfC,YAAa,uBACbC,cAAe,SACfC,WAAY,4BAGDC,EAAU,CACrBC,IAAK,qBACLC,KAAM,uBAGKC,EAAU,CACrBC,IAAK,MACLC,KAAM,OACNC,KAAM,OACNC,QAAS,UACTC,KAAM,QAGKpT,EAAQ,CACnBqT,QAAS,UACTC,KAAM,cACNC,MAAO,SAGIC,EAAe,CAC1BC,QAAS,UACTJ,QAAS,UACTK,YAAa,aACbH,MAAO,QACPI,mBAAoB,oBACpBC,aAAc,QACdC,YAAa,aACbC,kBAAmB,kBACnBC,cAAe,gBAGJ,EAAQ,CACnBC,iBAAkB,mBAClBC,aAAc,eACdC,WAAY,aACZC,cAAe,gBACfC,cAAe,iBAGJ,EAAS,CACpBC,OAAQ,cACRC,OAAQ,cACRC,OAAQ,cACRC,iBAAkB,uBAClBC,YAAa,kBACbC,WAAY,kBACZC,OAAQ,cACRC,iBAAkB,eAClBC,mBAAoB,kBAGTC,EAAgB,CAC3B7B,KAAM,OACN8B,kBAAmB,oBACnBC,mBAAoB,sBAGTvK,EAAO,CAClBgJ,QAAS,UACTwB,SAAU,WACVC,OAAQ,UAGGC,EAAe,CAC1BC,OAAQ,OACRC,SAAU,SAGCC,EAAe,CAC1B,aACA,UACA,aACA,UACA,WACA,kBACA,mBAGWC,GAAW,GACXC,GAAoB,GACpBC,EAAU,GACVC,EAAmB,GACnBC,GAAW,IACXC,EAAU,ICjGjBC,EAAqB,CACzB1V,MAAO,EACPE,WAAY,EACZC,gBAAiB,EACjBC,QAAS,GAGX,SAASuV,EAAWlM,EAAGC,GACrB,MAAMkM,EAAQF,EAAmBjM,EAAElK,SAASC,MAAQkW,EAAmBhM,EAAEnK,SAASC,MAElF,OAAc,IAAVoW,GAAenM,EAAElK,SAASC,OAAS,EAAuB0T,QACrDzJ,EAAEnL,KAAOoL,EAAEpL,KAGbsX,CACT,CAmBA,QAhBA,SAAsB9V,GACpB,OAAOA,EAASwE,KAAKtD,IACfA,EAAQzB,SAASC,OAAS,EAAuB0T,UACnDlS,EAAQ1C,KAAO,WAAc,CAC3BkB,KAAM,EAAuB8T,QAC7BuC,SAAU,CAAC,EACXtW,SAAUyB,EAAQzB,YAGfyB,KACNyN,KAAKkH,GAAYrR,KAAKtD,WAChBA,EAAQ1C,KACR0C,IAEX,ECtBA,QAPA,SAA+B8U,EAAUC,EAAS,GAChD,MAAO,CACL,CAACD,EAASzU,MAAMuL,EAAImJ,EAAQD,EAASzU,MAAM2U,EAAID,GAC/C,CAACD,EAASzU,MAAMuL,EAAImJ,EAAQD,EAASzU,MAAM2U,EAAID,GAEnD,ECXA,SAASE,EAAUC,GAIjB,GAHAhY,KAAKiY,OAAS,CAAC,EACfjY,KAAKkY,MAAQ,CAAC,EACdlY,KAAKmY,QAAUH,EAAQA,EAAM3X,OAAS,EACjC2X,EACL,IAAK,IAAIvX,EAAI,EAAGyH,EAAI8P,EAAM3X,OAAQI,EAAIyH,EAAGzH,IACvCT,KAAKoY,IAAIJ,EAAMvX,SACE8I,IAAbyO,EAAMvX,KACc,iBAAbuX,EAAMvX,GAAiBT,KAAKiY,OAAOD,EAAMvX,IAAMA,EACrDT,KAAKkY,MAAMF,EAAMvX,IAAMA,EAGhC,CAEAsX,EAAUjM,UAAUsM,IAAM,SAAS1J,GACjC,OAAI1O,KAAKqY,IAAI3J,KACb1O,KAAKmY,UACY,iBAANzJ,EAAgB1O,KAAKiY,OAAOvJ,GAAK1O,KAAKmY,QAC5CnY,KAAKkY,MAAMxJ,GAAK1O,KAAKmY,SAHFnY,IAK1B,EAEA+X,EAAUjM,UAAUwM,OAAS,SAAS5J,GACpC,OAAoB,IAAhB1O,KAAKqY,IAAI3J,KACb1O,KAAKmY,iBACEnY,KAAKiY,OAAOvJ,UACZ1O,KAAKkY,MAAMxJ,IAHgB1O,IAKpC,EAEA+X,EAAUjM,UAAUuM,IAAM,SAAS3J,GACjC,OAAiB,iBAANA,GAA+B,iBAANA,UACVnF,IAAnBvJ,KAAKiY,OAAOvJ,SAAsCnF,IAAlBvJ,KAAKkY,MAAMxJ,GACpD,EAEAqJ,EAAUjM,UAAUyM,OAAS,WAC3B,MAAMA,EAAS,GAQf,OAPA3T,OAAO6G,KAAKzL,KAAKiY,QAAQtQ,SAASM,IAChCsQ,EAAOlO,KAAK,CAAEpC,IAAGmI,EAAGpQ,KAAKiY,OAAOhQ,IAAK,IAEvCrD,OAAO6G,KAAKzL,KAAKkY,OAAOvQ,SAASM,IAC/BsQ,EAAOlO,KAAK,CAAEpC,EAAGuQ,KAAKC,MAAMxQ,GAAImI,EAAGpQ,KAAKkY,MAAMjQ,IAAK,IAG9CsQ,EAAOhI,MAAK,CAAChF,EAAGC,IAAMD,EAAE6E,EAAI5E,EAAE4E,IAAGhK,KAAImF,GAAKA,EAAEtD,GACrD,EAEA8P,EAAUjM,UAAUe,MAAQ,WAI1B,OAHA7M,KAAKmY,QAAU,EACfnY,KAAKiY,OAAS,CAAC,EACfjY,KAAKkY,MAAQ,CAAC,EACPlY,IACT,EAEA,UCjDM0Y,EAAa,CACjB,EAAetD,QACf,EAAewB,SACf,EAAeC,QAIjB,GACEnF,MAIF,SAAyBa,EAAO/P,EAAM6P,GACpC,OAAOsG,EAAWpG,EAAO/P,EAAM6P,EAAKA,EAAIrP,QAAQ4V,YAClD,EALEC,MAOF,SAAyBtG,EAAO/P,EAAM6P,GACpC,OAAOsG,EAAWpG,EAAO/P,EAAM6P,EAAKA,EAAIrP,QAAQ8V,YAClD,GAEA,SAASH,EAAWpG,EAAO/P,EAAM6P,EAAKwF,GACpC,GAAgB,OAAZxF,EAAIjM,IAAc,MAAO,GAE7B,MAAM2S,EAAM,EAAU,EAAsBxG,EAAOsF,GAAUrV,EAEvDwW,EAAc,CAAC,EAEjB3G,EAAIrP,QAAQiW,SAAQD,EAAYE,OAAS7G,EAAIrP,QAAQiW,OAAO7S,KAAI2H,GAAKA,EAAE7K,KAAIiW,QAAOjW,GAA8B,MAAxBmP,EAAIjM,IAAIgT,SAASlW,MAE7G,MAAMtB,EAAWyQ,EAAIjM,IAAIiT,sBAAsBN,EAAKC,GACjDG,QAAOrW,IAA4D,IAAjD4V,EAAW7Q,QAAQ/E,EAAQjB,WAAWuK,QAErDkN,EAAa,IAAI,EACjBC,EAAiB,GAQvB,OAPA3X,EAAS+F,SAAS7E,IAChB,MAAMwG,EAAYxG,EAAQjB,WAAWqB,GACjCoW,EAAWjB,IAAI/O,KACnBgQ,EAAWlB,IAAI9O,GACfiQ,EAAelP,KAAKvH,GAAQ,IAGvB,EAAayW,EACtB,CC5Ce,SAASC,EAA0BjH,EAAOF,GACvD,MAAMzQ,EAAW,EAAW8P,MAAMa,EAAO,KAAMF,GACzCmB,EAAU,CAAEiG,MAAO,EAAkB1E,MAe3C,OAbInT,EAAS,KACX4R,EAAQiG,MAAS7X,EAAS,GAAGC,WAAW6X,SAAW,EAAuB3C,OACxE,EAAkBnC,KAAO,EAAkBE,QAC7CtB,EAAQ1Q,QAAUlB,EAAS,GAAGC,WAAWuK,OAGW,IAAlDiG,EAAIsH,OAAOC,kBAAkB/R,QAAQ,UACvC2L,EAAQiG,MAAQ,EAAkB9E,KAGpCtC,EAAIa,GAAG2G,gBAAgBrG,GACvBnB,EAAIa,GAAGC,mBAEAvR,EAAS,EAClB,CCrBe,WAAS2J,EAAGC,GACzB,MAAMkD,EAAInD,EAAEmD,EAAIlD,EAAEkD,EACZoJ,EAAIvM,EAAEuM,EAAItM,EAAEsM,EAClB,OAAOxX,KAAK8N,KAAMM,EAAIA,EAAMoJ,EAAIA,EAClC,CCFA,MAAMgC,EAAiB,EACjBC,EAAkB,GAClBC,EAAW,IAEF,SAASC,EAAQ7G,EAAO8G,EAAKlX,EAAU,CAAC,GACrD,MAAMmX,EAA0C,MAAzBnX,EAAQmX,cAAyBnX,EAAQmX,cAAgBL,EAC1EM,EAA4C,MAA1BpX,EAAQoX,eAA0BpX,EAAQoX,eAAiBL,EAC7EM,EAAgC,MAApBrX,EAAQqX,SAAoBrX,EAAQqX,SAAWL,EAEjE5G,EAAMjQ,MAAQiQ,EAAMjQ,OAAS+W,EAAI/W,MACjCiQ,EAAMkH,KAAOlH,EAAMkH,MAAQJ,EAAII,KAC/B,MAAMC,EAAe,EAAkBnH,EAAMjQ,MAAO+W,EAAI/W,OAExD,OAAOoX,EAAeJ,GACnBI,EAAeH,GAAmBF,EAAII,KAAOlH,EAAMkH,KAAQD,CAChE,CCfO,MAAMG,EAAgB,GAChBC,EAAe,IAEb,SAASC,EAAMtH,EAAO8G,EAAKlX,EAAU,CAAC,GACnD,MAAM2X,EAAkC,MAArB3X,EAAQ2X,UAAqB3X,EAAQ2X,UAAYH,EAC9DH,EAAgC,MAApBrX,EAAQqX,SAAoBrX,EAAQqX,SAAWI,EAEjErH,EAAMjQ,MAAQiQ,EAAMjQ,OAAS+W,EAAI/W,MACjCiQ,EAAMkH,KAAOlH,EAAMkH,MAAQJ,EAAII,KAG/B,OAFqB,EAAkBlH,EAAMjQ,MAAO+W,EAAI/W,OAElCwX,GAAcT,EAAII,KAAOlH,EAAMkH,KAAQD,CAC/D,CCZA,MAAM,ECAsB,EAACO,EAAUC,EAAc,KAC5C,CAACC,EAAOD,KACb,IAAI3X,EAAK,GACLzC,EAAW,EAAPqa,EACR,KAAOra,KACLyC,GAAM0X,EAAUta,KAAKya,SAAWH,EAASva,OAAU,GAErD,OAAO6C,GDPI8X,CAAe,iEAAkE,IAEzF,SAASC,IACd,OAAO,GACT,CEHA,MAAM5Y,EAAU,SAASgQ,EAAK5P,GAC5BzC,KAAKqS,IAAMA,EACXrS,KAAK6B,WAAaY,EAAQZ,YAAc,CAAC,EACzC7B,KAAKuB,YAAckB,EAAQpB,SAASE,YACpCvB,KAAKkD,GAAKT,EAAQS,IAAM+X,IACxBjb,KAAKsB,KAAOmB,EAAQpB,SAASC,IAC/B,EAEAe,EAAQyJ,UAAUoP,QAAU,WAC1Blb,KAAKqS,IAAIM,MAAMC,eAAe5S,KAAKkD,GACrC,EAEAb,EAAQyJ,UAAUqP,eAAiB,SAAShb,GAC1CH,KAAKob,eAAejb,EACtB,EAEAkC,EAAQyJ,UAAUsP,eAAiB,SAASjb,GAC1CH,KAAKuB,YAAcpB,EACnBH,KAAKkb,SACP,EAEA7Y,EAAQyJ,UAAUuP,eAAiB,WACjC,OAAO7C,KAAKC,MAAMD,KAAK8C,UAAUtb,KAAKuB,aACxC,EAEAc,EAAQyJ,UAAUyP,YAAc,SAAS5D,EAAU7S,GACjD9E,KAAK6B,WAAW8V,GAAY7S,CAC9B,EAEAzC,EAAQyJ,UAAU0P,UAAY,WAC5B,OAAOhD,KAAKC,MAAMD,KAAK8C,UAAU,CAC/BpY,GAAIlD,KAAKkD,GACT5B,KAAM,EAAuB8T,QAC7BvT,WAAY7B,KAAK6B,WACjBR,SAAU,CACRE,YAAavB,KAAKqb,iBAClB/Z,KAAMtB,KAAKsB,QAGjB,EAEAe,EAAQyJ,UAAU2P,SAAW,SAASnK,GACpC,MAAMzP,EAAa,CACjBqB,GAAIlD,KAAKkD,GACTkJ,KAAM,EAAegJ,QACrB,YAAapV,KAAKsB,KAClBoY,OAAQ,EAAuB1C,SAC/B1F,QAGF,GAAItR,KAAKqS,IAAIrP,QAAQ0Y,eACnB,IAAK,MAAMC,KAAQ3b,KAAK6B,WACtBA,EAAW,QAAQ8Z,KAAU3b,KAAK6B,WAAW8Z,GAIjD,MAAO,CACLra,KAAM,EAAuB8T,QAC7BvT,aACAR,SAAU,CACRE,YAAavB,KAAKqb,iBAClB/Z,KAAMtB,KAAKsB,MAGjB,EAEA,UCnEMQ,EAAQ,SAASuQ,EAAK5P,GAC1B,EAAQwJ,KAAKjM,KAAMqS,EAAK5P,EAC1B,GAEAX,EAAMgK,UAAYlH,OAAOgX,OAAO,EAAQ9P,YAExB+P,QAAU,WACxB,MAAsC,iBAAxB7b,KAAKuB,YAAY,IACE,iBAAxBvB,KAAKuB,YAAY,EAC5B,EAEAO,EAAMgK,UAAUgQ,iBAAmB,SAASC,EAAWC,EAAUC,GAE7Djc,KAAKuB,YADkB,IAArB2a,UAAU7b,OACO,CAAC2b,EAAUC,GAEX,CAACF,EAAWC,GAEjChc,KAAKkb,SACP,EAEApZ,EAAMgK,UAAUqQ,cAAgB,WAC9B,OAAOnc,KAAKqb,gBACd,EAEA,UCxBMrZ,EAAa,SAASqQ,EAAK5P,GAC/B,EAAQwJ,KAAKjM,KAAMqS,EAAK5P,EAC1B,GAEAT,EAAW8J,UAAYlH,OAAOgX,OAAO,EAAQ9P,YAExB+P,QAAU,WAC7B,OAAO7b,KAAKuB,YAAYlB,OAAS,CACnC,EAEA2B,EAAW8J,UAAUsQ,cAAgB,SAASC,EAAMC,EAAKL,GACvDjc,KAAKkb,UACL,MAAMhY,EAAKqZ,SAASF,EAAM,IAC1Brc,KAAKuB,YAAYmO,OAAOxM,EAAI,EAAG,CAACoZ,EAAKL,GACvC,EAEAja,EAAW8J,UAAUqQ,cAAgB,SAASE,GAC5C,MAAMnZ,EAAKqZ,SAASF,EAAM,IAC1B,OAAO7D,KAAKC,MAAMD,KAAK8C,UAAUtb,KAAKuB,YAAY2B,IACpD,EAEAlB,EAAW8J,UAAU0Q,iBAAmB,SAASH,GAC/Crc,KAAKkb,UACLlb,KAAKuB,YAAYmO,OAAO6M,SAASF,EAAM,IAAK,EAC9C,EAEAra,EAAW8J,UAAUgQ,iBAAmB,SAASO,EAAMC,EAAKL,GAC1D,MAAM/Y,EAAKqZ,SAASF,EAAM,IAC1Brc,KAAKuB,YAAY2B,GAAM,CAACoZ,EAAKL,GAC7Bjc,KAAKkb,SACP,EAEA,UChCMhZ,EAAU,SAASmQ,EAAK5P,GAC5B,EAAQwJ,KAAKjM,KAAMqS,EAAK5P,GACxBzC,KAAKuB,YAAcvB,KAAKuB,YAAY6E,KAAI3E,GAAQA,EAAK8N,MAAM,GAAI,IACjE,GAEArN,EAAQ4J,UAAYlH,OAAOgX,OAAO,EAAQ9P,YAExB+P,QAAU,WAC1B,OAAgC,IAA5B7b,KAAKuB,YAAYlB,QACdL,KAAKuB,YAAYkb,OAAMhb,GAAQA,EAAKpB,OAAS,GACtD,EAGA6B,EAAQ4J,UAAUqP,eAAiB,SAAShb,GAC1CH,KAAKuB,YAAcpB,EAAOiG,KAAI3E,GAAQA,EAAK8N,MAAM,GAAI,KACrDvP,KAAKkb,SACP,EAGAhZ,EAAQ4J,UAAUsP,eAAiB,SAASjb,GAC1CH,KAAKuB,YAAcpB,EACnBH,KAAKkb,SACP,EAEAhZ,EAAQ4J,UAAUsQ,cAAgB,SAASC,EAAMC,EAAKL,GACpDjc,KAAKkb,UACL,MAAMwB,EAAML,EAAKM,MAAM,KAAKvW,KAAIsI,GAAK6N,SAAS7N,EAAG,MAEpC1O,KAAKuB,YAAYmb,EAAI,IAE7BhN,OAAOgN,EAAI,GAAI,EAAG,CAACJ,EAAKL,GAC/B,EAEA/Z,EAAQ4J,UAAU0Q,iBAAmB,SAASH,GAC5Crc,KAAKkb,UACL,MAAMwB,EAAML,EAAKM,MAAM,KAAKvW,KAAIsI,GAAK6N,SAAS7N,EAAG,MAC3CjN,EAAOzB,KAAKuB,YAAYmb,EAAI,IAC9Bjb,IACFA,EAAKiO,OAAOgN,EAAI,GAAI,GAChBjb,EAAKpB,OAAS,GAChBL,KAAKuB,YAAYmO,OAAOgN,EAAI,GAAI,GAGtC,EAEAxa,EAAQ4J,UAAUqQ,cAAgB,SAASE,GACzC,MAAMK,EAAML,EAAKM,MAAM,KAAKvW,KAAIsI,GAAK6N,SAAS7N,EAAG,MAC3CjN,EAAOzB,KAAKuB,YAAYmb,EAAI,IAClC,OAAOlE,KAAKC,MAAMD,KAAK8C,UAAU7Z,EAAKib,EAAI,KAC5C,EAEAxa,EAAQ4J,UAAUuP,eAAiB,WACjC,OAAOrb,KAAKuB,YAAY6E,KAAIjG,GAAUA,EAAOyc,OAAO,CAACzc,EAAO,MAC9D,EAEA+B,EAAQ4J,UAAUgQ,iBAAmB,SAASO,EAAMC,EAAKL,GACvDjc,KAAKkb,UACL,MAAM2B,EAAQR,EAAKM,MAAM,KACnBG,EAASP,SAASM,EAAM,GAAI,IAC5BE,EAAUR,SAASM,EAAM,GAAI,SAEFtT,IAA7BvJ,KAAKuB,YAAYub,KACnB9c,KAAKuB,YAAYub,GAAU,IAG7B9c,KAAKuB,YAAYub,GAAQC,GAAW,CAACT,EAAKL,EAC5C,EAEA,UC9DMe,EAAS,CACbjb,WAAU,EACVE,gBAAe,EACfE,aAAY,GAGR8a,GAAa,CAACrb,EAAUsb,EAAQb,EAAMC,EAAKL,KAC/C,MAAMY,EAAQR,EAAKM,MAAM,KACnBQ,EAAMZ,SAASM,EAAM,GAAI,IACzBO,EAASP,EAAM,GAAaA,EAAMtN,MAAM,GAAG8N,KAAK,KAA3B,KAC3B,OAAOzb,EAASub,GAAKD,GAAQE,EAAMd,EAAKL,EAAI,EAGxCqB,GAAe,SAASjL,EAAK5P,GAKjC,GAJA,EAAQwJ,KAAKjM,KAAMqS,EAAK5P,UAEjBzC,KAAKuB,YACZvB,KAAKud,MAAQP,EAAOva,EAAQpB,SAASC,WAClBiI,IAAfvJ,KAAKud,MAAqB,MAAM,IAAIC,UAAU,GAAG/a,EAAQpB,SAASC,4BACtEtB,KAAK4B,SAAW5B,KAAKyd,uBAAuBhb,EAAQpB,SAASE,YAC/D,GAEA+b,GAAaxR,UAAYlH,OAAOgX,OAAO,EAAQ9P,YAExB2R,uBAAyB,SAASlc,GACvD,MAAMmc,EAAQ1d,KAAKud,MAAMI,KAAK3d,MAC9B,OAAOuB,EAAY6E,KAAIjG,GAAU,IAAIud,EAAM1d,KAAKqS,IAAK,CACnDnP,GAAI+X,IACJ3Z,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRE,YAAapB,EACbmB,KAAMtB,KAAKsB,KAAKsc,QAAQ,QAAS,QAGvC,EAEAN,GAAaxR,UAAU+P,QAAU,WAC/B,OAAO7b,KAAK4B,SAAS6a,OAAMxO,GAAKA,EAAE4N,WACpC,EAEAyB,GAAaxR,UAAUsP,eAAiB,SAASjb,GAC/CH,KAAK4B,SAAW5B,KAAKyd,uBAAuBtd,GAC5CH,KAAKkb,SACP,EAEAoC,GAAaxR,UAAUqQ,cAAgB,SAASE,GAC9C,OAAOY,GAAWjd,KAAK4B,SAAU,gBAAiBya,EACpD,EAEAiB,GAAaxR,UAAUuP,eAAiB,WACtC,OAAO7C,KAAKC,MAAMD,KAAK8C,UAAUtb,KAAK4B,SAASwE,KAAK6H,GAC9CA,EAAE3M,OAAS,EAAuB0T,QAAgB/G,EAAEoN,iBACjDpN,EAAE1M,eAEb,EAEA+b,GAAaxR,UAAUgQ,iBAAmB,SAASO,EAAMC,EAAKL,GAC5DgB,GAAWjd,KAAK4B,SAAU,mBAAoBya,EAAMC,EAAKL,GACzDjc,KAAKkb,SACP,EAEAoC,GAAaxR,UAAUsQ,cAAgB,SAASC,EAAMC,EAAKL,GACzDgB,GAAWjd,KAAK4B,SAAU,gBAAiBya,EAAMC,EAAKL,GACtDjc,KAAKkb,SACP,EAEAoC,GAAaxR,UAAU0Q,iBAAmB,SAASH,GACjDY,GAAWjd,KAAK4B,SAAU,mBAAoBya,GAC9Crc,KAAKkb,SACP,EAEAoC,GAAaxR,UAAU+R,YAAc,WACnC,OAAO7d,KAAK4B,QACd,EAEA,YC7Ee,SAASkc,GAAczL,GACpCrS,KAAKoG,IAAMiM,EAAIjM,IACfpG,KAAK+d,WAAavF,KAAKC,MAAMD,KAAK8C,UAAUjJ,EAAIrP,SAAW,CAAC,IAC5DhD,KAAKge,KAAO3L,CACd,CAOAyL,GAAchS,UAAUmS,YAAc,SAASrc,GAC7C,OAAO5B,KAAKge,KAAKrL,MAAMsL,YAAYrc,EACrC,EAOAkc,GAAchS,UAAUoS,uBAAyB,SAAS/d,GACxDH,KAAKge,KAAKrL,MAAMuL,uBAAuB/d,GACvCA,EAAOge,QAAO,CAACnP,EAAGC,UACQ1F,IAApByF,EAAEC,EAAEmP,cACNpP,EAAEC,EAAEmP,aAAc,EAClBpe,KAAKge,KAAKrL,MAAM1B,IAAIhC,EAAEmP,YAAYlD,WAE7BlM,IACN,CAAC,EACN,EAOA8O,GAAchS,UAAUuS,YAAc,WACpC,OAAOre,KAAKge,KAAKrL,MAAM0L,aACzB,EAOAP,GAAchS,UAAUwS,eAAiB,WACvC,OAAOte,KAAKge,KAAKrL,MAAM2L,gBACzB,EAQAR,GAAchS,UAAUyS,WAAa,SAASrb,GAC5C,OAAOlD,KAAKge,KAAKrL,MAAM4L,WAAWrb,EACpC,EAQA4a,GAAchS,UAAU0S,WAAa,SAAStb,GAC5C,OAAOlD,KAAKge,KAAKrL,MAAM1B,IAAI/N,EAC7B,EAOA4a,GAAchS,UAAU2S,OAAS,SAASvb,GACxC,OAAOlD,KAAKge,KAAKrL,MAAM8L,OAAOvb,EAChC,EAOA4a,GAAchS,UAAU4S,SAAW,SAASxb,GAC1C,OAAOlD,KAAKge,KAAKrL,MAAM+L,SAASxb,EAClC,EAOA4a,GAAchS,UAAU6S,cAAgB,SAASzb,EAAI0b,EAAO,CAAC,GAC3D,OAAO5e,KAAKge,KAAKrL,MAAM2F,OAAOpV,EAAI0b,EACpC,EAQAd,GAAchS,UAAU+S,WAAa,SAAS/b,EAAS8b,EAAO,CAAC,GAC7D,OAAO5e,KAAKge,KAAKrL,MAAMyF,IAAItV,EAAS8b,EACtC,EAKAd,GAAchS,UAAUgT,sBAAwB,WAC9C,OAAO9e,KAAKge,KAAKrL,MAAMoM,eACzB,EAKAjB,GAAchS,UAAUkT,yBAA2B,WACjD,OAAOhf,KAAKge,KAAKrL,MAAMqM,0BACzB,EAQAlB,GAAchS,UAAUmT,mBAAqB,SAASC,EAAU,CAAC,GAC/D,MAAMC,EAAS,CACb9L,MAAO6L,EAAQ7L,QAAS,EACxBC,gBAAiB4L,EAAQ5L,kBAAmB,EAC5CC,kBAAmB2L,EAAQ3L,oBAAqB,GAElD,OAAOvT,KAAKge,KAAKrE,OAAOyF,WAAWD,EACrC,EASArB,GAAchS,UAAUuT,WAAa,SAAS/N,EAAMsN,EAAO,CAAC,EAAGU,EAAY,CAAC,GAC1E,OAAOtf,KAAKge,KAAKrE,OAAO0F,WAAW/N,EAAMsN,EAAMU,EACjD,EAQAxB,GAAchS,UAAUyT,KAAO,SAASzM,EAAW0M,GACjD,OAAOxf,KAAKge,KAAKrE,OAAO4F,KAAKzM,EAAW0M,EAC1C,EAOA1B,GAAchS,UAAU2T,gBAAkB,SAASb,GACjD,OAAO5e,KAAKge,KAAK9K,GAAG2G,gBAAgB+E,EACtC,EAOAd,GAAchS,UAAU4T,iBAAmB,SAAS/D,GAClD,OAAO3b,KAAKge,KAAK9K,GAAGyM,gBAAgBhE,EACtC,EASAmC,GAAchS,UAAU6M,WAAa,SAASpG,EAAO/P,EAAMod,EAAa,SACtE,GAAmB,UAAfA,GAAyC,UAAfA,EAAwB,MAAM,IAAIxc,MAAM,uBACtE,OAAO,EAAWwc,GAAYrN,EAAO/P,EAAMxC,KAAKge,KAClD,EAQAF,GAAchS,UAAU+T,WAAa,SAASpd,GAC5C,MAAMnB,EAAOmB,EAAQpB,SAASC,KAC9B,OAAIA,IAAS,EAAuB4T,MAAc,IAAI,EAAMlV,KAAKge,KAAMvb,GACnEnB,IAAS,EAAuB+T,YAAoB,IAAI,EAAWrV,KAAKge,KAAMvb,GAC9EnB,IAAS,EAAuB0T,QAAgB,IAAI,EAAQhV,KAAKge,KAAMvb,GACpE,IAAI,GAAazC,KAAKge,KAAMvb,EACrC,EASAqb,GAAchS,UAAUgU,aAAe,SAASxe,EAAMwB,GACpD,GAAIxB,IAAS,EAAuB4T,MAAO,OAAOpS,aAAmB,EACrE,GAAIxB,IAAS,EAAuB+T,YAAa,OAAOvS,aAAmB,EAC3E,GAAIxB,IAAS,EAAuB0T,QAAS,OAAOlS,aAAmB,EACvE,GAAa,iBAATxB,EAAyB,OAAOwB,aAAmB,GACvD,MAAM,IAAIM,MAAM,0BAA0B9B,IAC5C,EAOAwc,GAAchS,UAAUiU,SAAW,SAAS7c,GAC1C,OAAOlD,KAAKge,KAAKrL,MAAMC,eAAe1P,EACxC,ECpOA,YAQA4a,GAAchS,UAAUkU,QAAU,WAAY,EAQ9ClC,GAAchS,UAAUmU,OAAS,WAAY,EAQ7CnC,GAAchS,UAAUoU,QAAU,WAAY,EAQ9CpC,GAAchS,UAAUqU,YAAc,WAAY,EAQlDrC,GAAchS,UAAUsU,YAAc,WAAY,EAQlDtC,GAAchS,UAAUuU,UAAY,WAAY,EAQhDvC,GAAchS,UAAUwU,WAAa,WAAY,EAQjDxC,GAAchS,UAAUyU,QAAU,WAAY,EAQ9CzC,GAAchS,UAAU0U,UAAY,WAAY,EAQhD1C,GAAchS,UAAU2U,aAAe,WAAY,EAQnD3C,GAAchS,UAAU4U,YAAc,WAAY,EAQlD5C,GAAchS,UAAU6U,WAAa,WAAY,EAQjD7C,GAAchS,UAAU8U,MAAQ,WAAY,EAO5C9C,GAAchS,UAAU+U,OAAS,WAAY,EAO7C/C,GAAchS,UAAUgV,QAAU,WAAY,EAO9ChD,GAAchS,UAAUiV,iBAAmB,WAAY,EAOvDjD,GAAchS,UAAUkV,mBAAqB,WAAY,EAUzDlD,GAAchS,UAAUmV,kBAAoB,WAC1C,MAAM,IAAI7d,MAAM,uCAClB,EC/IA,MAAM8d,GAAc,CAClBzP,KAAM,SACNC,MAAO,UACPC,UAAW,cACXC,UAAW,cACXC,QAAS,YACTC,SAAU,aACVE,MAAO,UACPD,QAAS,YACTE,WAAY,eACZC,UAAW,cACXC,SAAU,aACVC,IAAK,SAGD+O,GAAYvc,OAAO6G,KAAKyV,IAEf,YAASE,GACtB,MAAMC,EAAiBzc,OAAO6G,KAAK2V,GAEnC,OAAO,SAAS/O,EAAKiP,EAAY,CAAC,GAChC,IAAIC,EAAQ,CAAC,EAEb,MAAMjQ,EAAO+P,EAAelD,QAAO,CAACnP,EAAG/G,KACrC+G,EAAE/G,GAAKmZ,EAAWnZ,GACX+G,IACN,IAAI,GAAcqD,IAMrB,MAAO,CACL,KAAAe,GACEmO,EAAQjQ,EAAK0O,QAAQsB,GAOrBH,GAAUxZ,SAASuE,IACjB,MAAMsV,EAAcN,GAAYhV,GAChC,IAAIsG,EAAW,KAAM,EAf3B,IAAiBiP,EAgBPL,EAAWI,KACbhP,EAAW,KAAM,GAEnBxS,KAAKsS,GAAGpG,EAAKsG,GAnBFiP,EAmBoBD,EAlB5B7T,GAAK2D,EAAKmQ,GAAIF,EAAO5T,IAkBoB,GAGhD,EACA,IAAAjF,GACE4I,EAAKuP,OAAOU,EACd,EACA,KAAAlO,GACE/B,EAAKwP,QAAQS,EACf,EACA,eAAAjO,GACEhC,EAAKoQ,kBAAkBH,EACzB,EACA,iBAAAhO,GACEjC,EAAKqQ,oBAAoBJ,EAC3B,EACA,MAAA7O,CAAOjQ,EAAS4H,GACdiH,EAAK2P,kBAAkBM,EAAO9e,EAAS4H,EACzC,EAEJ,CACF,CC5DA,SAJA,SAAsBqE,GACpB,MAAO,GAAGkO,OAAOlO,GAAGyK,QAAOrB,QAAWvO,IAANuO,GAClC,ECNe,SAASpF,KAEtB,MAAMC,EAAQ3S,KAEd,KADkB2S,EAAMN,IAAIjM,UAA0DmD,IAAnDoJ,EAAMN,IAAIjM,IAAIwb,UAAU,EAAkBpN,MAC7D,OAAOqN,IAEvB,MAAMvQ,EAAOqB,EAAMN,IAAIsH,OAAOC,kBAE9BjH,EAAMN,IAAIa,GAAG2G,gBAAgB,CAAEvI,SAE/B,IAAIwQ,EAAY,GACZC,EAAa,GAEbpP,EAAMqP,QACRD,EAAapP,EAAMsP,aAEnBH,EAAYnP,EAAMuP,gBAAgB/I,QAAOjW,QAAwBqG,IAAlBoJ,EAAM1B,IAAI/N,KACzD6e,EAAapP,EAAM4B,QAAQ4N,IAAIhJ,QAAO1W,GAAWA,EAAQZ,WAAWqB,KAAoD,IAA9C4e,EAAUja,QAAQpF,EAAQZ,WAAWqB,UAAmDqG,IAArCoJ,EAAM1B,IAAIxO,EAAQZ,WAAWqB,MAAmBkD,KAAI3D,GAAWA,EAAQZ,WAAWqB,MAGjNyP,EAAM4B,QAAQ4N,IAAM,GACpB,MAAMC,EAAgBzP,EAAM4B,QAAQ8N,KAAKhiB,OACzCsS,EAAM4B,QAAQ8N,KAAO1P,EAAMqP,QAAU,GAAKrP,EAAM4B,QAAQ8N,KAAKlJ,QAAQ1W,IACnE,MAAMS,EAAKT,EAAQZ,WAAWqB,IAAMT,EAAQZ,WAAWygB,OACvD,OAAkC,IAA3BR,EAAUja,QAAQ3E,EAAU,IAGrC,MAAMqf,EAAcH,IAAkBzP,EAAM4B,QAAQ8N,KAAKhiB,QAAU0hB,EAAW1hB,OAAS,EAIvF,SAASmiB,EAActf,EAAIyI,GACzB,MACM8W,EADU9P,EAAM1B,IAAI/N,GACMuY,SAASnK,GACzCqB,EAAMN,IAAIsH,OAAO+I,kBAAkBD,GAAkBhgB,IACnDA,EAAQZ,WAAWyP,KAAOA,EAC1BqB,EAAM4B,QAAQ5I,GAAQtB,KAAK5H,EAAQ,GAEvC,CAgBA,SAASof,IACPlP,EAAMqP,SAAU,EAChBrP,EAAMgQ,iBACR,CA7BAb,EAAUna,SAAQzE,GAAMsf,EAActf,EAAI,SAC1C6e,EAAWpa,SAAQzE,GAAMsf,EAActf,EAAI,UAWvCqf,GACF5P,EAAMN,IAAIjM,IAAIwb,UAAU,EAAkBnN,MAAMmO,QAAQ,CACtDthB,KAAM,EAAuBgU,mBAC7B1T,SAAU+Q,EAAM4B,QAAQ8N,OAI5B1P,EAAMN,IAAIjM,IAAIwb,UAAU,EAAkBpN,KAAKoO,QAAQ,CACrDthB,KAAM,EAAuBgU,mBAC7B1T,SAAU+Q,EAAM4B,QAAQ4N,MAG1BN,GAMF,CCvDe,SAASgB,GAAMxQ,GAe5B,IAAIyQ,EAdJ9iB,KAAK+iB,UAAY,CAAC,EAClB/iB,KAAKgjB,YAAc,IAAI,EACvBhjB,KAAKijB,oBAAsB,IAAI,EAC/BjjB,KAAKkjB,qBAAuB,GAC5BljB,KAAKmjB,mBAAqB,IAAI,EAC9BnjB,KAAKojB,sBAAuB,EAC5BpjB,KAAKqjB,kBAAoB,CAAC,EAC1BrjB,KAAKqS,IAAMA,EACXrS,KAAKuU,QAAU,CACb4N,IAAK,GACLE,KAAM,IAKRriB,KAAK0S,OAAS,KACPoQ,IACHA,EAAgBQ,uBAAsB,KACpCR,EAAgB,KAChBpQ,GAAOzG,KAAKjM,MAGRA,KAAKojB,uBACPpjB,KAAKqS,IAAIsH,OAAO4F,KAAK,EAAiBpJ,iBAAkB,CACtDvU,SAAU5B,KAAKqe,cAAcjY,KAAItD,GAAWA,EAAQ0Y,cACpDrV,OAAQnG,KAAKujB,yBAAyBnd,KAAIod,IAAc,CACtDliB,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,YAAaiiB,EAAWjiB,mBAK9BvB,KAAKojB,sBAAuB,GAI9BpjB,KAAKqS,IAAIsH,OAAO4F,KAAK,EAAiBjJ,OAAQ,CAAC,EAAE,IAErD,EAGFtW,KAAKgiB,SAAU,CACjB,CAiTA,SAASyB,GAA2B9Q,EAAO3P,EAAU,CAAC,GACpD,MAAM0gB,EAAyB/Q,EAAMuQ,qBAAqB/J,QAAOhW,GAASwP,EAAMsQ,oBAAoB5K,IAAIlV,EAAMib,cAC1GzL,EAAMuQ,qBAAqB7iB,SAAWqjB,EAAuBrjB,QAAW2C,EAAQ2gB,SAClFhR,EAAMyQ,sBAAuB,GAE/BzQ,EAAMuQ,qBAAuBQ,CAC/B,CAjTAb,GAAM/W,UAAU8X,kBAAoB,WAClC,MAAMC,EAAa7jB,KAAK0S,OACxB,IAAIoR,EAAa,EAKjB,OAJA9jB,KAAK0S,OAAS,WACZoR,GACF,EAEO,KACL9jB,KAAK0S,OAASmR,EACVC,EAAa,GACf9jB,KAAK0S,QACP,CAEJ,EAMAmQ,GAAM/W,UAAUiY,SAAW,WAEzB,OADA/jB,KAAKgiB,SAAU,EACRhiB,IACT,EAOA6iB,GAAM/W,UAAUkY,eAAiB,SAAS1a,EAAWtG,EAAU,CAAC,GAC9DhD,KAAKmjB,mBAAmB/K,IAAI9O,GAG5B,IAAe,KADkB,MAAlBtG,EAAQ2gB,OAAiB3gB,EAAQ2gB,OAAS3jB,KAAKqS,IAAIrP,QAAQihB,mBACrD,CACnB,MAAMnhB,EAAU9C,KAAKiR,IAAI3H,GACzBtJ,KAAKqS,IAAIsH,OAAO4F,KAAK,EAAiBvJ,OAAQ,CAC5CpU,SAAU,CAACkB,EAAQ0Y,cAEvB,CAEA,OAAOxb,IACT,EAOA6iB,GAAM/W,UAAU8G,eAAiB,SAAStJ,EAAWtG,EAAU,CAAC,GAC9DhD,KAAKmjB,mBAAmB/K,IAAI9O,GAU5B,OAPe,KADkB,MAAlBtG,EAAQ2gB,OAAiB3gB,EAAQ2gB,OAAS3jB,KAAKqS,IAAIrP,QAAQihB,oBAExEjkB,KAAKqS,IAAIsH,OAAO4F,KAAK,EAAiBrJ,OAAQ,CAC5CgH,OAAQla,EAAQka,OAASla,EAAQka,OAAS,EAAwBvG,mBAClE/U,SAAU,CAAC5B,KAAKiR,IAAI3H,GAAWkS,eAI5Bxb,IACT,EAMA6iB,GAAM/W,UAAUoW,cAAgB,WAC9B,OAAOliB,KAAKmjB,mBAAmB5K,QACjC,EAMAsK,GAAM/W,UAAU6W,gBAAkB,WAEhC,OADA3iB,KAAKmjB,mBAAmBtW,QACjB7M,IACT,EAMA6iB,GAAM/W,UAAUmW,UAAY,WAC1B,OAAOjiB,KAAKgjB,YAAYzK,QAC1B,EAUAsK,GAAM/W,UAAUsM,IAAM,SAAStV,EAASE,EAAU,CAAC,GAIjD,OAHAhD,KAAK+iB,UAAUjgB,EAAQI,IAAMJ,EAC7B9C,KAAKgjB,YAAY5K,IAAItV,EAAQI,IAC7BlD,KAAKgkB,eAAelhB,EAAQI,GAAI,CAACygB,OAAQ3gB,EAAQ2gB,SAC1C3jB,IACT,EAYA6iB,GAAM/W,UAAUwM,OAAS,SAASgB,EAAYtW,EAAU,CAAC,GACvD,MAAMkhB,EAAwB,GAmB9B,OAlBA,GAAa5K,GAAY3R,SAASzE,IAC3BlD,KAAKgjB,YAAY3K,IAAInV,KAC1BlD,KAAKgjB,YAAY1K,OAAOpV,GACxBlD,KAAKijB,oBAAoB3K,OAAOpV,GAC3BF,EAAQ2gB,SACgD,IAAvDO,EAAsBrc,QAAQ7H,KAAK+iB,UAAU7f,KAC/CghB,EAAsB7Z,KAAKrK,KAAK+iB,UAAU7f,GAAIsY,oBAG3Cxb,KAAK+iB,UAAU7f,GACtBlD,KAAKgiB,SAAU,EAAI,IAGjBkC,EAAsB7jB,QACxBL,KAAKqS,IAAIsH,OAAO4F,KAAK,EAAiBtJ,OAAQ,CAACrU,SAAUsiB,IAG3DT,GAA2BzjB,KAAMgD,GAC1BhD,IACT,EAMA6iB,GAAM/W,UAAUmF,IAAM,SAAS/N,GAC7B,OAAOlD,KAAK+iB,UAAU7f,EACxB,EAMA2f,GAAM/W,UAAUqY,OAAS,WACvB,OAAOvf,OAAO6G,KAAKzL,KAAK+iB,WAAW3c,KAAIlD,GAAMlD,KAAK+iB,UAAU7f,IAC9D,EASA2f,GAAM/W,UAAU2S,OAAS,SAASnF,EAAYtW,EAAU,CAAC,GASvD,OARA,GAAasW,GAAY3R,SAASzE,IAC5BlD,KAAKijB,oBAAoB5K,IAAInV,KACjClD,KAAKijB,oBAAoB7K,IAAIlV,GAC7BlD,KAAKmjB,mBAAmB/K,IAAIlV,GACvBF,EAAQ2gB,SACX3jB,KAAKojB,sBAAuB,GAC9B,IAEKpjB,IACT,EASA6iB,GAAM/W,UAAU4S,SAAW,SAASpF,EAAYtW,EAAU,CAAC,GAUzD,OATA,GAAasW,GAAY3R,SAASzE,IAC3BlD,KAAKijB,oBAAoB5K,IAAInV,KAClClD,KAAKijB,oBAAoB3K,OAAOpV,GAChClD,KAAKmjB,mBAAmB/K,IAAIlV,GACvBF,EAAQ2gB,SACX3jB,KAAKojB,sBAAuB,GAC9B,IAEFK,GAA2BzjB,KAAMgD,GAC1BhD,IACT,EAQA6iB,GAAM/W,UAAUiT,cAAgB,SAAS/b,EAAU,CAAC,GAElD,OADAhD,KAAK0e,SAAS1e,KAAKijB,oBAAoB1K,SAAU,CAAEoL,OAAQ3gB,EAAQ2gB,SAC5D3jB,IACT,EAUA6iB,GAAM/W,UAAUmS,YAAc,SAAS3E,EAAYtW,EAAU,CAAC,GAS5D,OARAsW,EAAa,GAAaA,GAG1BtZ,KAAK0e,SAAS1e,KAAKijB,oBAAoB1K,SAASY,QAAOjW,IAAkC,IAA5BoW,EAAWzR,QAAQ3E,KAAa,CAAEygB,OAAQ3gB,EAAQ2gB,SAG/G3jB,KAAKye,OAAOnF,EAAWH,QAAOjW,IAAOlD,KAAKijB,oBAAoB5K,IAAInV,KAAM,CAAEygB,OAAQ3gB,EAAQ2gB,SAEnF3jB,IACT,EAOA6iB,GAAM/W,UAAUoS,uBAAyB,SAAS3c,GAGhD,OAFAvB,KAAKkjB,qBAAuB3hB,EAC5BvB,KAAKojB,sBAAuB,EACrBpjB,IACT,EAOA6iB,GAAM/W,UAAUkT,yBAA2B,WAGzC,OAFAhf,KAAKkjB,qBAAuB,GAC5BljB,KAAKojB,sBAAuB,EACrBpjB,IACT,EAMA6iB,GAAM/W,UAAUwS,eAAiB,WAC/B,OAAOte,KAAKijB,oBAAoB1K,QAClC,EAMAsK,GAAM/W,UAAUuS,YAAc,WAC5B,OAAOre,KAAKse,iBAAiBlY,KAAIlD,GAAMlD,KAAKiR,IAAI/N,IAClD,EAMA2f,GAAM/W,UAAUyX,uBAAyB,WAOvC,OANiBvjB,KAAKkjB,qBAAqB9c,KAAKod,IAEvC,CACLjiB,YAFcvB,KAAKiR,IAAIuS,EAAWpF,YAEbjC,cAAcqH,EAAWY,eAIpD,EAOAvB,GAAM/W,UAAUyS,WAAa,SAASjV,GACpC,OAAOtJ,KAAKijB,oBAAoB5K,IAAI/O,EACtC,EAUAuZ,GAAM/W,UAAUuY,mBAAqB,SAAS/a,EAAWqO,EAAU7S,EAAO9B,EAAU,CAAC,GACnFhD,KAAKiR,IAAI3H,GAAWiS,YAAY5D,EAAU7S,GAE1C9E,KAAK4S,eAAetJ,EAAW,CAC7Bqa,OAAQ3gB,EAAQ2gB,OAChBzG,OAAQ,EAAwBxG,mBAEpC,EAaAmM,GAAM/W,UAAUwY,eAAiB,WAC/B,EAAuB3c,SAAS4c,IACPvkB,KAAKqS,IAAIjM,IAAIme,KAElCvkB,KAAKqjB,kBAAkBkB,GAAevkB,KAAKqS,IAAIjM,IAAIme,GAAaC,YAClE,GAEJ,EAKA3B,GAAM/W,UAAU2Y,iBAAmB,WACjC7f,OAAO6G,KAAKzL,KAAKqjB,mBAAmB1b,SAASuE,IAC7BlM,KAAKqjB,kBAAkBnX,GAEnClM,KAAKqS,IAAIjM,IAAI8F,GAAKwY,SAElB1kB,KAAKqS,IAAIjM,IAAI8F,GAAKyY,SACpB,GAEJ,EAQA9B,GAAM/W,UAAU8Y,sBAAwB,SAASL,GAC/C,YAA4Chb,IAAxCvJ,KAAKqjB,kBAAkBkB,IAClBvkB,KAAKqjB,kBAAkBkB,EAMlC,EClZA,MAAMM,GAAa,CAAC,OAAQ,UAAW,SCGxB,YAASxS,GAEtB,IAAIyS,EAAmB,KACnBC,EAAoB,KAExB,MAAMC,EAAQ,CACZ,QAAAC,GAkBE,OAhBA5S,EAAIjM,IAAI8e,IAAI,OAAQF,EAAMG,SAC1BC,cAAcL,GAEdC,EAAMK,eACNhT,EAAIM,MAAM8R,mBACVpS,EAAIa,GAAGoS,gBACPjT,EAAIsH,OAAO4L,uBACXlT,EAAIa,GAAGsS,kBACHnT,EAAIoT,gBAAgBpT,EAAIjM,IAAIsf,QAAQhB,SACxCrS,EAAIjM,IAAM,KACViM,EAAIsT,UAAY,KAChBtT,EAAIM,MAAQ,KAERmS,GAAoBA,EAAiBc,YAAYd,EAAiBc,WAAWC,YAAYf,GAC7FA,EAAmB,KAEZ9kB,IACT,EACA,OAAAmlB,GACE9S,EAAIjM,IAAI8e,IAAI,OAAQF,EAAMG,SAC1BC,cAAcL,GACdC,EAAMc,YACNzT,EAAIM,MAAM2R,iBACVjS,EAAIsH,OAAOoM,mBACb,EACA,KAAAC,CAAM5f,GAUJ,GATAiM,EAAIjM,IAAMA,EACViM,EAAIsH,OChCK,SAAStH,GAEtB,MAAM4T,EAAQrhB,OAAO6G,KAAK4G,EAAIrP,QAAQijB,OAAO9H,QAAO,CAACnP,EAAG/G,KACtD+G,EAAE/G,GAAK,GAAaoK,EAAIrP,QAAQijB,MAAMhe,IAC/B+G,IACN,CAAC,GAEJ,IAAIkX,EAAgB,CAAC,EACjBC,EAAiB,CAAC,EACtB,MAAMxM,EAAS,CAAC,EAChB,IAAIC,EAAkB,KAClBwM,EAAc,KAElBzM,EAAOlI,KAAO,SAASc,EAAO8T,GACxBA,EAAO,CACTljB,MAAOoP,EAAMpP,MACbmX,MAAM,IAAIgM,MAAOC,aAEjBlU,EAAIa,GAAG2G,gBAAgB,CAAEJ,MAAO,EAAkB5E,OAClDuR,EAAY3U,KAAKc,IAEjBA,EAAMiU,cAAcC,iBAExB,EAEA9M,EAAO+M,UAAY,SAASnU,GAC1BoH,EAAOlI,KAAKc,GAAOoU,IAAY1M,EAAQiM,EAAeS,IACxD,EAEAhN,EAAOiN,UAAY,SAASrU,GAC1BoH,EAAOlI,KAAKc,GAAOoU,IAAYjM,EAAMyL,EAAgBQ,IACvD,EAEAhN,EAAOhI,UAAY,SAASY,GAE1B,GAAe,UADgChJ,IAAhCgJ,EAAMiU,cAAcK,QAAwBtU,EAAMiU,cAAcK,QAAUtU,EAAMiU,cAAcM,OAE3G,OAAOnN,EAAO+M,UAAUnU,GAE1B,MAAMwU,EAAS,EAAwBxU,EAAOF,GAC9CE,EAAMyU,cAAgBD,EACtBX,EAAYzU,UAAUY,EACxB,EAEAoH,EAAO/H,UAAY,SAASW,GAC1B2T,EAAgB,CACd5L,MAAM,IAAIgM,MAAOC,UACjBpjB,MAAOoP,EAAMpP,OAEf,MAAM4jB,EAAS,EAAwBxU,EAAOF,GAC9CE,EAAMyU,cAAgBD,EACtBX,EAAYxU,UAAUW,EACxB,EAEAoH,EAAO9H,QAAU,SAASU,GACxB,MAAMwU,EAAS,EAAwBxU,EAAOF,GAC9CE,EAAMyU,cAAgBD,EAElB9M,EAAQiM,EAAe,CACzB/iB,MAAOoP,EAAMpP,MACbmX,MAAM,IAAIgM,MAAOC,YAEjBH,EAAY1U,MAAMa,GAElB6T,EAAYvU,QAAQU,EAExB,EAEAoH,EAAO7H,SAAW,SAASS,GACzB6T,EAAYtU,SAASS,EACvB,EAEAoH,EAAO1H,WAAa,SAASM,GAC3B,IAAKF,EAAIrP,QAAQikB,aACf,OAGFd,EAAiB,CACf7L,MAAM,IAAIgM,MAAOC,UACjBpjB,MAAOoP,EAAMpP,OAEf,MAAM4jB,EAAS,EAAWlO,MAAMtG,EAAO,KAAMF,GAAK,GAClDE,EAAMyU,cAAgBD,EACtBX,EAAYnU,WAAWM,EACzB,EAEAoH,EAAOzH,UAAY,SAASK,GAC1B,GAAKF,EAAIrP,QAAQikB,aAKjB,OADAb,EAAYlU,UAAUK,GACfoH,EAAOiN,UAAUrU,EAC1B,EAEAoH,EAAOxH,SAAW,SAASI,GAIzB,GADAA,EAAMiU,cAAcU,kBACf7U,EAAIrP,QAAQikB,aACf,OAGF,MAAMF,EAAS,EAAWlO,MAAMtG,EAAO,KAAMF,GAAK,GAClDE,EAAMyU,cAAgBD,EAClBrM,EAAMyL,EAAgB,CACxB7L,MAAM,IAAIgM,MAAOC,UACjBpjB,MAAOoP,EAAMpP,QAEbijB,EAAYhU,IAAIG,GAEhB6T,EAAYjU,SAASI,EAEzB,EAIA,MAAM4U,EAAiBC,KAAmB,IAATA,GAAuB,KAATA,GAAgBA,GAAQ,IAAMA,GAAQ,IA0CrF,SAAS/H,EAAWgI,EAAUC,EAAiBC,EAAe,CAAC,GAC7DnB,EAAY1d,OAEZ,MAAM8e,EAAcvB,EAAMoB,GAC1B,QAAoB9d,IAAhBie,EACF,MAAM,IAAIpkB,MAAM,GAAGikB,kBAErBzN,EAAkByN,EAClB,MAAM/V,EAAOkW,EAAYnV,EAAKiV,GAC9BlB,EAAc,EAAiB9U,EAAMe,GAEhCkV,EAAa5D,QAChBtR,EAAIjM,IAAImZ,KAAK,EAAiBnJ,YAAa,CAAE9E,KAAM+V,IAGrDhV,EAAIM,MAAMoR,WACV1R,EAAIM,MAAMD,QACZ,CAzDAiH,EAAO5H,QAAU,SAASQ,IACFA,EAAMkV,YAAclV,EAAMwU,QAAQW,UAAUC,SAAS,EAAkBlU,UAGtE,IAAlBlB,EAAMqV,SAAmC,KAAlBrV,EAAMqV,UAAmBvV,EAAIrP,QAAQ6kB,SAASxU,MAG/D8T,EAAe5U,EAAMqV,SAC9BxB,EAAYrU,QAAQQ,GACO,KAAlBA,EAAMqV,SAAkBvV,EAAIrP,QAAQ6kB,SAAS1kB,MACtDkc,EAAW,EAAgBxJ,YACA,KAAlBtD,EAAMqV,SAAkBvV,EAAIrP,QAAQ6kB,SAASC,YACtDzI,EAAW,EAAgB1J,kBACA,KAAlBpD,EAAMqV,SAAkBvV,EAAIrP,QAAQ6kB,SAASrkB,SACtD6b,EAAW,EAAgBzJ,eAT3BrD,EAAM2U,iBACNd,EAAY/S,SAUhB,EAEAsG,EAAO3H,MAAQ,SAASO,GAClB4U,EAAe5U,EAAMqV,UACvBxB,EAAYpU,MAAMO,EAEtB,EAEAoH,EAAOoO,QAAU,WACf1V,EAAIM,MAAMqV,YACZ,EAEArO,EAAOtK,KAAO,SAASkD,GACrB,GAAuB,UAAnBA,EAAM0V,SAAsB,CAC9B,MAAM,MAAEjD,EAAK,IAAE5e,EAAG,QAAEpD,EAAO,MAAE2P,GAAUN,EACrBrP,EAAQiW,OAAOiP,MAAKC,GAAS/hB,EAAIgT,SAAS+O,EAAMjlB,QAEhE8hB,EAAMc,YACNnT,EAAMoR,WACNpR,EAAMD,SAEV,CACF,EAqBA,MAAM0V,EAAc,CAClB/U,OAAO,EACPC,iBAAiB,EACjBC,mBAAmB,GA8ErB,MAjEY,CACV,KAAAH,GACEwG,EAAkBvH,EAAIrP,QAAQqlB,YAC9BjC,EAAc,EAAiBH,EAAMrM,GAAiBvH,GAAMA,EAC9D,EACAgN,aACAD,WAhBF,SAAoBF,GAClB,IAAIhE,GAAU,EACdtW,OAAO6G,KAAKyT,GAASvX,SAASuV,IAC5B,QAA4B3T,IAAxB6e,EAAYlL,GAAuB,MAAM,IAAI9Z,MAAM,uBACnDglB,EAAYlL,KAAYgC,EAAQhC,KAAShC,GAAU,GACvDkN,EAAYlL,GAAUgC,EAAQhC,EAAO,IAEnChC,GAAS7I,EAAIjM,IAAImZ,KAAK,EAAiBlJ,WAAY,CAAE6I,QAASkJ,GACpE,EASExO,gBAAe,IACNA,EAET8I,kBAAiB,CAACjgB,EAAS4H,IAClB+b,EAAY1T,OAAOjQ,EAAS4H,GAErC,IAAAkV,CAAKzM,EAAW0M,GACTnN,EAAIjM,KACTiM,EAAIjM,IAAImZ,KAAKzM,EAAW0M,EAC1B,EACA,iBAAAuG,GACE1T,EAAIjM,IAAIkM,GAAG,YAAaqH,EAAOhI,WAC/BU,EAAIjM,IAAIkM,GAAG,YAAaqH,EAAO/H,WAC/BS,EAAIjM,IAAIkM,GAAG,UAAWqH,EAAO9H,SAC7BQ,EAAIjM,IAAIkM,GAAG,OAAQqH,EAAOtK,MAE1BgD,EAAIjM,IAAIkM,GAAG,YAAaqH,EAAOzH,WAC/BG,EAAIjM,IAAIkM,GAAG,aAAcqH,EAAO1H,YAChCI,EAAIjM,IAAIkM,GAAG,WAAYqH,EAAOxH,UAE9BE,EAAIsT,UAAU2C,iBAAiB,WAAY3O,EAAO7H,UAE9CO,EAAIrP,QAAQulB,cACdlW,EAAIsT,UAAU2C,iBAAiB,UAAW3O,EAAO5H,SACjDM,EAAIsT,UAAU2C,iBAAiB,QAAS3O,EAAO3H,OAEnD,EACA,oBAAAuT,GACElT,EAAIjM,IAAI8e,IAAI,YAAavL,EAAOhI,WAChCU,EAAIjM,IAAI8e,IAAI,YAAavL,EAAO/H,WAChCS,EAAIjM,IAAI8e,IAAI,UAAWvL,EAAO9H,SAC9BQ,EAAIjM,IAAI8e,IAAI,OAAQvL,EAAOtK,MAE3BgD,EAAIjM,IAAI8e,IAAI,YAAavL,EAAOzH,WAChCG,EAAIjM,IAAI8e,IAAI,aAAcvL,EAAO1H,YACjCI,EAAIjM,IAAI8e,IAAI,WAAYvL,EAAOxH,UAE/BE,EAAIsT,UAAU6C,oBAAoB,WAAY7O,EAAO7H,UAEjDO,EAAIrP,QAAQulB,cACdlW,EAAIsT,UAAU6C,oBAAoB,UAAW7O,EAAO5H,SACpDM,EAAIsT,UAAU6C,oBAAoB,QAAS7O,EAAO3H,OAEtD,EACA,KAAAqB,CAAMrQ,GACJojB,EAAY/S,MAAMrQ,EACpB,EACA,eAAAsQ,GACE8S,EAAY9S,iBACd,EACA,iBAAAC,GACE6S,EAAY7S,mBACd,EACAkV,QAAO,IACE7O,EAKb,CDnOmBD,CAAOtH,GACpBA,EAAIa,GDrCK,SAASb,GAGtB,MAAMqW,EAAiB,CAAC,EACxB,IAAIC,EAAe,KAEfC,EAAoB,CACtBtX,KAAM,KACNxO,QAAS,KACT2W,MAAO,MAGLoP,EAAiB,CACnBvX,KAAM,KACNxO,QAAS,KACT2W,MAAO,MAQT,SAASI,EAAgB7W,GACvB6lB,EAAiBjkB,OAAOkkB,OAAOD,EAAgB7lB,EACjD,CAEA,SAASmQ,IACP,IAAKd,EAAIsT,UAAW,OAEpB,MAAMoD,EAAkB,GAClBC,EAAe,GAErBnE,GAAWld,SAASrG,IACdunB,EAAevnB,KAAUsnB,EAAkBtnB,KAE/CynB,EAAgB1e,KAAK,GAAG/I,KAAQsnB,EAAkBtnB,MACrB,OAAzBunB,EAAevnB,IACjB0nB,EAAa3e,KAAK,GAAG/I,KAAQunB,EAAevnB,MAC9C,IAGEynB,EAAgB1oB,OAAS,GAC3BgS,EAAIsT,UAAU+B,UAAU/a,UAAUoc,GAGhCC,EAAa3oB,OAAS,GACxBgS,EAAIsT,UAAU+B,UAAUtP,OAAO4Q,GAGjCJ,EAAoBhkB,OAAOkkB,OAAOF,EAAmBC,EACvD,CAEA,SAASI,EAAoB/lB,EAAIF,EAAU,CAAC,GAC1C,MAAMkmB,EAASC,SAASC,cAAc,UAoBtC,OAnBAF,EAAOG,UAAY,GAAG,EAAkBzV,kBAAkB5Q,EAAQqmB,YAClEH,EAAOI,aAAa,QAAStmB,EAAQumB,OACrCvmB,EAAQ2iB,UAAU6D,YAAYN,GAE9BA,EAAOZ,iBAAiB,SAAU3a,IAKhC,GAJAA,EAAEuZ,iBACFvZ,EAAE8Y,kBAEoB9Y,EAAEoZ,SACF4B,EAGpB,OAFAc,SACAzmB,EAAQ0mB,eAIV/J,EAAgBzc,GAChBF,EAAQ2mB,YAAY,IACnB,GAEIT,CACT,CAEA,SAASO,IACFd,IACLA,EAAajB,UAAU/a,OAAO,EAAkB0H,eAChDsU,EAAe,KACjB,CAEA,SAAShJ,EAAgBzc,GACvBumB,IAEA,MAAMP,EAASR,EAAexlB,GACzBgmB,GAEDA,GAAiB,UAAPhmB,IACZgmB,EAAOxB,UAAUtP,IAAI,EAAkB/D,eACvCsU,EAAeO,EAEnB,CAqFA,MAAO,CACLvJ,kBACA9F,kBACA1G,mBACAqS,gBApKF,WACE3L,EAAgB,CAACvI,KAAK,KAAMxO,QAAQ,KAAM2W,MAAM,OAChDtG,GACF,EAkKEyW,WAxFF,WACE,MAAM/B,EAAWxV,EAAIrP,QAAQ6kB,SACvBgC,EAAeV,SAASC,cAAc,OAG5C,OAFAS,EAAaR,UAAY,GAAG,EAAkBlV,iBAAiB,EAAkBT,eAE5EmU,GAEDA,EAAS,EAAgB5S,QAC3ByT,EAAe,EAAgBzT,MAAQgU,EAAoB,EAAgBhU,KAAM,CAC/E0Q,UAAWkE,EACXR,UAAW,EAAkBxV,oBAC7B0V,MAAO,oBAAmBlX,EAAIrP,QAAQulB,YAAc,MAAQ,IAC5DoB,WAAY,IAAMtX,EAAIsH,OAAO0F,WAAW,EAAgB1J,kBACxD+T,aAAc,IAAMrX,EAAIsH,OAAOtG,WAI/BwU,EAAS,EAAgB7S,WAC3B0T,EAAe,EAAgB1T,SAAWiU,EAAoB,EAAgBjU,QAAS,CACrF2Q,UAAWkE,EACXR,UAAW,EAAkBvV,uBAC7ByV,MAAO,iBAAgBlX,EAAIrP,QAAQulB,YAAc,MAAQ,IACzDoB,WAAY,IAAMtX,EAAIsH,OAAO0F,WAAW,EAAgBzJ,cACxD8T,aAAc,IAAMrX,EAAIsH,OAAOtG,WAI/BwU,EAAS,EAAgB3S,SAC3BwT,EAAe,EAAgBxT,OAAS+T,EAAoB,EAAgB/T,MAAO,CACjFyQ,UAAWkE,EACXR,UAAW,EAAkBtV,qBAC7BwV,MAAO,gBAAelX,EAAIrP,QAAQulB,YAAc,MAAQ,IACxDoB,WAAY,IAAMtX,EAAIsH,OAAO0F,WAAW,EAAgBxJ,YACxD6T,aAAc,IAAMrX,EAAIsH,OAAOtG,WAI/BwU,EAASxU,QACXqV,EAAerV,MAAQ4V,EAAoB,QAAS,CAClDtD,UAAWkE,EACXR,UAAW,EAAkBrV,qBAC7BuV,MAAO,SACPI,WAAY,KACVtX,EAAIsH,OAAOtG,OAAO,KAKpBwU,EAASiC,mBACXpB,EAAeoB,iBAAmBb,EAAoB,kBAAmB,CACvEtD,UAAWkE,EACXR,UAAW,EAAkBpV,gCAC7BsV,MAAO,UACPI,WAAY,KACVtX,EAAIsH,OAAOrG,iBAAiB,KAK9BuU,EAASkC,qBACXrB,EAAeqB,mBAAqBd,EAAoB,oBAAqB,CAC3EtD,UAAWkE,EACXR,UAAW,EAAkBnV,kCAC7BqV,MAAO,YACPI,WAAY,KACVtX,EAAIsH,OAAOpG,mBAAmB,KAK7BsW,GAjEeA,CAkExB,EAkBEvE,cAhBF,WACE1gB,OAAO6G,KAAKid,GAAgB/gB,SAASqiB,IACnC,MAAMd,EAASR,EAAesB,GAC1Bd,EAAOtD,YACTsD,EAAOtD,WAAWC,YAAYqD,UAEzBR,EAAesB,EAAS,GAEnC,EAUF,CCrJe9W,CAAGb,GACZA,EAAIsT,UAAYvf,EAAI6jB,eACpB5X,EAAIM,MAAQ,IAAIkQ,GAAMxQ,GAGtByS,EAAmBzS,EAAIa,GAAG0W,aAEtBvX,EAAIrP,QAAQknB,UAAW,CACzB7X,EAAIoT,eAAiBrf,EAAIsf,QAAQlB,YACjCpe,EAAIsf,QAAQf,UACZ,MAAMwF,EAAmB/jB,EAAIgkB,QAAQ5F,YAGrCpe,EAAIgkB,QAAQzF,UACZve,EAAIgkB,QAAQ1F,SACPyF,GACH/jB,EAAIgkB,QAAQzF,SAEhB,CAUA,OARIve,EAAIikB,SACNrF,EAAMG,WAEN/e,EAAIkM,GAAG,OAAQ0S,EAAMG,SACrBJ,EAAoBuF,aAAY,KAAYlkB,EAAIikB,UAAUrF,EAAMG,SAAS,GAAK,KAGhF9S,EAAIsH,OAAOvG,QACJ0R,CACT,EACA,SAAAgB,GAEEzT,EAAIjM,IAAImkB,UAAU,EAAkB9V,KAAM,CACxCpF,KAAM,CACJ/N,KAAM,EAAuBgU,mBAC7B1T,SAAU,IAEZN,KAAM,YAIR+Q,EAAIjM,IAAImkB,UAAU,EAAkB/V,IAAK,CACvCnF,KAAM,CACJ/N,KAAM,EAAuBgU,mBAC7B1T,SAAU,IAEZN,KAAM,YAGR+Q,EAAIrP,QAAQiW,OAAOtR,SAASwgB,IAC1B9V,EAAIjM,IAAIokB,SAASrC,EAAM,IAGzB9V,EAAIM,MAAMoR,UAAS,GACnB1R,EAAIM,MAAMD,QACZ,EAGA,YAAA2S,GACEhT,EAAIrP,QAAQiW,OAAOtR,SAASwgB,IACtB9V,EAAIjM,IAAIgT,SAAS+O,EAAMjlB,KACzBmP,EAAIjM,IAAIqkB,YAAYtC,EAAMjlB,GAC5B,IAGEmP,EAAIjM,IAAIwb,UAAU,EAAkBnN,OACtCpC,EAAIjM,IAAIskB,aAAa,EAAkBjW,MAGrCpC,EAAIjM,IAAIwb,UAAU,EAAkBpN,MACtCnC,EAAIjM,IAAIskB,aAAa,EAAkBlW,IAE3C,GAKF,OAFAnC,EAAI2S,MAAQA,EAELA,CACT,CErHA,MAAM2F,GAAO,UACPC,GAAS,UACTC,GAAQ,OAEd,IAIE,CACE,GAAM,uBACN,KAAQ,OACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,YAElB,MAAS,CACP,aAAc,CACZ,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAASD,GACnCD,IAEF,eAAgB,KAOpB,CACE,GAAM,gBACN,KAAQ,OACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,cAChB,CAAC,KAAM,QAAS,YAElB,OAAU,CACR,WAAY,QACZ,YAAa,SAEf,MAAS,CACP,aAAc,CACZ,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAASC,GACnCD,IAEF,iBAAkB,CAChB,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAAS,CAAC,GAAK,GACzC,CAAC,EAAG,IAEN,aAAc,IAMlB,CACE,GAAM,sBACN,KAAQ,SACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,SAChB,CAAC,KAAM,OAAQ,YAEjB,MAAS,CACP,gBAAiB,CACf,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAAS,EACnC,GAEF,eAAgBE,KAGpB,CACE,GAAM,sBACN,KAAQ,SACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,SAChB,CAAC,KAAM,OAAQ,YAEjB,MAAS,CACP,gBAAiB,CACf,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAAS,EACnC,GAEF,eAAgB,CACd,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAASD,GACnCD,MAQN,CACE,GAAM,uBACN,KAAQ,SACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,SAChB,CAAC,KAAM,OAAQ,UACf,CAAC,KAAM,OAAQ,kBAEjB,MAAS,CACP,gBAAiB,CACf,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAAS,EACnC,GAEF,eAAgBE,KAGpB,CACE,GAAM,uBACN,KAAQ,SACR,OAAU,CACR,MACA,CAAC,KAAM,QAAS,SAChB,CAAC,KAAM,OAAQ,UACf,CAAC,KAAM,OAAQ,kBAEjB,MAAS,CACP,gBAAiB,CACf,OACA,CAAC,KAAM,CAAC,MAAO,UAAW,QAAS,EACnC,GAEF,eAAgBD,KAMpB,CACE,GAAM,mBACN,KAAQ,SACR,OAAU,CACR,MACA,CAAC,KAAM,OAAQ,aAEjB,MAAS,CACP,gBAAiB,EACjB,eAAgBA,MCnJf,SAASE,GAAaxpB,GAC3B,OAAO,SAASqM,GACd,MAAMqZ,EAAgBrZ,EAAEqZ,cACxB,QAAKA,MACAA,EAAcnlB,YACZmlB,EAAcnlB,WAAWuK,OAAS9K,EAC3C,CACF,CAEO,SAASypB,GAAiBpd,GAC/B,QAAKA,EAAE6Y,kBACF7Y,EAAE6Y,cAAcwE,UACa,IAA3Brd,EAAE6Y,cAAc0C,OACzB,CAEO,SAAS+B,GAAgBtd,GAC9B,QAAKA,EAAEqZ,kBACFrZ,EAAEqZ,cAAcnlB,aACd8L,EAAEqZ,cAAcnlB,WAAW6X,SAAW,EAAuB3C,QAClEpJ,EAAEqZ,cAAcnlB,WAAWuK,OAAS,EAAegJ,SACvD,CAEO,SAAS8V,GAAkBvd,GAChC,QAAKA,EAAEqZ,kBACFrZ,EAAEqZ,cAAcnlB,aACd8L,EAAEqZ,cAAcnlB,WAAW6X,SAAW,EAAuB1C,UAClErJ,EAAEqZ,cAAcnlB,WAAWuK,OAAS,EAAegJ,SACvD,CAEO,SAAS+V,GAASxd,GACvB,YAA2BpE,IAApBoE,EAAEqZ,aACX,CAEO,SAAS,GAAUrZ,GACxB,QAAKA,EAAEqZ,kBACFrZ,EAAEqZ,cAAcnlB,YACd8L,EAAEqZ,cAAcnlB,WAAWuK,OAAS,EAAegJ,QAC5D,CAEO,SAASgW,GAASzd,GACvB,MAAMqZ,EAAgBrZ,EAAEqZ,cACxB,QAAKA,MACAA,EAAcnlB,YACZmlB,EAAcnlB,WAAWuK,OAAS,EAAeyK,OAC1D,CAEO,SAASwU,GAAY1d,GAC1B,QAAKA,EAAE6Y,gBAC6B,IAA7B7Y,EAAE6Y,cAAcwE,QACzB,CAEO,SAASM,GAAY3d,GAC1B,OAAqB,KAAdA,EAAEia,OACX,CAEO,SAAS2D,GAAW5d,GACzB,OAAqB,KAAdA,EAAEia,OACX,CAEO,SAAS4D,KACd,OAAO,CACT,CCpDe,SAAS,GAAM9c,EAAGoJ,GAC7B9X,KAAK0O,EAAIA,EACT1O,KAAK8X,EAAIA,CACb,CAEA,GAAMhM,UAAY,CAMd,KAAA2f,GAAU,OAAO,IAAI,GAAMzrB,KAAK0O,EAAG1O,KAAK8X,EAAI,EAQ5C,GAAAM,CAAI5J,GAAK,OAAOxO,KAAKyrB,QAAQC,KAAKld,EAAI,EAQtC,GAAAmd,CAAInd,GAAK,OAAOxO,KAAKyrB,QAAQG,KAAKpd,EAAI,EAQtC,WAAAqd,CAAYrd,GAAK,OAAOxO,KAAKyrB,QAAQK,aAAatd,EAAI,EAQtD,UAAAud,CAAWvd,GAAK,OAAOxO,KAAKyrB,QAAQO,YAAYxd,EAAI,EAQpD,IAAAyd,CAAKhkB,GAAK,OAAOjI,KAAKyrB,QAAQS,MAAMjkB,EAAI,EAQxC,GAAAkkB,CAAIlkB,GAAK,OAAOjI,KAAKyrB,QAAQW,KAAKnkB,EAAI,EAQtC,MAAAokB,CAAO9gB,GAAK,OAAOvL,KAAKyrB,QAAQa,QAAQ/gB,EAAI,EAS5C,YAAAghB,CAAahhB,EAAGiD,GAAK,OAAOxO,KAAKyrB,QAAQe,cAAcjhB,EAAGiD,EAAI,EAO9D,OAAAie,CAAQzd,GAAK,OAAOhP,KAAKyrB,QAAQiB,SAAS1d,EAAI,EAS9C,IAAA2d,GAAS,OAAO3sB,KAAKyrB,QAAQmB,OAAS,EAQtC,IAAAC,GAAS,OAAO7sB,KAAKyrB,QAAQqB,OAAS,EAOtC,KAAAtmB,GAAU,OAAOxG,KAAKyrB,QAAQsB,QAAU,EAQxC,GAAAC,GACI,OAAO1sB,KAAK8N,KAAKpO,KAAK0O,EAAI1O,KAAK0O,EAAI1O,KAAK8X,EAAI9X,KAAK8X,EACrD,EAQA,MAAAlL,CAAOqgB,GACH,OAAOjtB,KAAK0O,IAAMue,EAAMve,GACjB1O,KAAK8X,IAAMmV,EAAMnV,CAC5B,EAOA,IAAAoV,CAAK1e,GACD,OAAOlO,KAAK8N,KAAKpO,KAAKmtB,QAAQ3e,GAClC,EASA,OAAA2e,CAAQ3e,GACJ,MAAM4e,EAAK5e,EAAEE,EAAI1O,KAAK0O,EAClB2e,EAAK7e,EAAEsJ,EAAI9X,KAAK8X,EACpB,OAAOsV,EAAKA,EAAKC,EAAKA,CAC1B,EAOA,KAAAtmB,GACI,OAAOzG,KAAKgtB,MAAMttB,KAAK8X,EAAG9X,KAAK0O,EACnC,EAOA,OAAA6e,CAAQ/hB,GACJ,OAAOlL,KAAKgtB,MAAMttB,KAAK8X,EAAItM,EAAEsM,EAAG9X,KAAK0O,EAAIlD,EAAEkD,EAC/C,EAOA,SAAA8e,CAAUhiB,GACN,OAAOxL,KAAKytB,aAAajiB,EAAEkD,EAAGlD,EAAEsM,EACpC,EASA,YAAA2V,CAAa/e,EAAGoJ,GACZ,OAAOxX,KAAKgtB,MACRttB,KAAK0O,EAAIoJ,EAAI9X,KAAK8X,EAAIpJ,EACtB1O,KAAK0O,EAAIA,EAAI1O,KAAK8X,EAAIA,EAC9B,EAGA,QAAA4U,CAAS1d,GACL,MAAMN,EAAIM,EAAE,GAAKhP,KAAK0O,EAAIM,EAAE,GAAKhP,KAAK8X,EAClCA,EAAI9I,EAAE,GAAKhP,KAAK0O,EAAIM,EAAE,GAAKhP,KAAK8X,EAGpC,OAFA9X,KAAK0O,EAAIA,EACT1O,KAAK8X,EAAIA,EACF9X,IACX,EAGA,IAAA0rB,CAAKld,GAGD,OAFAxO,KAAK0O,GAAKF,EAAEE,EACZ1O,KAAK8X,GAAKtJ,EAAEsJ,EACL9X,IACX,EAGA,IAAA4rB,CAAKpd,GAGD,OAFAxO,KAAK0O,GAAKF,EAAEE,EACZ1O,KAAK8X,GAAKtJ,EAAEsJ,EACL9X,IACX,EAGA,KAAAksB,CAAMjkB,GAGF,OAFAjI,KAAK0O,GAAKzG,EACVjI,KAAK8X,GAAK7P,EACHjI,IACX,EAGA,IAAAosB,CAAKnkB,GAGD,OAFAjI,KAAK0O,GAAKzG,EACVjI,KAAK8X,GAAK7P,EACHjI,IACX,EAGA,YAAA8rB,CAAatd,GAGT,OAFAxO,KAAK0O,GAAKF,EAAEE,EACZ1O,KAAK8X,GAAKtJ,EAAEsJ,EACL9X,IACX,EAGA,WAAAgsB,CAAYxd,GAGR,OAFAxO,KAAK0O,GAAKF,EAAEE,EACZ1O,KAAK8X,GAAKtJ,EAAEsJ,EACL9X,IACX,EAEA,KAAA4sB,GAEI,OADA5sB,KAAKosB,KAAKpsB,KAAKgtB,OACRhtB,IACX,EAEA,KAAA8sB,GACI,MAAMhV,EAAI9X,KAAK8X,EAGf,OAFA9X,KAAK8X,EAAI9X,KAAK0O,EACd1O,KAAK0O,GAAKoJ,EACH9X,IACX,EAGA,OAAAssB,CAAQvlB,GACJ,MAAM2mB,EAAMptB,KAAKotB,IAAI3mB,GACjB9F,EAAMX,KAAKW,IAAI8F,GACf2H,EAAIgf,EAAM1tB,KAAK0O,EAAIzN,EAAMjB,KAAK8X,EAC9BA,EAAI7W,EAAMjB,KAAK0O,EAAIgf,EAAM1tB,KAAK8X,EAGlC,OAFA9X,KAAK0O,EAAIA,EACT1O,KAAK8X,EAAIA,EACF9X,IACX,EAMA,aAAAwsB,CAAczlB,EAAOyH,GACjB,MAAMkf,EAAMptB,KAAKotB,IAAI3mB,GACjB9F,EAAMX,KAAKW,IAAI8F,GACf2H,EAAIF,EAAEE,EAAIgf,GAAO1tB,KAAK0O,EAAIF,EAAEE,GAAKzN,GAAOjB,KAAK8X,EAAItJ,EAAEsJ,GACnDA,EAAItJ,EAAEsJ,EAAI7W,GAAOjB,KAAK0O,EAAIF,EAAEE,GAAKgf,GAAO1tB,KAAK8X,EAAItJ,EAAEsJ,GAGvD,OAFA9X,KAAK0O,EAAIA,EACT1O,KAAK8X,EAAIA,EACF9X,IACX,EAEA,MAAA+sB,GAGI,OAFA/sB,KAAK0O,EAAIpO,KAAKkG,MAAMxG,KAAK0O,GACzB1O,KAAK8X,EAAIxX,KAAKkG,MAAMxG,KAAK8X,GAClB9X,IACX,EAEAyH,YAAa,IAcjB,GAAMkmB,QAAU,SAAUnf,GACtB,GAAIA,aAAa,GACb,OAA4B,EAEhC,GAAInL,MAAMC,QAAQkL,GACd,OAAO,IAAI,IAAOA,EAAE,IAAKA,EAAE,IAE/B,QAAYjF,IAARiF,EAAEE,QAA2BnF,IAARiF,EAAEsJ,EACvB,OAAO,IAAI,IAAOtJ,EAAEE,GAAIF,EAAEsJ,GAE9B,MAAM,IAAI1U,MAAM,yCACpB,EChTA,SARA,SAAyBwqB,EAAYjI,GACnC,MAAMkI,EAAOlI,EAAUmI,wBACvB,OAAO,IAAI,GACTF,EAAWG,QAAUF,EAAKG,MAAQrI,EAAUsI,YAAc,GAC1DL,EAAWM,QAAUL,EAAKM,KAAOxI,EAAUyI,WAAa,GAE5D,ECFe,YAASC,EAAU9sB,EAAa8a,EAAMiS,GACnD,MAAO,CACLhtB,KAAM,EAAuB8T,QAC7BvT,WAAY,CACVuK,KAAM,EAAeyK,OACrByL,OAAQ+L,EACRjK,WAAY/H,EACZ3C,OAAQ,EAAa,EAAuB3C,OAAS,EAAuBC,UAE9E3V,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,eAGN,CC1Be,YAAS+gB,EAAQiM,EAAaC,GAC3C,MAAMC,EAAaF,EAAYltB,SAASE,YAClCmtB,EAAWF,EAAUntB,SAASE,YAIpC,GAAIktB,EAAW,GAAK,GAClBA,EAAW,GAAK,GAChBC,EAAS,GAAK,GACdA,EAAS,GAAK,EACd,OAAO,KAGT,MAAMC,EAAM,CACVrS,KAAMmS,EAAW,GAAKC,EAAS,IAAM,EACrCzS,KAAMwS,EAAW,GAAKC,EAAS,IAAM,GAGvC,MAAO,CACLptB,KAAM,EAAuB8T,QAC7BvT,WAAY,CACVuK,KAAM,EAAewK,SACrB0L,SACAhG,IAAKqS,EAAIrS,IACTL,IAAK0S,EAAI1S,IACTmI,WAAYoK,EAAU3sB,WAAWuiB,YAEnC/iB,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,YAAa,CAACotB,EAAIrS,IAAKqS,EAAI1S,MAGjC,CCgDA,SA9EA,SAAS2S,EAA0BnsB,EAASO,EAAU,CAAC,EAAG6rB,EAAW,MACnE,MAAM,KAAEvtB,EAAI,YAAEC,GAAgBkB,EAAQpB,SAChCiI,EAAY7G,EAAQZ,YAAcY,EAAQZ,WAAWqB,GAE3D,IAAI4rB,EAAsB,GAiB1B,SAASC,EAAYC,EAAMC,GACzB,IAAIC,EAAmB,GACnBC,EAAa,KACjBH,EAAKrnB,SAAQ,CAACxE,EAAOisB,KACnB,MAAMC,EAAY,MAACJ,EAAuD,GAAGA,KAAgBG,IAAeE,OAAOF,GAC7GG,EAAS,GAAajmB,EAAWnG,EAAOksB,EAAWG,EAAeH,IAKxE,GAAIrsB,EAAQysB,WAAaN,EAAY,CACnC,MAAMO,EAAW,GAAepmB,EAAW6lB,EAAYI,GACnDG,GACFZ,EAAoBzkB,KAAKqlB,EAE7B,CACAP,EAAaI,EAKb,MAAMI,EAAmBnX,KAAK8C,UAAUnY,GACpC+rB,IAAqBS,GACvBb,EAAoBzkB,KAAKklB,GAER,IAAfH,IACFF,EAAmBS,EACrB,GAEJ,CAEA,SAASH,EAAenT,GACtB,QAAKrZ,EAAQ4sB,gBACmC,IAAzC5sB,EAAQ4sB,cAAc/nB,QAAQwU,EACvC,CAoBA,OArEI/a,IAAS,EAAuB4T,MAElC4Z,EAAoBzkB,KAAK,GAAaf,EAAW/H,EAAastB,EAAUW,EAAeX,KAC9EvtB,IAAS,EAAuB0T,QAGzCzT,EAAYoG,SAAQ,CAACqnB,EAAMa,KACzBd,EAAYC,EAAoB,OAAbH,EAAqB,GAAGA,KAAYgB,IAAcP,OAAOO,GAAW,IAEhFvuB,IAAS,EAAuB+T,YACzC0Z,EAAYxtB,EAAastB,GACsC,IAAtDvtB,EAAKuG,QAAQ,EAAuB0N,eA2C/C,WACE,MAAMua,EAAUxuB,EAAKsc,QAAQ,EAAuBrI,aAAc,IAClEhU,EAAYoG,SAAQ,CAACooB,EAAgBC,KACnC,MAAMC,EAAa,CACjB3uB,KAAM,EAAuB8T,QAC7BvT,WAAYY,EAAQZ,WACpBR,SAAU,CACRC,KAAMwuB,EACNvuB,YAAawuB,IAGjBjB,EAAsBA,EAAoBlS,OAAOgS,EAA0BqB,EAAYjtB,EAASgtB,GAAO,GAE3G,CAvDEE,GAyDKpB,CACT,EChFA,IACE,MAAApK,CAAOrS,GACL8d,YAAW,KAEJ9d,EAAIjM,KAAQiM,EAAIjM,IAAIgqB,iBAAoB/d,EAAI2L,MAAS3L,EAAI2L,KAAKrL,OAAUN,EAAI2L,KAAKrL,MAAMiS,uBAEvFvS,EAAI2L,KAAKrL,MAAMiS,sBAAsB,oBAC1CvS,EAAIjM,IAAIgqB,gBAAgB1L,QAAQ,GAC/B,EACL,EACA,OAAAC,CAAQtS,GACN8d,YAAW,KACJ9d,EAAIjM,KAAQiM,EAAIjM,IAAIgqB,iBAEzB/d,EAAIjM,IAAIgqB,gBAAgBzL,SAAS,GAChC,EACL,ICbAzN,QAAO,GACPE,QAAO,GACPD,iBAAgB,GAChBE,iBAAgB,GAChBC,QAAO,GACPC,QAAO,IACL,EAuBW,YAAS8Y,EAAiBC,GAEvC,IAAIC,EAAiB,GACjBC,EAAiB,GAEjBC,EAAiB,GACjBC,EAAiB,GAEjBC,EAAW,GACXC,EAAW,GAEfP,EAAgB1oB,SAAS7E,IACvB,MAAM+tB,EAlCV,SAAgB/tB,GACd,MAAMguB,EAAQ,CACZhvB,MAAO,EACPE,WAAY,EACZE,QAAS,EACTH,WAAY,EACZE,gBAAiB,EACjBE,aAAc,GACdW,EAAQzB,SAASC,MAEbnB,EAAS,CAAC2C,EAAQzB,SAASE,aAAawvB,KAAKD,GAC7CE,EAAO7wB,EAAOiG,KAAIvD,GAASA,EAAM,KACjCouB,EAAO9wB,EAAOiG,KAAIvD,GAASA,EAAM,KACjC0L,EAAM2iB,GAAQ5wB,KAAKiO,IAAIuB,MAAM,KAAMohB,GACnC7iB,EAAM6iB,GAAQ5wB,KAAK+N,IAAIyB,MAAM,KAAMohB,GACzC,MAAO,CAAC3iB,EAAIyiB,GAAOziB,EAAI0iB,GAAO5iB,EAAI2iB,GAAO3iB,EAAI4iB,GAC/C,CAkBmBE,CAAOruB,GAChBsuB,EAAmBP,EAAO,GAC1BQ,EAAmBR,EAAO,GAC1BS,EAAkBT,EAAO,GACzBU,EAAkBV,EAAO,GAC3BO,EAAmBb,IAAgBA,EAAiBa,GACpDC,EAAmBb,IAAgBA,EAAiBa,GACpDA,EAAmBZ,IAAgBA,EAAiBY,GACpDD,EAAmBV,IAAgBA,EAAiBU,GACpDE,EAAkBX,IAAUA,EAAWW,GACvCC,EAAkBX,IAAUA,EAAWW,EAAe,IAO5D,MAAMC,EAAmBlB,EAoBzB,OAnBIC,EAAiBiB,EAAiBvV,IAAM,KAC1CuV,EAAiBvV,IAAM,GAAmBsU,GAExCE,EAAiBe,EAAiBvV,IAAM,KAC1CuV,EAAiBvV,IAAM,GAAUwU,GAE/BD,EAAiBgB,EAAiBvV,IAAM,KAC1CuV,EAAiBvV,IAAM,GAAmBuU,GAExCE,EAAiBc,EAAiBvV,IAAM,KAC1CuV,EAAiBvV,IAAM,GAAUyU,GAE/BC,EAAWa,EAAiBlV,KAAO,KACrCkV,EAAiBlV,KAAyD,IAAlDhc,KAAKuO,KAAKvO,KAAKC,IAAIixB,EAAiBlV,KAAO,MAEjEsU,EAAWY,EAAiBlV,KAAO,KACrCkV,EAAiBlV,KAAyD,IAAlDhc,KAAKuO,KAAKvO,KAAKC,IAAIixB,EAAiBlV,KAAO,MAG9DkV,CACT,CC/Ee,YAAS5vB,EAAU0uB,GAChC,MAAMkB,EAAmB,GAAyB5vB,EAASwE,KAAItD,GAAWA,EAAQ0Y,cAAc8U,GAEhG1uB,EAAS+F,SAAS7E,IAChB,MAAM2uB,EAAqB3uB,EAAQuY,iBAE7BqW,EAAkB7uB,IACtB,MAAMM,EAAQ,CACZmZ,IAAKzZ,EAAM,GAAK2uB,EAAiBlV,IACjCL,IAAKpZ,EAAM,GAAK2uB,EAAiBvV,KAEnC,MAAO,CAAC9Y,EAAMmZ,IAAKnZ,EAAM8Y,IAAI,EAEzB0V,EAAWlwB,GAAQA,EAAK2E,KAAIvD,GAAS6uB,EAAe7uB,KACpD+uB,EAAmBC,GAASA,EAAMzrB,KAAI3E,GAAQkwB,EAASlwB,KAE7D,IAAIqwB,EACAhvB,EAAQxB,OAAS,EAAuB4T,MAC1C4c,EAAkBJ,EAAeD,GACxB3uB,EAAQxB,OAAS,EAAuB+T,aAAevS,EAAQxB,OAAS,EAAuBkU,YACxGsc,EAAkBL,EAAmBrrB,IAAIsrB,GAChC5uB,EAAQxB,OAAS,EAAuB0T,SAAWlS,EAAQxB,OAAS,EAAuBmU,kBACpGqc,EAAkBL,EAAmBrrB,IAAIurB,GAChC7uB,EAAQxB,OAAS,EAAuBoU,gBACjDoc,EAAkBL,EAAmBrrB,IAAIwrB,IAG3C9uB,EAAQqY,eAAe2W,EAAgB,GAE3C,CCxBA,MAAMC,GAAe,CAErBA,QAAuB,SAASnT,GAE9B,MAAM2C,EAAQ,CACZyQ,iBAAkB,KAClBC,uBAAwB,KACxBC,sBAAkB3oB,EAClB4oB,cAAc,EACdC,cAAc,EACdC,YAAY,EACZC,aAAa,EACbC,oBAAqBvyB,KAAKoG,IAAIgkB,QAAQ5F,YACtCgO,4BAA6B5T,EAAKtF,YAAc,IAYlD,OATAtZ,KAAKie,YAAYsD,EAAMiR,4BAA4BrZ,QAAOjW,QAA8BqG,IAAxBvJ,KAAKwe,WAAWtb,MAChFlD,KAAKyyB,iBAELzyB,KAAKif,mBAAmB,CACtB3L,iBAAiB,EACjBC,mBAAmB,EACnBF,OAAO,IAGFkO,CACT,EAEAwQ,WAA0B,WACxB/xB,KAAKuf,KAAK,EAAiBrJ,OAAQ,CACjCgH,OAAQ,EAAwBtI,KAChChT,SAAU5B,KAAKqe,cAAcjY,KAAI6H,GAAKA,EAAEuN,eAE5C,EAEAuW,eAA8B,WAC5B,MAAMW,EAAmB1yB,KAAKqe,cAExBsU,EAAgBD,EAAiBvZ,QACrCrW,GAAW9C,KAAK8f,aAAa,eAAgBhd,KAG/C,IAAIwQ,GAAkB,EAEtB,GAAIof,EAAiBryB,OAAS,EAAG,CAC/BiT,GAAkB,EAClB,MAAMsf,EAAcF,EAAiB,GAAGpxB,KAAKsc,QAAQ,QAAS,IAC9D8U,EAAiB/qB,SAAS7E,IACpBA,EAAQxB,KAAKsc,QAAQ,QAAS,MAAQgV,IACxCtf,GAAkB,EACpB,GAEJ,CAEA,MAAMC,EAAoBof,EAActyB,OAAS,EAC3CgT,EAAQqf,EAAiBryB,OAAS,EAExCL,KAAKif,mBAAmB,CACtB3L,kBAAiBC,oBAAmBF,SAExC,EAEA0e,aAA4B,SAASc,GACnC,IAAKA,EAAYxyB,OAAQ,MAAO,GAQhC,OAPYwyB,EAAYzsB,KAAI2H,GAAKA,EAAElM,WAAWqB,KAC3CiW,QAAOjW,QAAaqG,IAAPrG,IACbib,QAAO,CAAC2U,EAAM5vB,KACb4vB,EAAK1a,IAAIlV,GACF4vB,IACN,IAAI,GAEEva,QACb,EAEAwZ,yBAAwC,SAASxQ,GAC3CA,EAAM2Q,mBACJ3Q,EAAM2Q,iBAAiBtM,YAAYrE,EAAM2Q,iBAAiBtM,WAAWC,YAAYtE,EAAM2Q,kBAC3F3Q,EAAM2Q,iBAAmB,OAGtB3Q,EAAM+Q,aAAe/Q,EAAM6Q,gBAA+C,IAA9B7Q,EAAMgR,qBACrDvyB,KAAKoG,IAAIgkB,QAAQ1F,SAGnBnD,EAAM4Q,cAAe,EACrB5Q,EAAM6Q,cAAe,EACrB7Q,EAAM8Q,YAAa,EACnB9Q,EAAM+Q,aAAc,CACtB,EAEAP,OAAsB,WACpB,GAAgBrN,OAAO1kB,KACzB,EAEA+xB,YAA2B,SAASxQ,EAAO5T,GAYzC,OAXkB,GAA0BA,IAC3B4T,EAAM8Q,YAAYryB,KAAK+yB,aAOxC/yB,KAAKgzB,yBAAyBzR,IAGvB,CACT,EAEAwQ,WAA0B,SAASxQ,GAEjC,OAAIA,EAAM8Q,YAAmBryB,KAAK+yB,YAIpC,GAEAhB,GAAanR,MAAQmR,GAAa7R,QAAU,SAASqB,EAAO5T,GAE1D,OAAI,GAAyBA,GAAW3N,KAAKizB,cAAc1R,EAAO5T,GAC9D,GAA6B,EAAekJ,OAA5C,CAAoDlJ,GAAW3N,KAAKkzB,cAAc3R,EAAO5T,GACzF,GAA0BA,GAAW3N,KAAKmzB,eAAe5R,EAAO5T,QAApE,CACF,EAEAokB,GAAakB,cAAgB,SAAU1R,GAErC,MAAM6R,EAAcpzB,KAAKse,iBACrB8U,EAAY/yB,SACdL,KAAK8e,wBACLsU,EAAYzrB,SAAQzE,GAAMlD,KAAK+f,SAAS7c,MAE1C,GAAgBwhB,OAAO1kB,MACvBA,KAAKgzB,yBAAyBzR,EAChC,EAEAwQ,GAAamB,cAAgB,SAAS3R,EAAO5T,GAE3C3N,KAAKqf,WAAW,EAAgBtJ,cAAe,CAC7CzM,UAAWqE,EAAEqZ,cAAcnlB,WAAWygB,OACtC+Q,UAAW1lB,EAAEqZ,cAAcnlB,WAAWuiB,WACtCkP,SAAU3lB,EAAE4lB,SAEdvzB,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,MAClD,EAEAmd,GAAayB,qBAAuB,SAASjS,EAAO5T,GAElD3N,KAAKgzB,yBAAyBzR,GAG9BvhB,KAAKoG,IAAIgkB,QAAQzF,UAGjB3kB,KAAK+f,SAASpS,EAAEqZ,cAAcnlB,WAAWqB,IAGzCqe,EAAM+Q,aAAc,EACpB/Q,EAAMyQ,iBAAmBrkB,EAAE4lB,MAC7B,EAEAxB,GAAaoB,eAAiB,SAAS5R,EAAO5T,GAE5C,GAAgBgX,QAAQ3kB,MACxBA,KAAKgzB,yBAAyBzR,GAE9B,MAAMkS,EAAe,GAA4B9lB,GAC3C+lB,EAAqB1zB,KAAKse,iBAC1BhV,EAAYqE,EAAEqZ,cAAcnlB,WAAWqB,GACvCywB,EAAoB3zB,KAAKue,WAAWjV,GAG1C,IAAKmqB,GAAgBE,GAAqB3zB,KAAKwe,WAAWlV,GAAWhI,OAAS,EAAuB4T,MAEnG,OAAOlV,KAAKqf,WAAW,EAAgBtJ,cAAe,CACpDzM,cAKAqqB,GAAqBF,GAEvBzzB,KAAK0e,SAASpV,GACdtJ,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB3E,UACd,IAA9B4e,EAAmBrzB,QACrB,GAAgBqkB,OAAO1kB,QAGf2zB,GAAqBF,GAE/BzzB,KAAKye,OAAOnV,GACZtJ,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,QAEtC+e,GAAsBF,IAEhCC,EAAmB/rB,SAAQzE,GAAMlD,KAAK+f,SAAS7c,KAC/ClD,KAAKie,YAAY3U,GACjBtJ,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,QAIlD5U,KAAK+f,SAASzW,EAChB,EAEAyoB,GAAa3R,YAAc,SAASmB,EAAO5T,GAEzC,OADA4T,EAAMgR,oBAAsBvyB,KAAKoG,IAAIgkB,QAAQ5F,YACzC,GAAgC7W,GAAW3N,KAAKwzB,qBAAqBjS,EAAO5T,GAC5E3N,KAAK+d,WAAWmM,WAAa,GAAiCvc,GAAW3N,KAAK4zB,eAAerS,EAAO5T,QAAxG,CACF,EAEAokB,GAAa6B,eAAiB,SAASrS,EAAO5T,GAC5C3N,KAAKgzB,yBAAyBzR,GAC9BvhB,KAAKoG,IAAIgkB,QAAQzF,UAEjBpD,EAAM0Q,uBAAyB,GAAgBtkB,EAAE6Y,cAAexmB,KAAKoG,IAAI6jB,gBACzE1I,EAAM6Q,cAAe,CACvB,EAEAL,GAAatR,aAAe,SAASc,EAAO5T,GAC1C,GAAI,GAAgCA,GAAI,OAAO3N,KAAKwzB,qBAAqBjS,EAAO5T,EAClF,EAEAokB,GAAa9R,OAAS,SAASsB,EAAO5T,GACpC,OAAI4T,EAAM+Q,YAAoBtyB,KAAK6zB,SAAStS,EAAO5T,GAC/C3N,KAAK+d,WAAWmM,WAAa3I,EAAM6Q,aAAqBpyB,KAAK8zB,eAAevS,EAAO5T,QAAvF,CACF,EAEAokB,GAAa+B,eAAiB,SAASvS,EAAO5T,GAC5C4T,EAAM4Q,cAAe,EACrBnyB,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAG3C4M,EAAM2Q,mBACT3Q,EAAM2Q,iBAAmB/I,SAASC,cAAc,OAChD7H,EAAM2Q,iBAAiBxK,UAAUtP,IAAI,EAAkB9D,YACvDtU,KAAKoG,IAAI6jB,eAAeT,YAAYjI,EAAM2Q,mBAI5C,MAAM6B,EAAU,GAAgBpmB,EAAE6Y,cAAexmB,KAAKoG,IAAI6jB,gBACpD5c,EAAO/M,KAAKiO,IAAIgT,EAAM0Q,uBAAuBvjB,EAAGqlB,EAAQrlB,GACxDnB,EAAOjN,KAAK+N,IAAIkT,EAAM0Q,uBAAuBvjB,EAAGqlB,EAAQrlB,GACxDpB,EAAOhN,KAAKiO,IAAIgT,EAAM0Q,uBAAuBna,EAAGic,EAAQjc,GACxDtK,EAAOlN,KAAK+N,IAAIkT,EAAM0Q,uBAAuBna,EAAGic,EAAQjc,GACxDkc,EAAiB,aAAa3mB,QAAWC,OAC/CiU,EAAM2Q,iBAAiB/J,MAAM8L,UAAYD,EACzCzS,EAAM2Q,iBAAiB/J,MAAM+L,gBAAkBF,EAC/CzS,EAAM2Q,iBAAiB/J,MAAMgM,MAAW5mB,EAAOF,EAAV,KACrCkU,EAAM2Q,iBAAiB/J,MAAMjZ,OAAY1B,EAAOF,EAAV,IACxC,EAEAykB,GAAa8B,SAAW,SAAStS,EAAO5T,GAEtC4T,EAAM8Q,YAAa,EACnB1kB,EAAE6Y,cAAcC,kBAEhB,MAAM6J,EAAQ,CACZhU,IAAK3O,EAAE4lB,OAAOjX,IAAMiF,EAAMyQ,iBAAiB1V,IAC3CL,IAAKtO,EAAE4lB,OAAOtX,IAAMsF,EAAMyQ,iBAAiB/V,KAG7C,GAAajc,KAAKqe,cAAeiS,GAEjC/O,EAAMyQ,iBAAmBrkB,EAAE4lB,MAC7B,EAEAxB,GAAapR,WAAaoR,GAAa1R,UAAY,SAASkB,EAAO5T,GAEjE,GAAI4T,EAAM8Q,WACRryB,KAAK+yB,kBACA,GAAIxR,EAAM4Q,aAAc,CAC7B,MAAM3vB,EAAO,CACX+e,EAAM0Q,uBACN,GAAgBtkB,EAAE6Y,cAAexmB,KAAKoG,IAAI6jB,iBAEtCmK,EAAgBp0B,KAAK2Y,WAAW,KAAMnW,EAAM,SAC5C6xB,EAAcr0B,KAAKs0B,aAAaF,GACnCjb,QAAOjW,IAAOlD,KAAKue,WAAWrb,KAE7BmxB,EAAYh0B,SACdL,KAAKye,OAAO4V,GACZA,EAAY1sB,SAAQzE,GAAMlD,KAAK+f,SAAS7c,KACxClD,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,OAEpD,CACA5U,KAAKgzB,yBAAyBzR,EAChC,EAEAwQ,GAAa9Q,kBAAoB,SAASM,EAAO9e,EAAS8xB,GACxD9xB,EAAQZ,WAAW6X,OAAU1Z,KAAKue,WAAW9b,EAAQZ,WAAWqB,IAC9D,EAAuB6T,OAAS,EAAuBC,SACzDud,EAAQ9xB,GACRzC,KAAKyyB,iBACDhwB,EAAQZ,WAAW6X,SAAW,EAAuB3C,QACvDtU,EAAQpB,SAASC,OAAS,EAAuB4T,OACnD,GAA0BzS,GAASkF,QAAQ4sB,EAC7C,EAEAxC,GAAajR,QAAU,WACrB9gB,KAAK2e,cAAc3e,KAAKse,kBACxBte,KAAKyyB,gBACP,EAEAV,GAAarQ,kBAAoB,WAC/B,MAAMgR,EAAmB1yB,KAAKqe,cAE9B,GAAgC,IAA5BqU,EAAiBryB,QAAgBqyB,EAAiBryB,OAAS,EAAG,OAElE,MAAMkB,EAAc,GAAIizB,EAAmB,GACrC5B,EAAcF,EAAiB,GAAGpxB,KAAKsc,QAAQ,QAAS,IAE9D,IAAK,IAAInd,EAAI,EAAGA,EAAIiyB,EAAiBryB,OAAQI,IAAK,CAChD,MAAMqC,EAAU4vB,EAAiBjyB,GAEjC,GAAIqC,EAAQxB,KAAKsc,QAAQ,QAAS,MAAQgV,EACxC,OAEE9vB,EAAQxB,KAAKmzB,SAAS,SACxB3xB,EAAQuY,iBAAiB1T,SAAS+sB,IAChCnzB,EAAY8I,KAAKqqB,EAAU,IAG7BnzB,EAAY8I,KAAKvH,EAAQuY,kBAG3BmZ,EAAiBnqB,KAAKvH,EAAQ0Y,YAChC,CAEA,GAAIgZ,EAAiBn0B,OAAS,EAAG,CAC/B,MAAMs0B,EAAe30B,KAAK6f,WAAW,CACnCve,KAAM,EAAuB8T,QAC7BvT,WAAY2yB,EAAiB,GAAG3yB,WAChCR,SAAU,CACRC,KAAM,QAAQsxB,IACdrxB,iBAIJvB,KAAK6e,WAAW8V,GAChB30B,KAAK2e,cAAc3e,KAAKse,iBAAkB,CAAEqF,QAAQ,IACpD3jB,KAAKie,YAAY,CAAC0W,EAAazxB,KAE/BlD,KAAKuf,KAAK,EAAiBhJ,iBAAkB,CAC3Cqe,gBAAiB,CAACD,EAAanZ,aAC/BqZ,gBAAiBL,GAErB,CACAx0B,KAAKyyB,gBACP,EAEAV,GAAapQ,oBAAsB,WACjC,MAAM+Q,EAAmB1yB,KAAKqe,cAC9B,GAAgC,IAA5BqU,EAAiBryB,OAAc,OAEnC,MAAMu0B,EAAkB,GAClBE,EAAqB,GAE3B,IAAK,IAAIr0B,EAAI,EAAGA,EAAIiyB,EAAiBryB,OAAQI,IAAK,CAChD,MAAMqC,EAAU4vB,EAAiBjyB,GAE7BT,KAAK8f,aAAa,eAAgBhd,KACpCA,EAAQ+a,cAAclW,SAASsoB,IAC7BjwB,KAAK6e,WAAWoR,GAChBA,EAAWpuB,WAAaiB,EAAQjB,WAChC+yB,EAAgBvqB,KAAK4lB,EAAWzU,aAChCxb,KAAKye,OAAO,CAACwR,EAAW/sB,IAAI,IAE9BlD,KAAK2e,cAAc7b,EAAQI,GAAI,CAAEygB,QAAQ,IACzCmR,EAAmBzqB,KAAKvH,EAAQ0Y,aAEpC,CAEIoZ,EAAgBv0B,OAAS,GAC3BL,KAAKuf,KAAK,EAAiB/I,mBAAoB,CAC7Coe,kBACAC,gBAAiBC,IAGrB90B,KAAKyyB,gBACP,EAEA,YC7XM,GAAW3H,GAAa,EAAejU,QACvCke,GAAajK,GAAa,EAAelU,UAEzCoe,GAAe,CAIrBA,WAA0B,WACxBh1B,KAAKuf,KAAK,EAAiBrJ,OAAQ,CACjCgH,OAAQ,EAAwBvG,mBAChC/U,SAAU5B,KAAKqe,cAAcjY,KAAI6H,GAAKA,EAAEuN,eAE5C,EAEAwZ,eAA8B,SAASzT,GACrCvhB,KAAKif,mBAAmB,CACtB3L,iBAAiB,EACjBC,mBAAmB,EACnBF,MAAOkO,EAAM0T,mBAAmB50B,OAAS,GAE7C,EAEA20B,cAA6B,SAASzT,EAAO5T,GAC3C4T,EAAMgR,oBAAsBvyB,KAAKoG,IAAIgkB,QAAQ5F,YAE7CxkB,KAAKoG,IAAIgkB,QAAQzF,UACjBpD,EAAM+Q,aAAc,EACpB/Q,EAAMyQ,iBAAmBrkB,EAAE4lB,MAC7B,EAEAyB,aAA4B,SAASzT,GAC/BA,EAAM+Q,cAA6C,IAA9B/Q,EAAMgR,qBAC7BvyB,KAAKoG,IAAIgkB,QAAQ1F,SAEnBnD,EAAM8Q,YAAa,EACnB9Q,EAAM+Q,aAAc,EACpB/Q,EAAMyQ,iBAAmB,IAC3B,EAEAgD,SAAwB,SAAUzT,EAAO5T,GACvC3N,KAAKk1B,cAAc3T,EAAO5T,GAC1B,MAAMwnB,EAAQxnB,EAAEqZ,cAAcnlB,WACxBuzB,EAAgB7T,EAAM0T,mBAAmBptB,QAAQstB,EAAM/Q,YACxDiH,GAAY1d,KAAyB,IAAnBynB,EAEZ/J,GAAY1d,KAAyB,IAAnBynB,GAC3B7T,EAAM0T,mBAAmB5qB,KAAK8qB,EAAM/Q,YAFpC7C,EAAM0T,mBAAqB,CAACE,EAAM/Q,YAKpC,MAAMiR,EAAsBr1B,KAAKs1B,mBAAmB/T,EAAMjY,UAAWiY,EAAM0T,oBAC3Ej1B,KAAKke,uBAAuBmX,EAC9B,EAEAL,WAA0B,SAASzT,EAAO5T,GACxC3N,KAAKk1B,cAAc3T,EAAO5T,GAC1B,MAAMwnB,EAAQxnB,EAAEqZ,cAAcnlB,WAC9B0f,EAAMze,QAAQsZ,cAAc+Y,EAAM/Q,WAAY+Q,EAAM7Y,IAAK6Y,EAAMlZ,KAC/Djc,KAAK+yB,aACLxR,EAAM0T,mBAAqB,CAACE,EAAM/Q,WACpC,EAEA4Q,mBAAkC,SAAS1rB,EAAWisB,GACpD,OAAOA,EAAMnvB,KAAIge,IAAc,CAAGhG,WAAY9U,EAAW8a,gBAC3D,EAEA4Q,UAAyB,SAASzT,EAAO5T,GACC,IAApC4T,EAAM0T,mBAAmB50B,OAAcL,KAAKk1B,cAAc3T,EAAO5T,GAChE3N,KAAKw1B,aAAajU,EACzB,EAEAyT,YAA2B,SAASzT,EAAO5T,EAAG2iB,GAC5C,GAAatwB,KAAKqe,cAAeiS,GACjC/O,EAAMyQ,iBAAmBrkB,EAAE4lB,MAC7B,EAEAyB,WAA0B,SAASzT,EAAO5T,EAAG2iB,GAC3C,MAAMmF,EAAiBlU,EAAM0T,mBAAmB7uB,KAAIge,GAAc7C,EAAMze,QAAQqZ,cAAciI,KAUxFoN,EAAmB,GATGiE,EAAervB,KAAIjG,IAAU,CACvDmB,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,YAAapB,OAIsDmwB,GACvE,IAAK,IAAI7vB,EAAI,EAAGA,EAAIg1B,EAAep1B,OAAQI,IAAK,CAC9C,MAAMoC,EAAQ4yB,EAAeh1B,GAC7B8gB,EAAMze,QAAQgZ,iBAAiByF,EAAM0T,mBAAmBx0B,GAAIoC,EAAM,GAAK2uB,EAAiBlV,IAAKzZ,EAAM,GAAK2uB,EAAiBvV,IAC3H,CACF,EAEA+Y,cAA6B,WAC3Bh1B,KAAKqf,WAAW,EAAgBvJ,cAClC,EAEAkf,cAA6B,WAC3Bh1B,KAAKqf,WAAW,EAAgBvJ,cAClC,EAEAkf,mBAAkC,SAAUzT,GAC1CA,EAAM0T,mBAAqB,GAC3Bj1B,KAAKgf,2BACLuC,EAAMze,QAAQoY,SAChB,EAIA8Z,QAAuB,SAASpW,GAC9B,MAAMtV,EAAYsV,EAAKtV,UACjBxG,EAAU9C,KAAKwe,WAAWlV,GAEhC,IAAKxG,EACH,MAAM,IAAIM,MAAM,4DAGlB,GAAIN,EAAQxB,OAAS,EAAuB4T,MAC1C,MAAM,IAAIsI,UAAU,oDAGtB,MAAM+D,EAAQ,CACZjY,YACAxG,UACAkvB,iBAAkBpT,EAAK0U,UAAY,KACnCjB,YAAY,EACZC,aAAa,EACb2C,mBAAoBrW,EAAKyU,UAAY,CAACzU,EAAKyU,WAAa,IAW1D,OARArzB,KAAKke,uBAAuBle,KAAKs1B,mBAAmBhsB,EAAWiY,EAAM0T,qBACrEj1B,KAAKie,YAAY3U,GACjB,GAAgBqb,QAAQ3kB,MAExBA,KAAKif,mBAAmB,CACtB5L,OAAO,IAGFkO,CACT,EAEAyT,OAAsB,WACpB,GAAgBtQ,OAAO1kB,MACvBA,KAAKgf,0BACP,EAEAgW,kBAAiC,SAASzT,EAAO9e,EAAS4H,GACpDkX,EAAMjY,YAAc7G,EAAQZ,WAAWqB,IACzCT,EAAQZ,WAAW6X,OAAS,EAAuB3C,OACnD1M,EAAK5H,GACL,GAA0BA,EAAS,CACjC2D,IAAKpG,KAAKoG,IACVqpB,WAAW,EACXG,cAAerO,EAAM0T,qBACpBttB,QAAQ0C,KAEX5H,EAAQZ,WAAW6X,OAAS,EAAuB1C,SACnD3M,EAAK5H,IAEPzC,KAAKyyB,eAAelR,EACtB,EAEAyT,QAAuB,SAASzT,GAG9BA,EAAM0T,mBACH1kB,MAAK,CAAChF,EAAGC,IAAMA,EAAEkqB,cAAcnqB,EAAG,KAAM,CAAEoqB,SAAS,MACnDhuB,SAAQzE,GAAMqe,EAAMze,QAAQ0Z,iBAAiBtZ,KAChDlD,KAAK+yB,aACLxR,EAAM0T,mBAAqB,GAC3Bj1B,KAAKgf,2BACLhf,KAAKyyB,eAAelR,IACY,IAA5BA,EAAMze,QAAQ+Y,YAChB7b,KAAK2e,cAAc,CAAC4C,EAAMjY,YAC1BtJ,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAC,GAEpD,EAEAkf,YAA2B,SAASzT,EAAO5T,GAEzC,MAAMlF,EAAYwiB,GAAgBtd,GAC5BioB,EAAW,GAASjoB,GACpBkoB,EAAad,GAAWpnB,GACxBmoB,EAA+C,IAApCvU,EAAM0T,mBAAmB50B,OACtCoI,GAAaqtB,GACRF,IAAaE,EADK91B,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,OAEtE5U,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB1E,OAQrD,OANwB6gB,GAAYntB,GAAaotB,IAC1BtU,EAAM8Q,YAAYryB,KAAK+yB,aAE9C/yB,KAAKw1B,aAAajU,IAGX,CACT,EAEAyT,WAA0B,SAASzT,GAKjC,OAHIA,EAAM8Q,YAAYryB,KAAK+yB,cAGpB,CACT,GAEAiC,GAAavU,aAAeuU,GAAa5U,YAAc,SAASmB,EAAO5T,GACrE,OAAI,GAASA,GAAW3N,KAAK41B,SAASrU,EAAO5T,GACzCsd,GAAgBtd,GAAW3N,KAAK+1B,UAAUxU,EAAO5T,GACjDonB,GAAWpnB,GAAW3N,KAAKg2B,WAAWzU,EAAO5T,QAAjD,CACF,EAEAqnB,GAAa/U,OAAS,SAASsB,EAAO5T,GACpC,IAA0B,IAAtB4T,EAAM+Q,YAAsB,OAChC/Q,EAAM8Q,YAAa,EACnB1kB,EAAE6Y,cAAcC,kBAEhB,MAAM6J,EAAQ,CACZhU,IAAK3O,EAAE4lB,OAAOjX,IAAMiF,EAAMyQ,iBAAiB1V,IAC3CL,IAAKtO,EAAE4lB,OAAOtX,IAAMsF,EAAMyQ,iBAAiB/V,KAEzCsF,EAAM0T,mBAAmB50B,OAAS,EAAGL,KAAKi2B,WAAW1U,EAAO5T,EAAG2iB,GAC9DtwB,KAAKk2B,YAAY3U,EAAO5T,EAAG2iB,GAEhC/O,EAAMyQ,iBAAmBrkB,EAAE4lB,MAC7B,EAEAyB,GAAa9U,QAAU,SAASqB,EAAO5T,GACrC,OAAIwd,GAASxd,GAAW3N,KAAKm2B,cAAc5U,EAAO5T,GAC9Csd,GAAgBtd,GAAW3N,KAAKo2B,mBAAmB7U,EAAO5T,GAC1Dud,GAAkBvd,GAAW3N,KAAKq2B,cAAc9U,EAAO5T,QAC3D3N,KAAKw1B,aAAajU,EACpB,EAEAyT,GAAapU,MAAQ,SAASW,EAAO5T,GACnC,OAAIwd,GAASxd,GAAW3N,KAAKm2B,cAAc5U,EAAO5T,GAC9Csd,GAAgBtd,GAAW3N,KAAKo2B,mBAAmB7U,EAAO5T,GAC1Dud,GAAkBvd,GAAW3N,KAAKq2B,cAAc9U,EAAO5T,QAA3D,CACF,EAEAqnB,GAAarU,WAAaqU,GAAa3U,UAAY,SAASkB,GACtDA,EAAM8Q,YACRryB,KAAK+yB,aAEP/yB,KAAKw1B,aAAajU,EACpB,EAEA,YC1PM+U,GAAY,CAElBA,QAAoB,WAClB,MAAMnzB,EAAQnD,KAAK6f,WAAW,CAC5Bve,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,YAAa,MAcjB,OAVAvB,KAAK6e,WAAW1b,GAEhBnD,KAAK8e,wBACL9e,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAChD3U,KAAK0f,iBAAiB,EAAgBxK,OAEtClV,KAAKif,mBAAmB,CACtB5L,OAAO,IAGF,CAAElQ,QACX,EAEAmzB,qBAAiC,SAAS/U,GACxCvhB,KAAK2e,cAAc,CAAC4C,EAAMpe,MAAMD,IAAK,CAAEygB,QAAQ,IAC/C3jB,KAAKqf,WAAW,EAAgBvJ,cAClC,GAEAwgB,GAAU1V,MAAQ0V,GAAUpW,QAAU,SAASqB,EAAO5T,GACpD3N,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB7E,OAChD2M,EAAMpe,MAAM2Y,iBAAiB,GAAInO,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,KACxDjc,KAAKuf,KAAK,EAAiBvJ,OAAQ,CACjCpU,SAAU,CAAC2f,EAAMpe,MAAMqY,eAEzBxb,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAMpe,MAAMD,KAC5E,EAEAozB,GAAUzV,OAAS,SAASU,GAC1BvhB,KAAK0f,mBACA6B,EAAMpe,MAAMgZ,gBAAgB9b,QAC/BL,KAAK2e,cAAc,CAAC4C,EAAMpe,MAAMD,IAAK,CAAEygB,QAAQ,GAEnD,EAEA2S,GAAUrV,kBAAoB,SAASM,EAAO9e,EAAS8xB,GAErD,MAAMgC,EAAgB9zB,EAAQZ,WAAWqB,KAAOqe,EAAMpe,MAAMD,GAE5D,GADAT,EAAQZ,WAAW6X,OAAS,EAAkB,EAAuB3C,OAAS,EAAuBC,UAChGuf,EAAe,OAAOhC,EAAQ9xB,EACrC,EAEA6zB,GAAUxV,QAAUwV,GAAUE,qBAE9BF,GAAU/V,QAAU,SAASgB,EAAO5T,GAClC,GAAI,GAA4BA,IAAM,GAA2BA,GAC/D,OAAO3N,KAAKw2B,qBAAqBjV,EAAO5T,EAE5C,EAEA,YC3DA,SALA,SAA8B4E,EAAOhR,GACnC,QAAKgR,EAAMghB,SACJhhB,EAAMghB,OAAOjX,MAAQ/a,EAAY,IAAMgR,EAAMghB,OAAOtX,MAAQ1a,EAAY,GACjF,ECGMk1B,GAAc,CAEpBA,QAAsB,WACpB,MAAMjzB,EAAUxD,KAAK6f,WAAW,CAC9Bve,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB0T,QAC7BzT,YAAa,CAAC,OAclB,OAVAvB,KAAK6e,WAAWrb,GAEhBxD,KAAK8e,wBACL,GAAgB6F,QAAQ3kB,MACxBA,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAChD3U,KAAK0f,iBAAiB,EAAgB1K,SACtChV,KAAKif,mBAAmB,CACtB5L,OAAO,IAGF,CACL7P,UACAkzB,sBAAuB,EAE3B,EAEAD,cAA4B,SAASlV,EAAO5T,GAC1C,GAAI4T,EAAMmV,sBAAwB,GAAK,GAAqB/oB,EAAG4T,EAAM/d,QAAQjC,YAAY,GAAGggB,EAAMmV,sBAAwB,IACxH,OAAO12B,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAM/d,QAAQN,MAErFlD,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAChD4M,EAAM/d,QAAQsY,iBAAiB,KAAKyF,EAAMmV,wBAAyB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,KAC1FsF,EAAMmV,wBACNnV,EAAM/d,QAAQsY,iBAAiB,KAAKyF,EAAMmV,wBAAyB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,IAC5F,EAEAwa,cAA4B,SAASlV,GACnC,OAAOvhB,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAM/d,QAAQN,KACrF,EAEAuzB,YAA0B,SAASlV,EAAO5T,GACxC4T,EAAM/d,QAAQsY,iBAAiB,KAAKyF,EAAMmV,wBAAyB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,KACtF,GAAyBtO,IAC3B3N,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB3E,SAEpD,GAEA2hB,GAAY7V,MAAQ6V,GAAYvW,QAAU,SAASqB,EAAO5T,GACxD,OAAI,GAAyBA,GAAW3N,KAAKkzB,cAAc3R,EAAO5T,GAC3D3N,KAAKizB,cAAc1R,EAAO5T,EACnC,EAEA8oB,GAAYlW,QAAU,SAASgB,EAAO5T,GAChC,GAA4BA,IAC9B3N,KAAK2e,cAAc,CAAC4C,EAAM/d,QAAQN,IAAK,CAAEygB,QAAQ,IACjD3jB,KAAKqf,WAAW,EAAgBvJ,gBACvB,GAA2BnI,IACpC3N,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAM/d,QAAQN,KAEhF,EAEAuzB,GAAY5V,OAAS,SAASU,GAC5BvhB,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB1E,OAChD,GAAgB2P,OAAO1kB,MACvBA,KAAK0f,wBAGqCnW,IAAtCvJ,KAAKwe,WAAW+C,EAAM/d,QAAQN,MAGlCqe,EAAM/d,QAAQgZ,iBAAiB,KAAK+E,EAAMmV,yBACtCnV,EAAM/d,QAAQqY,UAChB7b,KAAKuf,KAAK,EAAiBvJ,OAAQ,CACjCpU,SAAU,CAAC2f,EAAM/d,QAAQgY,gBAG3Bxb,KAAK2e,cAAc,CAAC4C,EAAM/d,QAAQN,IAAK,CAAEygB,QAAQ,IACjD3jB,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAC,EAAG,CAAE6N,QAAQ,KAEjE,EAEA8S,GAAYxV,kBAAoB,SAASM,EAAO9e,EAAS8xB,GACvD,MAAMoC,EAAkBl0B,EAAQZ,WAAWqB,KAAOqe,EAAM/d,QAAQN,GAEhE,GADAT,EAAQZ,WAAW6X,OAAS,EAAoB,EAAuB3C,OAAS,EAAuBC,UAClG2f,EAAiB,OAAOpC,EAAQ9xB,GAIrC,GAA4C,IAAxCA,EAAQpB,SAASE,YAAYlB,OAAc,OAE/C,MAAMu2B,EAAkBn0B,EAAQpB,SAASE,YAAY,GAAGlB,OAGxD,KAAIu2B,EAAkB,GAAtB,CAKA,GAFAn0B,EAAQZ,WAAWuK,KAAO,EAAegJ,QACzCmf,EAAQ,GAAahT,EAAM/d,QAAQN,GAAIT,EAAQpB,SAASE,YAAY,GAAG,GAAI,OAAO,IAC9Eq1B,EAAkB,EAAG,CAGvB,MAAMC,EAASp0B,EAAQpB,SAASE,YAAY,GAAGlB,OAAS,EACxDk0B,EAAQ,GAAahT,EAAM/d,QAAQN,GAAIT,EAAQpB,SAASE,YAAY,GAAGs1B,GAAS,KAAKA,KAAU,GACjG,CACA,GAAID,GAAmB,EAAG,CAGxB,MAAME,EAAkB,CACtB,CAACr0B,EAAQpB,SAASE,YAAY,GAAG,GAAG,GAAIkB,EAAQpB,SAASE,YAAY,GAAG,GAAG,IAAK,CAACkB,EAAQpB,SAASE,YAAY,GAAG,GAAG,GAAIkB,EAAQpB,SAASE,YAAY,GAAG,GAAG,KAW7J,GARAgzB,EAAQ,CACNjzB,KAAM,EAAuB8T,QAC7BvT,WAAYY,EAAQZ,WACpBR,SAAU,CACRE,YAAau1B,EACbx1B,KAAM,EAAuB+T,eAGT,IAApBuhB,EACF,MAEJ,CAEA,OAAOrC,EAAQ9xB,EA7Bf,CA8BF,EAEAg0B,GAAY3V,QAAU,SAASS,GAC7BvhB,KAAK2e,cAAc,CAAC4C,EAAM/d,QAAQN,IAAK,CAAEygB,QAAQ,IACjD3jB,KAAKqf,WAAW,EAAgBvJ,cAClC,EAEA,YCtIMihB,GAAiB,CAEvBA,QAAyB,SAASnY,GAEhC,MAAMtV,GADNsV,EAAOA,GAAQ,CAAC,GACOtV,UAEvB,IAAI0lB,EAAM0H,EACNM,EAAY,UAChB,GAAI1tB,EAAW,CAEb,GADA0lB,EAAOhvB,KAAKwe,WAAWlV,IAClB0lB,EACH,MAAM,IAAI5rB,MAAM,wDAElB,IAAI6zB,EAAOrY,EAAKqY,KAOhB,GANIA,GAAsB,YAAdA,EAAK31B,MAAsB21B,EAAK51B,UAAmC,UAAvB41B,EAAK51B,SAASC,OACpE21B,EAAOA,EAAK51B,UAEV41B,GAAsB,UAAdA,EAAK31B,MAAoB21B,EAAK11B,aAA2C,IAA5B01B,EAAK11B,YAAYlB,SACxE42B,EAAOA,EAAK11B,cAET01B,IAAS5zB,MAAMC,QAAQ2zB,GAC1B,MAAM,IAAI7zB,MAAM,oFAElB,MAAM8zB,EAAYlI,EAAKztB,YAAYlB,OAAS,EAC5C,GAAI2uB,EAAKztB,YAAY21B,GAAW,KAAOD,EAAK,IAAMjI,EAAKztB,YAAY21B,GAAW,KAAOD,EAAK,GACxFP,EAAwBQ,EAAY,EAEpClI,EAAK5S,cAAcsa,KAA0B1H,EAAKztB,YAAY21B,QACzD,IAAIlI,EAAKztB,YAAY,GAAG,KAAO01B,EAAK,IAAMjI,EAAKztB,YAAY,GAAG,KAAO01B,EAAK,GAM/E,MAAM,IAAI7zB,MAAM,2FALhB4zB,EAAY,YACZN,EAAwB,EAExB1H,EAAK5S,cAAcsa,KAA0B1H,EAAKztB,YAAY,GAGhE,CACF,MACEytB,EAAOhvB,KAAK6f,WAAW,CACrBve,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB+T,YAC7B9T,YAAa,MAGjBm1B,EAAwB,EACxB12B,KAAK6e,WAAWmQ,GAWlB,OARAhvB,KAAK8e,wBACL,GAAgB6F,QAAQ3kB,MACxBA,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAChD3U,KAAK0f,iBAAiB,EAAgBzK,MACtCjV,KAAKif,mBAAmB,CACtB5L,OAAO,IAGF,CACL2b,OACA0H,wBACAM,YAEJ,EAEAD,cAA+B,SAASxV,EAAO5T,GAC7C,GAAI4T,EAAMmV,sBAAwB,GAAK,GAAqB/oB,EAAG4T,EAAMyN,KAAKztB,YAAYggB,EAAMmV,sBAAwB,KAC5F,cAApBnV,EAAMyV,WAA6B,GAAqBrpB,EAAG4T,EAAMyN,KAAKztB,YAAYggB,EAAMmV,sBAAwB,IAClH,OAAO12B,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAMyN,KAAK9rB,MAElFlD,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB9E,MAChD4M,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,KACxD,YAApBsF,EAAMyV,WACRzV,EAAMmV,wBACNnV,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,MAEhFsF,EAAMyN,KAAK5S,cAAc,EAAGzO,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,IAEvD,EAEA8a,cAA+B,SAASxV,GACtC,OAAOvhB,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAMyN,KAAK9rB,KAClF,EAEA6zB,YAA6B,SAASxV,EAAO5T,GAC3C4T,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuB/oB,EAAE4lB,OAAOjX,IAAK3O,EAAE4lB,OAAOtX,KAC5E,GAAyBtO,IAC3B3N,KAAKyf,gBAAgB,CAAEhG,MAAO,EAAkB3E,SAEpD,GAEAiiB,GAAenW,MAAQmW,GAAe7W,QAAU,SAASqB,EAAO5T,GAC9D,GAAI,GAAyBA,GAAI,OAAO3N,KAAKkzB,cAAc3R,EAAO5T,GAClE3N,KAAKizB,cAAc1R,EAAO5T,EAC5B,EAEAopB,GAAexW,QAAU,SAASgB,EAAO5T,GACnC,GAA2BA,GAC7B3N,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAEwD,WAAY,CAACiI,EAAMyN,KAAK9rB,MAChE,GAA4ByK,KACrC3N,KAAK2e,cAAc,CAAC4C,EAAMyN,KAAK9rB,IAAK,CAAEygB,QAAQ,IAC9C3jB,KAAKqf,WAAW,EAAgBvJ,eAEpC,EAEAihB,GAAelW,OAAS,SAASU,GAC/B,GAAgBmD,OAAO1kB,MACvBA,KAAK0f,wBAGkCnW,IAAnCvJ,KAAKwe,WAAW+C,EAAMyN,KAAK9rB,MAG/Bqe,EAAMyN,KAAKxS,iBAAiB,GAAG+E,EAAMmV,yBACjCnV,EAAMyN,KAAKnT,UACb7b,KAAKuf,KAAK,EAAiBvJ,OAAQ,CACjCpU,SAAU,CAAC2f,EAAMyN,KAAKxT,gBAGxBxb,KAAK2e,cAAc,CAAC4C,EAAMyN,KAAK9rB,IAAK,CAAEygB,QAAQ,IAC9C3jB,KAAKqf,WAAW,EAAgBvJ,cAAe,CAAC,EAAG,CAAE6N,QAAQ,KAEjE,EAEAoT,GAAejW,QAAU,SAASS,GAChCvhB,KAAK2e,cAAc,CAAC4C,EAAMyN,KAAK9rB,IAAK,CAAEygB,QAAQ,IAC9C3jB,KAAKqf,WAAW,EAAgBvJ,cAClC,EAEAihB,GAAe9V,kBAAoB,SAASM,EAAO9e,EAAS8xB,GAC1D,MAAM4C,EAAe10B,EAAQZ,WAAWqB,KAAOqe,EAAMyN,KAAK9rB,GAE1D,GADAT,EAAQZ,WAAW6X,OAAS,EAAiB,EAAuB3C,OAAS,EAAuBC,UAC/FmgB,EAAc,OAAO5C,EAAQ9xB,GAE9BA,EAAQpB,SAASE,YAAYlB,OAAS,IAC1CoC,EAAQZ,WAAWuK,KAAO,EAAegJ,QACzCmf,EAAQ,GACNhT,EAAMyN,KAAK9rB,GACXT,EAAQpB,SAASE,YAAgC,YAApBggB,EAAMyV,UAA0Bv0B,EAAQpB,SAASE,YAAYlB,OAAS,EAAI,GACvG,IAAuB,YAApBkhB,EAAMyV,UAA0Bv0B,EAAQpB,SAASE,YAAYlB,OAAS,EAAI,IAC7E,IAGFk0B,EAAQ9xB,GACV,EAEA,MChJA,IACE20B,cAAa,GACbC,cAAa,GACbC,WAAU,GACVC,aAAY,GACZC,iBD2IF,IElJMC,GAAiB,CACrBpP,YAAa,EAAgBvS,cAC7ByS,aAAa,EACbtB,cAAc,EACdrO,YAAa,EACbE,YAAa,GACboR,WAAW,EACXwN,wBAAwB,EACxBze,OAAM,GACNgN,MAAK,GACL4B,SAAU,CAAC,EACXnM,gBAAgB,EAChBuI,mBAAmB,GAGf0T,GAAe,CACnBx0B,OAAO,EACP2kB,aAAa,EACbtkB,SAAS,EACT6P,OAAO,EACPyW,kBAAkB,EAClBC,oBAAoB,GAGhB6N,GAAe,CACnBz0B,OAAO,EACP2kB,aAAa,EACbtkB,SAAS,EACT6P,OAAO,EACPyW,kBAAkB,EAClBC,oBAAoB,GAGtB,SAAS8N,GAAW5e,EAAQ6e,GAC1B,OAAO7e,EAAO7S,KAAK+hB,GACbA,EAAMxc,OAAewc,EAClBvjB,OAAOkkB,OAAO,CAAC,EAAGX,EAAO,CAC9BjlB,GAAI,GAAGilB,EAAMjlB,MAAM40B,IACnBnsB,OAA0B,QAAjBmsB,EAA0B,EAAkBtjB,IAAM,EAAkBC,QAGnF,C,uBC9Ce,YAASlJ,EAAGC,GACzB,OAAID,EAAElL,SAAWmL,EAAEnL,QACZmY,KAAK8C,UAAU/P,EAAEnF,KAAIlD,GAAMA,IAAIqN,UAAYiI,KAAK8C,UAAU9P,EAAEpF,KAAIlD,GAAMA,IAAIqN,OACnF,CCUA,MAAMwnB,GAAe,CACnB71B,QAAO,EACPF,WAAU,EACVF,MAAK,EACLK,aAAc,GACdF,gBAAiB,GACjBF,WAAY,ICZd,MAAMi2B,GAAY,SAASh1B,EAASi1B,GAGlC,MAAM5lB,EAAM,CACVrP,QAHFA,EHwCa,SAASA,EAAU,CAAC,GACjC,IAAIk1B,EAAetzB,OAAOkkB,OAAO,CAAC,EAAG9lB,GAiBrC,OAfKA,EAAQ6kB,WACXqQ,EAAarQ,SAAW,CAAC,IAGY,IAAnC7kB,EAAQ00B,uBACVQ,EAAarQ,SAAWjjB,OAAOkkB,OAAO,CAAC,EAAG8O,GAAc50B,EAAQ6kB,UAEhEqQ,EAAarQ,SAAWjjB,OAAOkkB,OAAO,CAAC,EAAG6O,GAAc30B,EAAQ6kB,UAGlEqQ,EAAetzB,OAAOkkB,OAAO,CAAC,EAAG2O,GAAgBS,GAGjDA,EAAajf,OAAS4e,GAAWK,EAAajf,OAAQ,QAAQ2D,OAAOib,GAAWK,EAAajf,OAAQ,QAE9Fif,CACT,CG3DY,CAAal1B,IAMvBi1B,EDQa,SAAS5lB,EAAK4lB,GAC3BA,EAAIhS,MAAQ,EAGZ,MAAMtC,OAA2Cpa,IAAlC8I,EAAIrP,QAAQihB,qBAAoC5R,EAAIrP,QAAQihB,kBA4K3E,OA1KAgU,EAAIE,gBAAkB,SAASh1B,GAE7B,OADiB,EAAWuO,MAAM,CAAEvO,SAAS,KAAMkP,GACnCjM,KAAItD,GAAWA,EAAQjB,WAAWqB,IACpD,EAEA+0B,EAAI3Z,eAAiB,WACnB,OAAOjM,EAAIM,MAAM2L,gBACnB,EAEA2Z,EAAI5Z,YAAc,WAChB,MAAO,CACL/c,KAAM,EAAuBgU,mBAC7B1T,SAAUyQ,EAAIM,MAAM2L,iBAAiBlY,KAAIlD,GAAMmP,EAAIM,MAAM1B,IAAI/N,KAAKkD,KAAItD,GAAWA,EAAQ0Y,cAE7F,EAEAyc,EAAIG,kBAAoB,WACtB,MAAO,CACL92B,KAAM,EAAuBgU,mBAC7B1T,SAAUyQ,EAAIM,MAAM4Q,yBAAyBnd,KAAIod,IAAc,CAC7DliB,KAAM,EAAuB8T,QAC7BvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM,EAAuB4T,MAC7B3T,YAAaiiB,EAAWjiB,iBAIhC,EAEA02B,EAAII,IAAM,SAASx0B,GACjB,QAA+B0F,IAA3B1F,EAAkBvC,MAAsBuC,EAAkBvC,OAAS,EAAuBgU,qBAAuBjS,MAAMC,QAAQO,EAAkBjC,UACnJ,MAAM,IAAIwB,MAAM,6BAElB,MAAMk1B,EAAcjmB,EAAIM,MAAMiR,oBAC9B,IAAI2U,EAAWlmB,EAAIM,MAAMsP,YAAY1S,QACrC,MAAMipB,EAASP,EAAI7f,IAAIvU,GACjB40B,EAAe,IAAI,EAAUD,GAQnC,OANAD,EAAWA,EAASpf,QAAOjW,IAAOu1B,EAAapgB,IAAInV,KAC/Cq1B,EAASl4B,QACX43B,EAAI3f,OAAOigB,GAGbD,IACOE,CACT,EAEAP,EAAI7f,IAAM,SAAS3V,GACjB,MAEMia,EAFoBlE,KAAKC,MAAMD,KAAK8C,UAAU,GAAU7Y,KAEhCb,SAASwE,KAAKtD,IAG1C,GAFAA,EAAQI,GAAKJ,EAAQI,IAAM+X,IAEF,OAArBnY,EAAQzB,SACV,MAAM,IAAI+B,MAAM,0BAGlB,QAAkCmG,IAA9B8I,EAAIM,MAAM1B,IAAInO,EAAQI,KAAqBmP,EAAIM,MAAM1B,IAAInO,EAAQI,IAAI5B,OAASwB,EAAQzB,SAASC,KAAM,CAEvG,MAAMoc,EAAQqa,GAAaj1B,EAAQzB,SAASC,MAC5C,QAAciI,IAAVmU,EACF,MAAM,IAAIta,MAAM,0BAA0BN,EAAQzB,SAASC,SAE7D,MAAMo3B,EAAkB,IAAIhb,EAAMrL,EAAKvP,GACvCuP,EAAIM,MAAMyF,IAAIsgB,EAAiB,CAAE/U,UACnC,KAAO,CAEL,MAAM+U,EAAkBrmB,EAAIM,MAAM1B,IAAInO,EAAQI,IACxCy1B,EAAqBD,EAAgB72B,WAC3C62B,EAAgB72B,WAAaiB,EAAQjB,WAChC,GAAQ82B,EAAoB71B,EAAQjB,aACvCwQ,EAAIM,MAAMC,eAAe8lB,EAAgBx1B,GAAI,CAAEygB,WAE5C,GAAQ+U,EAAgBrd,iBAAkBvY,EAAQzB,SAASE,cAC9Dm3B,EAAgBvd,eAAerY,EAAQzB,SAASE,YAEpD,CACA,OAAOuB,EAAQI,EAAE,IAInB,OADAmP,EAAIM,MAAMD,SACHgK,CACT,EAGAub,EAAIhnB,IAAM,SAAS/N,GACjB,MAAMJ,EAAUuP,EAAIM,MAAM1B,IAAI/N,GAC9B,GAAIJ,EACF,OAAOA,EAAQ0Y,WAEnB,EAEAyc,EAAI9T,OAAS,WACX,MAAO,CACL7iB,KAAM,EAAuBgU,mBAC7B1T,SAAUyQ,EAAIM,MAAMwR,SAAS/d,KAAItD,GAAWA,EAAQ0Y,cAExD,EAEAyc,EAAI3f,OAAS,SAASgB,GAUpB,OATAjH,EAAIM,MAAM2F,OAAOgB,EAAY,CAAEqK,WAG3BsU,EAAIxP,YAAc,EAAgB1S,eAAkB1D,EAAIM,MAAM2L,iBAAiBje,OAGjFgS,EAAIM,MAAMD,SAFVL,EAAIsH,OAAO0F,WAAW,EAAgBvJ,mBAAevM,EAAW,CAAEoa,WAK7DsU,CACT,EAEAA,EAAIW,UAAY,WAUd,OATAvmB,EAAIM,MAAM2F,OAAOjG,EAAIM,MAAMsP,YAAa,CAAE0B,WAGtCsU,EAAIxP,YAAc,EAAgB1S,cACpC1D,EAAIsH,OAAO0F,WAAW,EAAgBvJ,mBAAevM,EAAW,CAAEoa,WAElEtR,EAAIM,MAAMD,SAGLulB,CACT,EAEAA,EAAI5Y,WAAa,SAAS/N,EAAMunB,EAAc,CAAC,GAE7C,OAAIvnB,IAAS,EAAgBwE,eAAiBmiB,EAAIxP,YAAc,EAAgB3S,eAC1E,GAAoB+iB,EAAYvf,YAAc,GAAKjH,EAAIM,MAAM2L,oBAGjEjM,EAAIM,MAAMsL,YAAY4a,EAAYvf,WAAY,CAAEqK,WAChDtR,EAAIM,MAAMD,UAJiFulB,IAQzF3mB,IAAS,EAAgByE,eAAiBkiB,EAAIxP,YAAc,EAAgB1S,eAC9E8iB,EAAYvvB,YAAc+I,EAAIM,MAAM2L,iBAAiB,IAIvDjM,EAAIsH,OAAO0F,WAAW/N,EAAMunB,EAAa,CAAElV,WAHlCsU,EAKX,EAEAA,EAAIxP,QAAU,WACZ,OAAOpW,EAAIsH,OAAO8O,SACpB,EAEAwP,EAAI5kB,MAAQ,WAEV,OADAhB,EAAIsH,OAAOtG,MAAM,CAAEsQ,WACZsU,CACT,EAEAA,EAAI3kB,gBAAkB,WAEpB,OADAjB,EAAIsH,OAAOrG,gBAAgB,CAAEqQ,WACtBsU,CACT,EAEAA,EAAI1kB,kBAAoB,WAEtB,OADAlB,EAAIsH,OAAOpG,kBAAkB,CAAEoQ,WACxBsU,CACT,EAEAA,EAAI5T,mBAAqB,SAAS/a,EAAWqO,EAAU7S,GAErD,OADAuN,EAAIM,MAAM0R,mBAAmB/a,EAAWqO,EAAU7S,EAAO,CAAE6e,WACpDsU,CACT,EAEOA,CACT,CCzLQ,CAAS5lB,EAAK4lB,GACpB5lB,EAAI4lB,IAAMA,EAEV,MAAMjT,EAAQ,GAAS3S,GAOvB,OALA4lB,EAAIjS,MAAQhB,EAAMgB,MAClBiS,EAAIhT,SAAWD,EAAMC,SACrBgT,EAAIt2B,MAAQ,EACZs2B,EAAIj1B,QAAUA,EAEPi1B,CACT,EAEA,SAASa,GAAW91B,GAClBg1B,GAAUh1B,EAAShD,KACrB,CAEA84B,GAAW7S,MAAQA,GACnB6S,GAAWC,UAAY,EACvBD,GAAWE,IAAM,EAEjB,YC1BO,IAAIj0B,GAAc,UAOdT,GAAU,CACjBU,YAAaD,UACbE,YAAaF,UACbG,QAASH,kBACTI,KAAMJ,gBACNK,OAAsB,MAAdL,GACRM,WAAYN,UACZO,WAAYP,UACZQ,OAAQR,GACRS,OAAQT,GACRU,MAAOV,kBACPW,YAAaX,WACbY,YAAaZ,WACba,cAAeb,GAAc,KAC7BZ,QAAS,EACT0B,MAAOd,mBAmEJ,SAAS,GAAQhC,EAAMlB,EAAYmB,QACtB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIC,EAAO,CAAE3B,KAAM,WASnB,OARmB,IAAf0B,EAAQE,IAAYF,EAAQE,MAC5BD,EAAKC,GAAKF,EAAQE,IAElBF,EAAQR,OACRS,EAAKT,KAAOQ,EAAQR,MAExBS,EAAKpB,WAAaA,GAAc,CAAC,EACjCoB,EAAK5B,SAAW0B,EACTE,CACX,CAkDO,SAAS,GAAM1B,EAAaM,EAAYmB,GAE3C,QADgB,IAAZA,IAAsBA,EAAU,CAAC,IAChCzB,EACD,MAAM,IAAI6B,MAAM,2BAEpB,IAAKC,MAAMC,QAAQ/B,GACf,MAAM,IAAI6B,MAAM,gCAEpB,GAAI7B,EAAYlB,OAAS,EACrB,MAAM,IAAI+C,MAAM,+CAEpB,IAAK,GAAS7B,EAAY,MAAQ,GAASA,EAAY,IACnD,MAAM,IAAI6B,MAAM,oCAMpB,OAAO,GAJI,CACP9B,KAAM,QACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA0CO,SAAS,GAAQzB,EAAaM,EAAYmB,QAC7B,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAK,IAAIS,EAAK,EAAGC,EAAgBnC,EAAakC,EAAKC,EAAcrD,OAAQoD,IAAM,CAC3E,IAAIhC,EAAOiC,EAAcD,GACzB,GAAIhC,EAAKpB,OAAS,EACd,MAAM,IAAI+C,MAAM,+DAEpB,IAAK,IAAIO,EAAI,EAAGA,EAAIlC,EAAKA,EAAKpB,OAAS,GAAGA,OAAQsD,IAE9C,GAAIlC,EAAKA,EAAKpB,OAAS,GAAGsD,KAAOlC,EAAK,GAAGkC,GACrC,MAAM,IAAIP,MAAM,8CAG5B,CAKA,OAAO,GAJI,CACP9B,KAAM,UACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA0CO,SAAS,GAAWzB,EAAaM,EAAYmB,GAEhD,QADgB,IAAZA,IAAsBA,EAAU,CAAC,GACjCzB,EAAYlB,OAAS,EACrB,MAAM,IAAI+C,MAAM,yDAMpB,OAAO,GAJI,CACP9B,KAAM,aACNC,YAAaA,GAEIM,EAAYmB,EACrC,CAgDO,SAASa,GAAkBjC,EAAUoB,QACxB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIc,EAAK,CAAExC,KAAM,qBAQjB,OAPI0B,EAAQE,KACRY,EAAGZ,GAAKF,EAAQE,IAEhBF,EAAQR,OACRsB,EAAGtB,KAAOQ,EAAQR,MAEtBsB,EAAGlC,SAAWA,EACPkC,CACX,CAkBO,SAASC,GAAgBxC,EAAaM,EAAYmB,GAMrD,YALgB,IAAZA,IAAsBA,EAAU,CAAC,GAK9B,GAJI,CACP1B,KAAM,kBACNC,YAAaA,GAEIM,EAAYmB,EACrC,CA6GO,SAASkB,GAAgBC,EAASC,QACvB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASC,GAAQF,GACrB,IAAKC,EACD,MAAM,IAAIjB,MAAMgB,EAAQ,qBAE5B,OAAOD,EAAUE,CACrB,CAWO,SAASE,GAAgBC,EAAUJ,QACxB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASC,GAAQF,GACrB,IAAKC,EACD,MAAM,IAAIjB,MAAMgB,EAAQ,qBAE5B,OAAOI,EAAWH,CACtB,CAoCO,SAASI,GAAiBN,GAE7B,OAAkB,KADJA,GAAW,EAAI7D,KAAKc,KACTd,KAAKc,EAClC,CAQO,SAAS4F,GAAiB9B,GAE7B,OADcA,EAAU,IACN5E,KAAKc,GAAM,GACjC,CAqDO,SAAS,GAASsD,GACrB,OAAQC,MAAMD,IAAgB,OAARA,IAAiBrB,MAAMC,QAAQoB,EACzD,CC1lBO,SAASu0B,GAASp2B,GACrB,IAAKA,EACD,MAAM,IAAIO,MAAM,qBAEpB,IAAKC,MAAMC,QAAQT,GAAQ,CACvB,GAAmB,YAAfA,EAAMvB,MACa,OAAnBuB,EAAMxB,UACkB,UAAxBwB,EAAMxB,SAASC,KACf,OAAOuB,EAAMxB,SAASE,YAE1B,GAAmB,UAAfsB,EAAMvB,KACN,OAAOuB,EAAMtB,WAErB,CACA,GAAI8B,MAAMC,QAAQT,IACdA,EAAMxC,QAAU,IACfgD,MAAMC,QAAQT,EAAM,MACpBQ,MAAMC,QAAQT,EAAM,IACrB,OAAOA,EAEX,MAAM,IAAIO,MAAM,qDACpB,CAaO,SAAS81B,GAAU/4B,GACtB,GAAIkD,MAAMC,QAAQnD,GACd,OAAOA,EAGX,GAAoB,YAAhBA,EAAOmB,MACP,GAAwB,OAApBnB,EAAOkB,SACP,OAAOlB,EAAOkB,SAASE,iBAK3B,GAAIpB,EAAOoB,YACP,OAAOpB,EAAOoB,YAGtB,MAAM,IAAI6B,MAAM,8DACpB,CA2HO,SAAS+1B,GAAQ12B,GACpB,MAAqB,YAAjBA,EAAQnB,KACDmB,EAAQpB,SAEZoB,CACX,CCpKe,SAAS22B,GAAsBj2B,EAAOK,EAASR,GAG1D,QAFgB,IAAZA,IAAsBA,EAAU,CAAC,IAEhCG,EACD,MAAM,IAAIC,MAAM,qBAEpB,IAAKI,EACD,MAAM,IAAIJ,MAAM,uBAEpB,IAAIi2B,EAAKJ,GAAS91B,GACdJ,EAAOo2B,GAAQ31B,GACflC,EAAOyB,EAAKzB,KACZkB,EAAOgB,EAAQhB,KACf82B,EAAQv2B,EAAKxB,YAEjB,GAAIiB,IAA6B,IAqErC,SAAgB62B,EAAI72B,GAChB,OAAQA,EAAK,IAAM62B,EAAG,IAAM72B,EAAK,IAAM62B,EAAG,IAAM72B,EAAK,IAAM62B,EAAG,IAAM72B,EAAK,IAAM62B,EAAG,EACtF,CAvEgBE,CAAOF,EAAI72B,GACnB,OAAO,EAGE,YAATlB,IACAg4B,EAAQ,CAACA,IAGb,IADA,IAAIE,GAAa,EACR/4B,EAAI,EAAGA,EAAI64B,EAAMj5B,SAAWm5B,EAAY/4B,IAE7C,GAAIg5B,GAAOJ,EAAIC,EAAM74B,GAAG,GAAIuC,EAAQ02B,gBAAiB,CAIjD,IAHA,IAAIC,GAAS,EACT1xB,EAAI,EAEDA,EAAIqxB,EAAM74B,GAAGJ,SAAWs5B,GACvBF,GAAOJ,EAAIC,EAAM74B,GAAGwH,IAAKjF,EAAQ02B,kBACjCC,GAAS,GAEb1xB,IAEC0xB,IACDH,GAAa,EAErB,CAEJ,OAAOA,CACX,CAUA,SAASC,GAAOJ,EAAI53B,EAAMi4B,GACtB,IAAIE,GAAW,EACXn4B,EAAK,GAAG,KAAOA,EAAKA,EAAKpB,OAAS,GAAG,IACrCoB,EAAK,GAAG,KAAOA,EAAKA,EAAKpB,OAAS,GAAG,KACrCoB,EAAOA,EAAK8N,MAAM,EAAG9N,EAAKpB,OAAS,IAEvC,IAAK,IAAII,EAAI,EAAGkD,EAAIlC,EAAKpB,OAAS,EAAGI,EAAIgB,EAAKpB,OAAQsD,EAAIlD,IAAK,CAC3D,IAAIo5B,EAAKp4B,EAAKhB,GAAG,GACbq5B,EAAKr4B,EAAKhB,GAAG,GACbs5B,EAAKt4B,EAAKkC,GAAG,GACbq2B,EAAKv4B,EAAKkC,GAAG,GAIjB,GAHiB01B,EAAG,IAAMQ,EAAKE,GAAMD,GAAMC,EAAKV,EAAG,IAAMW,GAAMX,EAAG,GAAKQ,IAAQ,IAC1EA,EAAKR,EAAG,KAAOU,EAAKV,EAAG,KAAO,IAC9BS,EAAKT,EAAG,KAAOW,EAAKX,EAAG,KAAO,EAE/B,OAAQK,EAEII,EAAKT,EAAG,IAAOW,EAAKX,EAAG,IACnCA,EAAG,IAAOU,EAAKF,IAAOR,EAAG,GAAKS,IAAQE,EAAKF,GAAMD,IAEjDD,GAAYA,EAEpB,CACA,OAAOA,CACX,CC8RA,SAAS3wB,GAAYxG,EAASsF,GAC5B,GAAqB,YAAjBtF,EAAQnB,KACVyG,EAAStF,EAAS,QACb,GAAqB,sBAAjBA,EAAQnB,KACjB,IAAK,IAAIb,EAAI,EAAGA,EAAIgC,EAAQb,SAASvB,SACM,IAArC0H,EAAStF,EAAQb,SAASnB,GAAIA,GADSA,KAIjD,CA6GA,SAASyI,GAASzG,EAASsF,GACzB,IAAItH,EACFkD,EACAwF,EACA9H,EACA8G,EACAC,EACAC,EACAe,EACAC,EACAC,EACAX,EAAe,EACfH,EAAuC,sBAAjB/F,EAAQnB,KAC9BmH,EAA6B,YAAjBhG,EAAQnB,KACpBoH,EAAOF,EAAsB/F,EAAQb,SAASvB,OAAS,EAczD,IAAKI,EAAI,EAAGA,EAAIiI,EAAMjI,IAAK,CA4BzB,IA3BA2H,EAA0BI,EACtB/F,EAAQb,SAASnB,GAAGY,SACpBoH,EACAhG,EAAQpB,SACRoB,EACJ2G,EAAoBZ,EAChB/F,EAAQb,SAASnB,GAAGoB,WACpB4G,EACAhG,EAAQZ,WACR,CAAC,EACLwH,EAAcb,EACV/F,EAAQb,SAASnB,GAAG+B,KACpBiG,EACAhG,EAAQD,UACR+G,EACJD,EAAYd,EACR/F,EAAQb,SAASnB,GAAGyC,GACpBuF,EACAhG,EAAQS,QACRqG,EAIJpB,GAHAE,IAAuBD,GACc,uBAAjCA,EAAwB9G,MAGxB8G,EAAwB5G,WAAWnB,OACnC,EAEC8I,EAAI,EAAGA,EAAIhB,EAAOgB,IAMrB,GAAiB,QALjB9H,EAAWgH,EACPD,EAAwB5G,WAAW2H,GACnCf,GAgBJ,OAAQ/G,EAASC,MACf,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACH,IAOQ,IANNyG,EACE1G,EACAsH,EACAS,EACAC,EACAC,GAGF,OAAO,EACT,MAEF,IAAK,qBACH,IAAK3F,EAAI,EAAGA,EAAItC,EAASG,WAAWnB,OAAQsD,IAC1C,IAOQ,IANNoE,EACE1G,EAASG,WAAWmC,GACpBgF,EACAS,EACAC,EACAC,GAGF,OAAO,EAEX,MAEF,QACE,MAAM,IAAIlG,MAAM,8BA/ClB,IAOQ,IANN2E,EACE,KACAY,EACAS,EACAC,EACAC,GAGF,OAAO,EA0CbX,GACF,CACF,CAyGA,SAASa,GAAY/G,EAASsF,GAC5BmB,GAASzG,GAAS,SAAUpB,EAAUsH,EAAc9G,EAAYW,EAAMU,GAEpE,IAiBI6F,EAjBAzH,EAAoB,OAAbD,EAAoB,KAAOA,EAASC,KAC/C,OAAQA,GACN,KAAK,KACL,IAAK,QACL,IAAK,aACL,IAAK,UACH,OAKQ,IAJNyG,EACE,GAAQ1G,EAAUQ,EAAY,CAAEW,KAAMA,EAAMU,GAAIA,IAChDyF,EACA,SAIJ,EAMJ,OAAQrH,GACN,IAAK,aACHyH,EAAW,QACX,MACF,IAAK,kBACHA,EAAW,aACX,MACF,IAAK,eACHA,EAAW,UAIf,IACE,IAAIF,EAAoB,EACxBA,EAAoBxH,EAASE,YAAYlB,OACzCwI,IACA,CACA,IAAI2a,EAAaniB,EAASE,YAAYsH,GAKtC,IAEE,IADAd,EAAS,GALA,CACTzG,KAAMyH,EACNxH,YAAaiiB,GAGU3hB,GAAa8G,EAAcE,GAGlD,OAAO,CACX,CACF,GACF,CC/qBA,SA3EA,SAAqBpG,GACjB,IAAKA,EACD,MAAM,IAAIW,MAAM,uBAEpB,IAAI62B,EAAU,GAId,OAHAzwB,GAAY/G,GAAS,SAAUK,IAanC,SAA4BL,EAASw3B,GACjC,IAAI95B,EAAS,GACTkB,EAAWoB,EAAQpB,SACvB,GAAiB,OAAbA,EAAmB,CACnB,OAAQA,EAASC,MACb,IAAK,UACDnB,EAAS+4B,GAAU73B,GACnB,MACJ,IAAK,aACDlB,EAAS,CAAC+4B,GAAU73B,IAE5BlB,EAAOwH,SAAQ,SAAU9E,GACrB,IAAIq3B,EAgBhB,SAAwB/5B,EAAQ0B,GAC5B,IAAIq4B,EAAW,GAOf,OANA/5B,EAAOge,QAAO,SAAUxU,EAAgBwwB,GACpC,IAeMC,EAASC,EACfC,EACAC,EACAC,EACAC,EAnBIC,EAAU,GAAW,CAAC/wB,EAAgBwwB,GAAgBt4B,GAG1D,OAFA64B,EAAQl4B,MAcO63B,EAdqBF,EAepCG,GADMF,EAdczwB,GAeP,GACb4wB,EAAKH,EAAQ,GACbI,EAAKH,EAAQ,GACbI,EAAKJ,EAAQ,GAKV,CAJIC,EAAKE,EAAKF,EAAKE,EACdD,EAAKE,EAAKF,EAAKE,EAChBH,EAAKE,EAAKF,EAAKE,EACdD,EAAKE,EAAKF,EAAKE,IArBvBP,EAAS7vB,KAAKqwB,GACPP,CACX,IACOD,CACX,CAzB2BS,CAAe93B,EAAOJ,EAAQZ,YAC7Cq4B,EAASvyB,SAAQ,SAAU+yB,GACvBA,EAAQx3B,GAAK+2B,EAAQ55B,OACrB45B,EAAQ5vB,KAAKqwB,EACjB,GACJ,GACJ,CACJ,CA/BQE,CAAmB93B,EAASm3B,EAChC,IACOp2B,GAAkBo2B,EAC7B,E,cC6CA,SAASY,GAAWC,EAAOC,GACvB,IAAIX,EAAUlB,GAAU4B,GACpBT,EAAUnB,GAAU6B,GACxB,GAAuB,IAAnBX,EAAQ/5B,OACR,MAAM,IAAI+C,MAAM,sDAEpB,GAAuB,IAAnBi3B,EAAQh6B,OACR,MAAM,IAAI+C,MAAM,sDAEpB,IAAIk3B,EAAKF,EAAQ,GAAG,GAChBG,EAAKH,EAAQ,GAAG,GAChBI,EAAKJ,EAAQ,GAAG,GAChBK,EAAKL,EAAQ,GAAG,GAChBY,EAAKX,EAAQ,GAAG,GAChBY,EAAKZ,EAAQ,GAAG,GAChBa,EAAKb,EAAQ,GAAG,GAChBc,EAAKd,EAAQ,GAAG,GAChBe,GAASD,EAAKF,IAAOT,EAAKF,IAAOY,EAAKF,IAAOP,EAAKF,GAClDc,GAASH,EAAKF,IAAOT,EAAKU,IAAOE,EAAKF,IAAOX,EAAKU,GAClDM,GAASd,EAAKF,IAAOC,EAAKU,IAAOR,EAAKF,IAAOD,EAAKU,GACtD,GAAc,IAAVI,EACA,OACW,KAIf,IAAIG,EAAKF,EAAQD,EACbI,EAAKF,EAAQF,EACjB,OAAIG,GAAM,GAAKA,GAAM,GAAKC,GAAM,GAAKA,GAAM,EAGhC,GAAM,CAFLlB,EAAKiB,GAAMf,EAAKF,GAChBC,EAAKgB,GAAMd,EAAKF,KAGrB,IACX,CACA,SAtFA,SAAuBO,EAAOC,GAC1B,IAAIU,EAAS,CAAC,EACVxB,EAAU,GASd,GANmB,eAAfa,EAAMx5B,OACNw5B,EAAQ,GAAQA,IAED,eAAfC,EAAMz5B,OACNy5B,EAAQ,GAAQA,IAED,YAAfD,EAAMx5B,MACS,YAAfy5B,EAAMz5B,MACa,OAAnBw5B,EAAMz5B,UACa,OAAnB05B,EAAM15B,UACkB,eAAxBy5B,EAAMz5B,SAASC,MACS,eAAxBy5B,EAAM15B,SAASC,MACuB,IAAtCw5B,EAAMz5B,SAASE,YAAYlB,QACW,IAAtC06B,EAAM15B,SAASE,YAAYlB,OAAc,CACzC,IAAIq7B,EAAYb,GAAWC,EAAOC,GAIlC,OAHIW,GACAzB,EAAQ5vB,KAAKqxB,GAEV73B,GAAkBo2B,EAC7B,CAEA,IAAIztB,EAAO,KAeX,OAdAA,EAAKE,KAAK,GAAYquB,IACtB9xB,GAAY,GAAY6xB,IAAQ,SAAUJ,GACtCzxB,GAAYuD,EAAKM,OAAO4tB,IAAU,SAAUiB,GACxC,IAAID,EAAYb,GAAWH,EAASiB,GACpC,GAAID,EAAW,CAEX,IAAIxvB,EAAMgtB,GAAUwC,GAAWre,KAAK,KAC/Boe,EAAOvvB,KACRuvB,EAAOvvB,IAAO,EACd+tB,EAAQ5vB,KAAKqxB,GAErB,CACJ,GACJ,IACO73B,GAAkBo2B,EAC7B,EC3Ce,SAAS,GAAC2B,EAAM54B,QACX,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAID,EAAOo2B,GAAQyC,GAInB,OAHK54B,EAAQnB,YAA4B,YAAd+5B,EAAKt6B,OAC5B0B,EAAQnB,WAAa+5B,EAAK/5B,YAEtBkB,EAAKzB,MACT,IAAK,UACD,OAUL,SAAuBs6B,EAAM54B,QAChB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAID,EAAOo2B,GAAQyC,GACfz7B,EAAS4C,EAAKxB,YACdM,EAAamB,EAAQnB,WACnBmB,EAAQnB,WACM,YAAd+5B,EAAKt6B,KACDs6B,EAAK/5B,WACL,CAAC,EACX,OAAOg6B,GAAa17B,EAAQ0B,EAChC,CApBmBi6B,CAAc/4B,EAAMC,GAC/B,IAAK,eACD,OAsBL,SAA4B+4B,EAAW/4B,QAC1B,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAID,EAAOo2B,GAAQ4C,GACf57B,EAAS4C,EAAKxB,YACdM,EAAamB,EAAQnB,WACnBmB,EAAQnB,WACW,YAAnBk6B,EAAUz6B,KACNy6B,EAAUl6B,WACV,CAAC,EACPm6B,EAAQ,GAIZ,OAHA77B,EAAOwH,SAAQ,SAAU9E,GACrBm5B,EAAM3xB,KAAKwxB,GAAah5B,EAAOhB,GACnC,IACOgC,GAAkBm4B,EAC7B,CApCmBC,CAAmBl5B,EAAMC,GACpC,QACI,MAAM,IAAII,MAAM,gBAE5B,CAoCO,SAASy4B,GAAa17B,EAAQ0B,GACjC,OAAI1B,EAAOE,OAAS,EACT0D,GAAgB5D,EAAQ0B,GAE5B,GAAW1B,EAAO,GAAI0B,EACjC,CCCA,SAASq6B,GAAct4B,EAAYy1B,GAC/B,IAAK,IAAI54B,EAAI,EAAGA,EAAImD,EAAWrC,YAAYlB,OAAS,EAAGI,IACnD,GAAI07B,GAAqBv4B,EAAWrC,YAAYd,GAAImD,EAAWrC,YAAYd,EAAI,GAAI44B,EAAG93B,aAClF,OAAO,EAGf,OAAO,CACX,CAQA,SAAS66B,GAAa54B,EAASI,GAC3B,IAAK,IAAIH,EAAK,EAAG44B,EAAKz4B,EAAWrC,YAAakC,EAAK44B,EAAGh8B,OAAQoD,IAAM,CAEhE,GAAI21B,GADQiD,EAAG54B,GACkBD,GAC7B,OAAO,CAEf,CAEA,OADuB,GAAcI,EAAY,GAAcJ,IAC1C5B,SAASvB,OAAS,CAI3C,CA8BA,SAAS87B,GAAqBG,EAAkBC,EAAgBlD,GAC5D,IAAImD,EAAMnD,EAAG,GAAKiD,EAAiB,GAC/BG,EAAMpD,EAAG,GAAKiD,EAAiB,GAC/BI,EAAMH,EAAe,GAAKD,EAAiB,GAC3CK,EAAMJ,EAAe,GAAKD,EAAiB,GAE/C,OAAc,GADFE,EAAMG,EAAMF,EAAMC,IAI1Bp8B,KAAKC,IAAIm8B,IAAQp8B,KAAKC,IAAIo8B,GACtBD,EAAM,EACCJ,EAAiB,IAAMjD,EAAG,IAAMA,EAAG,IAAMkD,EAAe,GAGxDA,EAAe,IAAMlD,EAAG,IAAMA,EAAG,IAAMiD,EAAiB,GAG9DK,EAAM,EACJL,EAAiB,IAAMjD,EAAG,IAAMA,EAAG,IAAMkD,EAAe,GAGxDA,EAAe,IAAMlD,EAAG,IAAMA,EAAG,IAAMiD,EAAiB,GAEvE,CAYA,SArJA,SAAyBM,EAAUC,GAC/B,IAAIC,GAAO,EASX,OARAtzB,GAAYozB,GAAU,SAAUG,GAC5BvzB,GAAYqzB,GAAU,SAAUG,GAC5B,IAAa,IAATF,EACA,OAAO,EAEXA,EAaZ,SAAkBG,EAAOC,GACrB,OAAQD,EAAM37B,MACV,IAAK,QACD,OAAQ47B,EAAM57B,MACV,IAAK,QACD,OAyHG67B,EAzHmBF,EAAM17B,YAyHlB67B,EAzH+BF,EAAM37B,cA0HxD47B,EAAM,KAAOC,EAAM,IAAMD,EAAM,KAAOC,EAAM,IAzHvC,IAAK,aACD,OAAQlB,GAAcgB,EAAOD,GACjC,IAAK,UACD,OAAQ7D,GAAsB6D,EAAOC,GAG7C,MACJ,IAAK,aACD,OAAQA,EAAM57B,MACV,IAAK,QACD,OAAQ46B,GAAce,EAAOC,GACjC,IAAK,aACD,OA2BpB,SAAsBG,EAAaC,GAE/B,GADuB,GAAcD,EAAaC,GAC7B17B,SAASvB,OAAS,EACnC,OAAO,EAEX,OAAO,CACX,CAjC4Bk9B,CAAaN,EAAOC,GAChC,IAAK,UACD,OAAQd,GAAac,EAAOD,GAGpC,MACJ,IAAK,UACD,OAAQC,EAAM57B,MACV,IAAK,QACD,OAAQ83B,GAAsB8D,EAAOD,GACzC,IAAK,aACD,OAAQb,GAAaa,EAAOC,GAChC,IAAK,UACD,OA4CpB,SAAsBN,EAAUC,GAC5B,IAAK,IAAIp5B,EAAK,EAAG44B,EAAKO,EAASr7B,YAAY,GAAIkC,EAAK44B,EAAGh8B,OAAQoD,IAAM,CAEjE,GAAI21B,GADSiD,EAAG54B,GACkBo5B,GAC9B,OAAO,CAEf,CACA,IAAK,IAAIW,EAAK,EAAGC,EAAKZ,EAASt7B,YAAY,GAAIi8B,EAAKC,EAAGp9B,OAAQm9B,IAAM,CAEjE,GAAIpE,GADSqE,EAAGD,GACkBZ,GAC9B,OAAO,CAEf,CACA,IAAIc,EAAmB,GAAc,GAAcd,GAAW,GAAcC,IAC5E,GAAIa,EAAiB97B,SAASvB,OAAS,EACnC,OAAO,EAEX,OAAO,CACX,CA9D4Bs9B,CAAaT,EAAOD,IA+FhD,IAAuBE,EAAOC,EA5F1B,OAAO,CACX,CAhDmBQ,CAASb,EAAS17B,SAAU27B,EAAS37B,SAChD,GACJ,IACOy7B,CACX,ECSA,SAZA,SAAkB7F,EAAM4G,EAAI76B,QACR,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAI86B,EAAe7E,GAAShC,GACxB8G,EAAe9E,GAAS4E,GACxBG,EAAOh3B,GAAiB+2B,EAAa,GAAKD,EAAa,IACvDG,EAAOj3B,GAAiB+2B,EAAa,GAAKD,EAAa,IACvDI,EAAOl3B,GAAiB82B,EAAa,IACrCK,EAAOn3B,GAAiB+2B,EAAa,IACrCxyB,EAAIjL,KAAKqG,IAAIrG,KAAKW,IAAI+8B,EAAO,GAAI,GACjC19B,KAAKqG,IAAIrG,KAAKW,IAAIg9B,EAAO,GAAI,GAAK39B,KAAKotB,IAAIwQ,GAAQ59B,KAAKotB,IAAIyQ,GAChE,OAAOj6B,GAAgB,EAAI5D,KAAKgtB,MAAMhtB,KAAK8N,KAAK7C,GAAIjL,KAAK8N,KAAK,EAAI7C,IAAKvI,EAAQoB,MACnF,ECXe,SAAS0C,GAAQsM,EAAO8G,EAAKlX,GAGxC,QAFgB,IAAZA,IAAsBA,EAAU,CAAC,IAEf,IAAlBA,EAAQo7B,MACR,OAqBR,SAA+BhrB,EAAO8G,GAElC,IAAImkB,EAAOv3B,GAAQoT,EAAK9G,GAExB,OADAirB,GAAQA,EAAO,KAAO,GAE1B,CA1BeC,CAAsBlrB,EAAO8G,GAExC,IAAI4jB,EAAe7E,GAAS7lB,GACxB2qB,EAAe9E,GAAS/e,GACxBqkB,EAAOv3B,GAAiB82B,EAAa,IACrCU,EAAOx3B,GAAiB+2B,EAAa,IACrCG,EAAOl3B,GAAiB82B,EAAa,IACrCK,EAAOn3B,GAAiB+2B,EAAa,IACrCxyB,EAAIjL,KAAKW,IAAIu9B,EAAOD,GAAQj+B,KAAKotB,IAAIyQ,GACrC3yB,EAAIlL,KAAKotB,IAAIwQ,GAAQ59B,KAAKW,IAAIk9B,GAC9B79B,KAAKW,IAAIi9B,GAAQ59B,KAAKotB,IAAIyQ,GAAQ79B,KAAKotB,IAAI8Q,EAAOD,GACtD,OAAO95B,GAAiBnE,KAAKgtB,MAAM/hB,EAAGC,GAC1C,CCZe,SAASizB,GAAYC,EAAQl6B,EAAUsC,EAAS9D,QAC3C,IAAZA,IAAsBA,EAAU,CAAC,GAErC,IAAI86B,EAAe7E,GAASyF,GACxBC,EAAa33B,GAAiB82B,EAAa,IAC3Cc,EAAY53B,GAAiB82B,EAAa,IAC1Ce,EAAa73B,GAAiBF,GAC9B3C,EAAUI,GAAgBC,EAAUxB,EAAQoB,OAE5C06B,EAAYx+B,KAAKy+B,KAAKz+B,KAAKW,IAAI29B,GAAat+B,KAAKotB,IAAIvpB,GACrD7D,KAAKotB,IAAIkR,GAAat+B,KAAKW,IAAIkD,GAAW7D,KAAKotB,IAAImR,IAKvD,OAAO,GAAM,CAFHp6B,GAFOk6B,EACbr+B,KAAKgtB,MAAMhtB,KAAKW,IAAI49B,GAAcv+B,KAAKW,IAAIkD,GAAW7D,KAAKotB,IAAIkR,GAAYt+B,KAAKotB,IAAIvpB,GAAW7D,KAAKW,IAAI29B,GAAat+B,KAAKW,IAAI69B,KAExHr6B,GAAiBq6B,IACF97B,EAAQnB,WACrC,CCyCA,SAtDA,SAA4Bm6B,EAAO3C,EAAIr2B,QACnB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIg8B,EAAY,GAAM,CAACr8B,IAAUA,KAAW,CACxCuqB,KAAMvqB,MAENtC,EAAS,EA+Cb,OA9CAmJ,GAAYwyB,GAAO,SAAUhN,GAEzB,IADA,IAAI7uB,EAAS+4B,GAAUlK,GACdvuB,EAAI,EAAGA,EAAIN,EAAOE,OAAS,EAAGI,IAAK,CAExC,IAAI2S,EAAQ,GAAMjT,EAAOM,IACzB2S,EAAMvR,WAAWqrB,KAAO,GAASmM,EAAIjmB,EAAOpQ,GAE5C,IAAIi8B,EAAS,GAAM9+B,EAAOM,EAAI,IAC9Bw+B,EAAOp9B,WAAWqrB,KAAO,GAASmM,EAAI4F,EAAQj8B,GAE9C,IAAIk8B,EAAgB,GAAS9rB,EAAO6rB,EAAQj8B,GAExCm8B,EAAiB7+B,KAAK+N,IAAI+E,EAAMvR,WAAWqrB,KAAM+R,EAAOp9B,WAAWqrB,MACnE8J,EAAYlwB,GAAQsM,EAAO6rB,GAC3BG,EAAmBX,GAAYpF,EAAI8F,EAAgBnI,EAAY,GAAIh0B,GACnEq8B,EAAmBZ,GAAYpF,EAAI8F,EAAgBnI,EAAY,GAAIh0B,GACnE04B,EAAY,GAAe,GAAW,CACtC0D,EAAiB/9B,SAASE,YAC1B89B,EAAiBh+B,SAASE,cAC1B,GAAW,CAAC6R,EAAM/R,SAASE,YAAa09B,EAAO59B,SAASE,eACxD+9B,EAAc,KACd5D,EAAU95B,SAASvB,OAAS,KAC5Bi/B,EAAc5D,EAAU95B,SAAS,IACrBC,WAAWqrB,KAAO,GAASmM,EAAIiG,EAAat8B,GACxDs8B,EAAYz9B,WAAW09B,SACnBl/B,EAAS,GAAS+S,EAAOksB,EAAat8B,IAE1CoQ,EAAMvR,WAAWqrB,KAAO8R,EAAUn9B,WAAWqrB,QAC7C8R,EAAY5rB,GACFvR,WAAWmuB,MAAQvvB,EAC7Bu+B,EAAUn9B,WAAW09B,SAAWl/B,GAEhC4+B,EAAOp9B,WAAWqrB,KAAO8R,EAAUn9B,WAAWqrB,QAC9C8R,EAAYC,GACFp9B,WAAWmuB,MAAQvvB,EAAI,EACjCu+B,EAAUn9B,WAAW09B,SAAWl/B,EAAS6+B,GAEzCI,GACAA,EAAYz9B,WAAWqrB,KAAO8R,EAAUn9B,WAAWqrB,QACnD8R,EAAYM,GACFz9B,WAAWmuB,MAAQvvB,GAGjCJ,GAAU6+B,CACd,CACJ,IACOF,CACX,EC9CA,SAASQ,GAAa/8B,GAClB,IAAIg9B,EAAS,CAAEn+B,KAAM,WAerB,OAbAsD,OAAO6G,KAAKhJ,GAASkF,SAAQ,SAAUuE,GACnC,OAAQA,GACJ,IAAK,OACL,IAAK,aACL,IAAK,WACD,OACJ,QACIuzB,EAAOvzB,GAAOzJ,EAAQyJ,GAElC,IAEAuzB,EAAO59B,WAAa69B,GAAgBj9B,EAAQZ,YAC5C49B,EAAOp+B,SAAWs+B,GAAcl9B,EAAQpB,UACjCo+B,CACX,CAQA,SAASC,GAAgB79B,GACrB,IAAI49B,EAAS,CAAC,EACd,OAAK59B,GAGL+C,OAAO6G,KAAK5J,GAAY8F,SAAQ,SAAUuE,GACtC,IAAIpH,EAAQjD,EAAWqK,GACF,iBAAVpH,EACO,OAAVA,EAEA26B,EAAOvzB,GAAO,KAET7I,MAAMC,QAAQwB,GAEnB26B,EAAOvzB,GAAOpH,EAAMsB,KAAI,SAAUw5B,GAC9B,OAAOA,CACX,IAIAH,EAAOvzB,GAAOwzB,GAAgB56B,GAIlC26B,EAAOvzB,GAAOpH,CAEtB,IACO26B,GAxBIA,CAyBf,CAiCA,SAASE,GAAct+B,GACnB,IAAI0B,EAAO,CAAEzB,KAAMD,EAASC,MAI5B,OAHID,EAASmB,OACTO,EAAKP,KAAOnB,EAASmB,MAEH,uBAAlBnB,EAASC,MACTyB,EAAKvB,WAAaH,EAASG,WAAW4E,KAAI,SAAU+C,GAChD,OAAOw2B,GAAcx2B,EACzB,IACOpG,IAEXA,EAAKxB,YAAcs+B,GAAUx+B,EAASE,aAC/BwB,EACX,CAQA,SAAS88B,GAAU1/B,GACf,IAAIs/B,EAASt/B,EACb,MAAyB,iBAAds/B,EAAO,GACPA,EAAOlwB,QAEXkwB,EAAOr5B,KAAI,SAAUvD,GACxB,OAAOg9B,GAAUh9B,EACrB,GACJ,CACA,SAhJA,SAAeJ,GACX,IAAKA,EACD,MAAM,IAAIW,MAAM,uBAEpB,OAAQX,EAAQnB,MACZ,IAAK,UACD,OAAOk+B,GAAa/8B,GACxB,IAAK,oBACD,OAiFZ,SAAgCA,GAC5B,IAAIg9B,EAAS,CAAEn+B,KAAM,qBAerB,OAbAsD,OAAO6G,KAAKhJ,GAASkF,SAAQ,SAAUuE,GACnC,OAAQA,GACJ,IAAK,OACL,IAAK,WACD,OACJ,QACIuzB,EAAOvzB,GAAOzJ,EAAQyJ,GAElC,IAEAuzB,EAAO79B,SAAWa,EAAQb,SAASwE,KAAI,SAAUtD,GAC7C,OAAO08B,GAAa18B,EACxB,IACO28B,CACX,CAlGmBK,CAAuBr9B,GAClC,IAAK,QACL,IAAK,aACL,IAAK,UACL,IAAK,aACL,IAAK,kBACL,IAAK,eACL,IAAK,qBACD,OAAOk9B,GAAcl9B,GACzB,QACI,MAAM,IAAIW,MAAM,wBAE5B,ECgBA,SArBA,SAAsB28B,EAAa55B,GAE/B,IAAK45B,EACD,MAAM,IAAI38B,MAAM,2BACpB,IAAK+C,EACD,MAAM,IAAI/C,MAAM,sBACpB,IAAI48B,EACAC,EAAUt9B,IACVu9B,EAAmB,EAWvB,OAVAj3B,GAAY9C,GAAQ,SAAUkzB,EAAI1wB,GAC9B,IAAIw3B,EAAkB,GAASJ,EAAa1G,GACxC8G,EAAkBF,IAClBC,EAAmBv3B,EACnBs3B,EAAUE,EAElB,KACAH,EAAU,GAAM75B,EAAOvE,SAASs+B,KACxBr+B,WAAW8G,aAAeu3B,EAClCF,EAAQn+B,WAAWs+B,gBAAkBF,EAC9BD,CACX,ECjBA,SARA,SAAkBI,EAAQC,GAKxB,OAFe5B,GAAY2B,EAFhB,GAASA,EAAQC,GAEc,EAD5Bv5B,GAAQs5B,EAAQC,GAIhC,E,ogCCzBA,IAAQlrB,GAAiB2jB,GAAWC,UAA5B5jB,aAgBKmrB,GAAM,CACjBC,eAAgB,iBAChBC,iBAAkB,oBAGPC,GAAqB,SAChCr6B,EACAs6B,EACAn/B,EACAo/B,GAEA,IAAAC,EAAgCx6B,EAAIy6B,YAArBC,EAACF,EAARzM,MAAkBvmB,EAACgzB,EAAT1xB,OAElB6xB,EAAiB36B,EAAI46B,QAAQz/B,GAArBmN,EAACqyB,EAADryB,EAAGoJ,EAACipB,EAADjpB,GACgBpJ,EAAI,GAAKA,EAAIoyB,GAAKhpB,EAAI,GAAKA,EAAIlK,GAIhC+yB,IACxBD,EAASr2B,KAAK9I,EAElB,EAEa0/B,GAAiB,SAAC76B,EAAK86B,EAAMx2B,GAExC,IAAM9I,EAAWs/B,EAAK/c,SAASviB,SACzBu/B,EAAW,GAGXC,EAAiB,WACrB,IAAMC,EAASj7B,EAAIy6B,YACjBC,EAAIO,EAAOlN,MACXvmB,EAAIyzB,EAAOnyB,OAEXoyB,GADMl7B,EAAIm7B,UAAU,CAAC,EAAG,IAAIC,UACtBp7B,EAAIm7B,UAAU,CAACT,EAAG,IAAIU,WACtBp7B,EAAIm7B,UAAU,CAACT,EAAGlzB,IAAI4zB,UAG9B,OCvCW,SAAqBh/B,EAAMQ,QACtB,IAAZA,IAAsBA,EAAU,CAAC,GAIrC,IAAIy+B,EAAOC,OAAOl/B,EAAK,IACnBm/B,EAAQD,OAAOl/B,EAAK,IACpBo/B,EAAOF,OAAOl/B,EAAK,IACnBq/B,EAAQH,OAAOl/B,EAAK,IACxB,GAAoB,IAAhBA,EAAKnC,OACL,MAAM,IAAI+C,MAAM,6DAEpB,IAAI0+B,EAAU,CAACL,EAAME,GAIrB,OAAO,GAAQ,CAAC,CAACG,EADF,CAACF,EAAMD,GADP,CAACC,EAAMC,GADR,CAACJ,EAAMI,GAGkCC,IAAW9+B,EAAQnB,WAAY,CAAEW,KAAMA,EAAMU,GAAIF,EAAQE,IACpH,CDsBW6+B,CAAY,CAFX37B,EAAIm7B,UAAU,CAAC,EAAG3zB,IAAI4zB,UAELF,GAAKvQ,OAChC,CAVuB,GAYjB2P,EAAW,GAGXsB,EAAwB,SAACzgC,GAA0C,IAA7B0gC,EAAgB/lB,UAAA7b,OAAA,QAAAkJ,IAAA2S,UAAA,IAAAA,UAAA,GAC1D,IAAK7Y,MAAMC,QAAQ/B,GAAc,MAAM6B,MAAM,8BAEzCC,MAAMC,QAAQ/B,EAAY,IAE5BA,EAAYoG,SAAQ,SAAC9E,GACnBm/B,EAAsBn/B,EACxB,IAG2B,IAAvBtB,EAAYlB,QACdogC,GAAmBr6B,EAAKs6B,EAAUn/B,EAAa0gC,EAGrD,EAiCA,OA/BArgC,EAAS+F,SAAQ,SAAC7E,GAEZA,EAAQI,KAAOwH,EAAexH,GAgBhCJ,EAAQI,KAAOo9B,GAAIE,kBACnB19B,EAAQI,KAAOo9B,GAAIC,iBAIrByB,EAAsBl/B,EAAQzB,SAASE,aAGlC2gC,GAAgBd,EAAet+B,IAClCq+B,EAAS92B,KAAKvH,IAxBV4H,EAAepJ,OAAS6T,GAAaH,SAIvCgtB,EACEl/B,EAAQzB,SAASE,YAAY,GAAGgO,MAAM,GAAI,IAC1C,EAoBR,IAEO,CAAC4xB,EAAUT,EACpB,EAoHA,SAASyB,GAA2B77B,EAAa87B,GAC/C,IAAMC,EAA6B/7B,EAAYF,KAAI,SAACnD,GAAI,MAAM,CAC5DH,QAASG,EACTE,MAAOm/B,GAAmBr/B,EAAMm/B,GACjC,IAMD,OAJAC,EAA2B9xB,MACzB,SAAChF,EAAGC,GAAC,OAAKD,EAAEpI,MAAMtB,WAAWqrB,KAAO1hB,EAAErI,MAAMtB,WAAWqrB,IAAI,IAGtD,CACLpqB,QAASu/B,EAA2B,GAAGv/B,QACvCK,MAAOk/B,EAA2B,GAAGl/B,MAEzC,CAEA,IAAMo/B,GAAmB,SAAChP,EAAQra,GAChC,IAAIspB,EAAe,CAAC,EAmBpB,OAhBAtpB,EAAOvR,SAAQ,SAAC86B,EAAOzS,GAErB,IAAMiK,EAjHiB,SAAC1G,EAAQkP,GAElC,IA2CIC,EA3CEN,EAAI,CAAC7O,EAAOjX,IAAKiX,EAAOtX,KAGxB0mB,EAAmC,UAAxBF,EAAMphC,SAASC,KAE1BshC,EAAoC,YAAxBH,EAAMphC,SAASC,KAE3BuhC,EAAyC,iBAAxBJ,EAAMphC,SAASC,KAEhCwhC,EAAuC,eAAxBL,EAAMphC,SAASC,KAEhC06B,OAAQzyB,EAGNw5B,EAAU7J,GAAUuJ,GAE1B,GAAIE,EAAU,CACZ,IAAAK,EAAAC,GAAmBF,EAAO,GAE1B,MAAO,CACLG,OAAQ,CAAE5mB,IAHF0mB,EAAA,GAGO/mB,IAHF+mB,EAAA,IAIbx+B,SAAUA,GAASu+B,EAASX,GAEhC,CAEA,GAAIU,EAAc,CAChB,IAAMK,EAAKC,GACThB,EACAv+B,GAAkBk/B,EAAQ38B,KAAI,SAACsI,GAAC,OAAK20B,GAAU30B,EAAE,MAE7CO,EAAIk0B,EAAG9hC,SAASE,YACtB,MAAO,CACL2hC,OAAQ,CAAE5mB,IAAKrN,EAAE,GAAIgN,IAAKhN,EAAE,IAC5BzK,SAAU2+B,EAAGthC,WAAWs+B,gBAE5B,CASA,GANEnE,EADE4G,GAAaC,EACP/G,GAAc2G,GAEdA,EAING,EAAW,CACb,IASMU,EAAiBnB,GARK,eAAxBnG,EAAM36B,SAASC,KACH,CAACiiC,GAAevH,EAAM36B,SAASE,cAE/By6B,EAAM36B,SAASE,YAAY6E,KAAI,SAACjG,GAAM,OAClDojC,GAAepjC,EAAO,IAIqCiiC,GAC/DpG,EAAQsH,EAAexgC,QACvB4/B,EAAeY,EAAengC,KAChC,MAAO,GAAI0/B,EAAgB,CACzB,IAWMS,EAAiBnB,GAXHnG,EAAMp6B,SACvBwE,KAAI,SAACnD,GACJ,MAA2B,eAAvBA,EAAK5B,SAASC,KACT,CAAC2B,EAAK5B,SAASE,aAEf0B,EAAK5B,SAASE,WAEzB,IACCiiC,SAAQ,SAACrjC,GAAM,OAAKA,CAAM,IAC1BiG,KAAI,SAACjG,GAAM,OAAKojC,GAAepjC,EAAO,IAEsBiiC,GAC/DpG,EAAQsH,EAAexgC,QACvB4/B,EAAeY,EAAengC,KAChC,MACEu/B,EAAeJ,GAAmBtG,EAAOoG,GAG3C,IAAAqB,EAAAR,GAAmBP,EAAarhC,SAASE,YAAW,GAA7C+a,EAAGmnB,EAAA,GAAExnB,EAAGwnB,EAAA,GAEX/5B,EAAeg5B,EAAa7gC,WAAWmuB,MAG3C,OAFItmB,EAAe,IAAMsyB,EAAM36B,SAASE,YAAYlB,QAAQqJ,IAErD,CACLw5B,OAAQ,CAAE5mB,IAAAA,EAAKL,IAAAA,GACfye,QAASsB,EAAM36B,SAASE,YAAYgO,MAAM7F,EAAcA,EAAe,GACvElF,SAAUk+B,EAAa7gC,WAAWqrB,KAClCyV,SAAAA,EAEJ,CAwBoBe,CAAmBnQ,EAAQkP,SAIfl5B,IAA1Bi5B,EAAah+B,UACby1B,EAAQz1B,SAAWg+B,EAAah+B,aAEhCg+B,EAAevI,GACFwI,MAAQA,EAEzB,IAIOD,CACT,EA8FA,IAAMmB,GAAyB,SAC7BnB,EACAoB,EACArQ,GAGA,OADuBlwB,MAAMC,QAAQk/B,EAAa9H,SATpD,SAAqB8H,GACnB,OAAOA,EAAaU,MACtB,CASWW,CAAYrB,GAxFvB,SACEA,EACAoB,EACArQ,GAEA,IAAAuQ,EAMIF,QAAAA,EAAe,CAAC,EAACG,EAAAD,EALnBE,gBAAAA,OAAe,IAAAD,GAAQA,EAAAE,EAAAH,EACvBI,YAAAA,OAAW,IAAAD,GAAOA,EAAAE,EAAAL,EAClBM,gBAAAA,OAAe,IAAAD,GAAOA,EAAAE,EAAAP,EACtBQ,YAAAA,OAAW,IAAAD,GAAOA,EAAAE,EAAAT,EAClBU,2BAAAA,OAA0B,IAAAD,EAAG,KAAIA,EAE7BljC,EAAWmhC,EAAaC,MAAMphC,SAG9BojC,EAAIjC,EAAa9H,QAAQ,GACzBgK,EAAIlC,EAAa9H,QAAQ,GAIzBiK,EAAI,CAACnC,EAAaU,OAAO5mB,IAAKkmB,EAAaU,OAAOjnB,KAGlD2oB,EAAapgC,GAASigC,EAAGE,GACzBE,EAAargC,GAASkgC,EAAGC,GAG3BG,EAAsBF,EAAaC,EAAaJ,EAAIC,EAGpDK,EAAmBH,EAAaC,EAAaD,EAAaC,EAE1DG,GAAgB,EACpB,GAAIhB,EAAiB,CACnB,IAAM3zB,EAAIqf,GAAS+U,EAAGC,GAAGrjC,SAASE,YAC5B0jC,EAAazgC,GAAS6L,EAAGs0B,GAE3BM,EAAaL,GAAcK,EAAaJ,IAE1CC,EAAsBz0B,EACtB00B,EAAmBE,EACnBD,GAAgB,EAEpB,CAGA,IAUIE,EAVEC,EAAmBX,EAKnBY,GAF8B,eAAlB/jC,EAASC,KAAwB,CAACD,EAASE,YAAY,GAAIF,EAASE,YAAYF,EAASE,YAAYlB,OAAS,IAAM,IAEzGglC,MAAK,SAACliC,GACjC,OAAOA,EAAM,KAAO2hC,EAAoB,IAAM3hC,EAAM,KAAO2hC,EAAoB,EACjF,IASEI,EADEH,GAAoBI,EACTb,EAAcK,EAAIpR,EAIHyR,GAAkBd,KAC3CE,GAAoBgB,IACpBhB,EACwCU,EAATvR,EAIpC,IAA6B+R,EAAArC,GAAViC,EAAU,GAC7B,MAAO,CAAE5oB,IADCgpB,EAAA,GACIrpB,IADCqpB,EAAA,GAEjB,CAeWC,CACL/C,EACAoB,EACArQ,EAGN,EAYaiS,GAAO,SAACjkB,EAAO5T,GAC1B,IAgBI60B,EAAciD,EAAaC,EAvIAC,EAAUC,EAEnCC,EA+JFC,EAAYC,EA3TSrF,EAAUvgC,EAC7B6lC,EACAC,EA+QF3pB,EAAM3O,EAAE4lB,OAAOjX,IACfL,EAAMtO,EAAE4lB,OAAOtX,IAGnB,GAAItO,EAAE6Y,cAAc0f,OAIlB,OAHA3kB,EAAM4kB,sBAAuB,EAC7B5kB,EAAM6kB,wBAAyB,EAExB,CAAE9pB,IAAAA,EAAKL,IAAAA,GAGhB,GAAIsF,EAAM4f,SAAS9gC,QAAU,EAC3B,MAAO,CAAEic,IAAAA,EAAKL,IAAAA,GAKhB,GAAIsF,EAAMve,QAAQwiC,KAAM,CAItB,GAHAhD,EAAeD,GAAiB,CAAEjmB,IAAAA,EAAKL,IAAAA,GAAOsF,EAAM4f,UAGX,IAArCv8B,OAAO6G,KAAK+2B,GAAcniC,OAC5B,OAAO,EAYPqlC,EATelD,EAAaG,SASfH,EAAaU,OAPbS,GACXnB,EACAjhB,EAAMve,QAAQ4gC,YACd,CAAEtnB,EAAKL,IAOXwpB,GACIlkB,EAAMve,QAAQ4gC,aAAeriB,EAAMve,QAAQ4gC,YAAYyC,QAAW,KA7JzCV,EA8JZD,EAAWzpB,IA9JW2pB,EA8JNrkB,EAAMnb,IAAIkgC,UA5JvCT,EAAkBF,GAAYrlC,KAAKc,GAAK,KADnB,SAGHd,KAAKotB,IAAImY,GAC/BvlC,KAAKqG,IAAI,EAAGi/B,EAAY,GA0J1B,CAGA,GAAIrkB,EAAMve,QAAQujC,OAAQ,CACxB,IAAMC,GA7TiB9F,EA6TmBnf,EAAMmf,SA7TfvgC,EA6TyBwN,EAAE4lB,OA5TxDyS,EAAY,GACZC,EAAc,GAEpBvF,EAAS/4B,SAAQ,SAAC4nB,GAChByW,EAAU37B,KAAKklB,EAAO,IACtB0W,EAAY57B,KAAKklB,EAAO,GAC1B,IAUO,CACLuW,WAT0BE,EAAUX,MACpC,SAACoB,GAAE,OAAKnmC,KAAKC,IAAIkmC,EAAKtmC,EAAOmc,KAAO,IAAK,IASzCypB,aAN4BE,EAAYZ,MACxC,SAACqB,GAAE,OAAKpmC,KAAKC,IAAImmC,EAAKvmC,EAAO8b,KAAO,IAAK,MAoTzC,GAFA8pB,EAAeS,EAAgBT,aAD/BD,EAAaU,EAAgBV,WAGb,CAGd,IAAMa,EAAY,CAAErqB,IAAKwpB,EAAY7pB,IAAKtO,EAAE4lB,OAAOtX,IAAM,IACnD2qB,EAAe,CAAEtqB,IAAKwpB,EAAY7pB,IAAKtO,EAAE4lB,OAAOtX,IAAM,IAE5DsF,EAAMslB,cAAc/qB,iBAAiB,EAAG6qB,EAAUrqB,IAAKqqB,EAAU1qB,KACjEsF,EAAMslB,cAAc/qB,iBAClB,EACA8qB,EAAatqB,IACbsqB,EAAa3qB,IAEjB,CAEA,GAAI8pB,EAAc,CAGhB,IAAMY,EAAY,CAAErqB,IAAK3O,EAAE4lB,OAAOjX,IAAM,GAAIL,IAAK8pB,GAC3Ca,EAAe,CAAEtqB,IAAK3O,EAAE4lB,OAAOjX,IAAM,GAAIL,IAAK8pB,GAEpDxkB,EAAMulB,gBAAgBhrB,iBAAiB,EAAG6qB,EAAUrqB,IAAKqqB,EAAU1qB,KACnEsF,EAAMulB,gBAAgBhrB,iBACpB,EACA8qB,EAAatqB,IACbsqB,EAAa3qB,IAEjB,CAEAsF,EAAM4kB,uBAAyBL,EAC/BvkB,EAAM6kB,yBAA2BL,CACnC,CAEA,OAAIvD,GAAwC,IAAxBA,EAAah+B,SAAkBihC,EAC1CC,EACEI,GAAcC,GACnBD,IACFxpB,EAAMwpB,GAEJC,IACF9pB,EAAM8pB,GAED,CAAEzpB,IAAAA,EAAKL,IAAAA,IAEP,CAAEK,IAAAA,EAAKL,IAAAA,EAElB,EAEa8qB,GAAkB,SAAC7jC,GAAE,MAAM,CACtCA,GAAAA,EACA5B,KAAM6T,GAAaC,QACnBvT,WAAY,CACVmlC,YAAa,QAEf3lC,SAAU,CACRC,KAAM6T,GAAaE,YACnB9T,YAAa,IAEhB,EAEY0lC,GAAkB,SAAC1lB,EAAO9e,GACrC,QACEA,EAAQZ,WAAWqB,KAAOo9B,GAAIC,gBAC5Bhf,EAAMve,QAAQujC,QAAWhlB,EAAM4kB,yBAMjC1jC,EAAQZ,WAAWqB,KAAOo9B,GAAIE,kBAC5Bjf,EAAMve,QAAQujC,QAAWhlB,EAAM6kB,uBAMrC,E,i4DEpfA,IAAQhW,GAAoB0I,GAAWE,IAA/B5I,gBACFkG,GAAYwC,GAAW7S,MAAMqR,WACnC4P,GAAkCpO,GAAWC,UAArC5jB,GAAY+xB,GAAZ/xB,aAAcT,GAAOwyB,GAAPxyB,QAEhByyB,G,kWAAaC,CAAA,GAAQ9Q,IAE3B6Q,GAAcnnB,QAAU,SAAUhd,GAAS,IAAAqkC,EAAA,KACnClkC,EAAQnD,KAAK6f,WAAW,CAC5Bve,KAAM6T,GAAaC,QACnBvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM6T,GAAaD,MACnB3T,YAAa,CAAC,OAIZslC,EAAgB7mC,KAAK6f,WAAWknB,GAAgBzG,GAAIC,iBACpDuG,EAAkB9mC,KAAK6f,WAC3BknB,GAAgBzG,GAAIE,mBAGtBxgC,KAAK6e,WAAW1b,GAChBnD,KAAK6e,WAAWgoB,GAChB7mC,KAAK6e,WAAWioB,GAEhB,IAAMpU,EAAmB1yB,KAAKqe,cAC9Bre,KAAK8e,wBACLsR,GAAgBzL,QAAQ3kB,MAExB,IAA2EsnC,EAAArE,GAA9ChC,GAAejhC,KAAKoG,IAAKpG,KAAKge,KAAKia,IAAK90B,GAAM,GAApEg+B,EAAQmG,EAAA,GAAE5G,EAAQ4G,EAAA,GAEnB/lB,EAAQ,CACZnb,IAAKpG,KAAKoG,IACVjD,MAAAA,EACAu9B,SAAAA,EACAS,SAAAA,EACAzO,iBAAAA,EACAmU,cAAAA,EACAC,gBAAAA,GAGFvlB,EAAMve,QAAUhD,KAAKge,KAAKhb,QAE1B,IAAMukC,EAAiB,WACrB,IAA2EC,EAAAvE,GAA9ChC,GAAeoG,EAAKjhC,IAAKihC,EAAKrpB,KAAKia,IAAK90B,GAAM,GAApEg+B,EAAQqG,EAAA,GAAE9G,EAAQ8G,EAAA,GACzBjmB,EAAMmf,SAAWA,EACjBnf,EAAM4f,SAAWA,CACnB,EAEA5f,EAAsB,eAAIgmB,EAE1B,IAAME,EAAyB,SAACzkC,GAC9Bue,EAAMve,QAAUA,CAClB,EAQA,OANAue,EAA8B,uBAAIkmB,EAElCznC,KAAKoG,IAAIkM,GAAG,UAAWi1B,GACvBvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bi1B,GACzCvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bm1B,GAElClmB,CACT,EAEA4lB,GAAcjnB,QAAU,SAAUqB,GAEhC+U,GAAUpW,QAAQjU,KAAKjM,KAAMuhB,EAAO,CAClCgS,OAAQ,CACNjX,IAAKiF,EAAMmmB,WACXzrB,IAAKsF,EAAMomB,aAGjB,EAEAR,GAAchnB,YAAc,SAAUoB,EAAO5T,GAC3C,IAAAi6B,EAAqBpC,GAAKjkB,EAAO5T,GAAzB2O,EAAGsrB,EAAHtrB,IAAKL,EAAG2rB,EAAH3rB,IAEbsF,EAAMmmB,WAAaprB,EACnBiF,EAAMomB,WAAa1rB,EAGjBsF,EAAM4N,YACN5N,EAAM4N,WAAW,KAAO7S,GACxBiF,EAAM4N,WAAW,KAAOlT,EAExBjc,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQI,UAStC9U,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQC,KAE1C,EAGAwyB,GAAclmB,kBAAoB,SAAUM,EAAO9e,EAAS8xB,GACtD0S,GAAgB1lB,EAAO9e,IAG3B6zB,GAAUrV,kBAAkBM,EAAO9e,EAAS8xB,EAC9C,EAGA4S,GAActmB,OAAS,SAAUU,GAC/BvhB,KAAK2e,cAAc2hB,GAAIC,eAAgB,CAAE5c,QAAQ,IACjD3jB,KAAK2e,cAAc2hB,GAAIE,iBAAkB,CAAE7c,QAAQ,IAGnD3jB,KAAKoG,IAAI8e,IAAI,UAAW3D,EAAMgmB,gBAE9BvnC,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMgmB,gBAGhDjR,GAAUzV,OAAO5U,KAAKjM,KAAMuhB,EAC9B,EAEA,Y,i4DCjIA,IAAA2lB,GAIIpO,GAAWC,UAHb5jB,GAAY+xB,GAAZ/xB,aACA8Q,GAAKihB,GAALjhB,MACAvR,GAAOwyB,GAAPxyB,QAEM0b,GAAoB0I,GAAWE,IAA/B5I,gBACFyX,GAAW/O,GAAW7S,MAAMuR,iBAW5BsQ,G,kWAAYV,CAAA,GAAQS,IAE1BC,GAAa9nB,QAAU,SAAUhd,GAAS,IAAAqkC,EAAA,KAClCrY,EAAOhvB,KAAK6f,WAAW,CAC3Bve,KAAM6T,GAAaC,QACnBvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM6T,GAAaE,YACnB9T,YAAa,CAAC,OAIZslC,EAAgB7mC,KAAK6f,WAAWknB,GAAgBzG,GAAIC,iBACpDuG,EAAkB9mC,KAAK6f,WAC3BknB,GAAgBzG,GAAIE,mBAGtBxgC,KAAK6e,WAAWmQ,GAChBhvB,KAAK6e,WAAWgoB,GAChB7mC,KAAK6e,WAAWioB,GAEhB,IAAMpU,EAAmB1yB,KAAKqe,cAC9Bre,KAAK8e,wBACLsR,GAAgBzL,QAAQ3kB,MAExB,IAA0EsnC,EAAArE,GAA7ChC,GAAejhC,KAAKoG,IAAKpG,KAAKge,KAAKia,IAAKjJ,GAAK,GAAnEmS,EAAQmG,EAAA,GAAE5G,EAAQ4G,EAAA,GAEnB/lB,EAAQ,CACZnb,IAAKpG,KAAKoG,IACV4oB,KAAAA,EACA0H,sBAAuB,EACvBgK,SAAAA,EACAS,SAAAA,EACAzO,iBAAAA,EACAmU,cAAAA,EACAC,gBAAAA,EACA9P,UAAW,WAGbzV,EAAMve,QAAUhD,KAAKge,KAAKhb,QAE1B,IAAMukC,EAAiB,WACrB,IAA0EC,EAAAvE,GAA7ChC,GAAeoG,EAAKjhC,IAAKihC,EAAKrpB,KAAKia,IAAKjJ,GAAK,GAAnEmS,EAAQqG,EAAA,GAAE9G,EAAQ8G,EAAA,GACzBjmB,EAAMmf,SAAWA,EACjBnf,EAAM4f,SAAWA,CACnB,EAEA5f,EAAsB,eAAIgmB,EAE1B,IAAME,EAAyB,SAACzkC,GAC9Bue,EAAMve,QAAUA,CAClB,EAQA,OANAue,EAA8B,uBAAIkmB,EAElCznC,KAAKoG,IAAIkM,GAAG,UAAWi1B,GACvBvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bi1B,GACzCvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bm1B,GAElClmB,CACT,EAEAumB,GAAa5nB,QAAU,SAAUqB,GAE/B,IAAMjF,EAAMiF,EAAMmmB,WACZzrB,EAAMsF,EAAMomB,WAIlB,GAAIpmB,EAAMmV,sBAAwB,EAAG,CACnC,IAAMvH,EAAa5N,EAAMyN,KAAKztB,YAAYggB,EAAMmV,sBAAwB,GAIxE,GAFAnV,EAAM4N,WAAaA,EAEfA,EAAW,KAAO7S,GAAO6S,EAAW,KAAOlT,EAC7C,OAAOjc,KAAKqf,WAAW4G,GAAMnQ,cAAe,CAC1CwD,WAAY,CAACiI,EAAMyN,KAAK9rB,KAG9B,CAIAu9B,GAAmBlf,EAAMnb,IAAKmb,EAAMmf,SAAU,CAAEpkB,IAAAA,EAAKL,IAAAA,IAErDsF,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuBpa,EAAKL,GAE9DsF,EAAMmV,wBAENnV,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuBpa,EAAKL,EAChE,EAEA6rB,GAAa3nB,YAAc,SAAUoB,EAAO5T,GAC1C,IAAAi6B,EAAqBpC,GAAKjkB,EAAO5T,GAAzB2O,EAAGsrB,EAAHtrB,IAAKL,EAAG2rB,EAAH3rB,IAEbsF,EAAMyN,KAAKlT,iBAAiByF,EAAMmV,sBAAuBpa,EAAKL,GAC9DsF,EAAMmmB,WAAaprB,EACnBiF,EAAMomB,WAAa1rB,EAGjBsF,EAAM4N,YACN5N,EAAM4N,WAAW,KAAO7S,GACxBiF,EAAM4N,WAAW,KAAOlT,EAExBjc,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQI,UAStC9U,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQC,KAE1C,EAGAmzB,GAAa7mB,kBAAoB,SAAUM,EAAO9e,EAAS8xB,GACrD0S,GAAgB1lB,EAAO9e,IAG3BolC,GAAS5mB,kBAAkBM,EAAO9e,EAAS8xB,EAC7C,EAGAuT,GAAajnB,OAAS,SAAUU,GAC9BvhB,KAAK2e,cAAc2hB,GAAIC,eAAgB,CAAE5c,QAAQ,IACjD3jB,KAAK2e,cAAc2hB,GAAIE,iBAAkB,CAAE7c,QAAQ,IAGnD3jB,KAAKoG,IAAI8e,IAAI,UAAW3D,EAAMgmB,gBAE9BvnC,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMgmB,gBAGhDM,GAAShnB,OAAO5U,KAAKjM,KAAMuhB,EAC7B,EAEA,Y,i4DC5JA,IAAA2lB,GAAyCpO,GAAWC,UAA5C5jB,GAAY+xB,GAAZ/xB,aAAc8Q,GAAKihB,GAALjhB,MAAOvR,GAAOwyB,GAAPxyB,QACrB0b,GAAoB0I,GAAWE,IAA/B5I,gBACFqG,GAAcqC,GAAW7S,MAAMsR,aAY/BwQ,G,kWAAeX,CAAA,GAAQ3Q,IAE7BsR,GAAgB/nB,QAAU,SAAUhd,GAAS,IAAAqkC,EAAA,KACrC7jC,EAAUxD,KAAK6f,WAAW,CAC9Bve,KAAM6T,GAAaC,QACnBvT,WAAY,CAAC,EACbR,SAAU,CACRC,KAAM6T,GAAaH,QACnBzT,YAAa,CAAC,OAIZslC,EAAgB7mC,KAAK6f,WAAWknB,GAAgBzG,GAAIC,iBACpDuG,EAAkB9mC,KAAK6f,WAC3BknB,GAAgBzG,GAAIE,mBAGtBxgC,KAAK6e,WAAWrb,GAChBxD,KAAK6e,WAAWgoB,GAChB7mC,KAAK6e,WAAWioB,GAEhB,IAAMpU,EAAmB1yB,KAAKqe,cAC9Bre,KAAK8e,wBACLsR,GAAgBzL,QAAQ3kB,MAExB,IAA6EsnC,EAAArE,GAAhDhC,GAAejhC,KAAKoG,IAAKpG,KAAKge,KAAKia,IAAKz0B,GAAQ,GAAtE29B,EAAQmG,EAAA,GAAE5G,EAAQ4G,EAAA,GAEnB/lB,EAAQ,CACZnb,IAAKpG,KAAKoG,IACV5C,QAAAA,EACAkzB,sBAAuB,EACvBgK,SAAAA,EACAS,SAAAA,EACAzO,iBAAAA,EACAmU,cAAAA,EACAC,gBAAAA,GAIFvlB,EAAMve,QAAU4B,OAAOkkB,OAAO9oB,KAAKge,KAAKhb,QAAS,CAC/CglC,SAAS,IAGX,IAAMT,EAAiB,WACrB,IAICC,EAAAvE,GAJ4BhC,GAC3BoG,EAAKjhC,IACLihC,EAAKrpB,KAAKia,IACVz0B,GACD,GAJM29B,EAAQqG,EAAA,GAAE9G,EAAQ8G,EAAA,GAKzBjmB,EAAMmf,SAAWA,EACjBnf,EAAM4f,SAAWA,CACnB,EAEA5f,EAAsB,eAAIgmB,EAE1B,IAAME,EAAyB,SAACzkC,GAC9Bue,EAAMve,QAAUA,CAClB,EASA,OANAue,EAA8B,uBAAIkmB,EAElCznC,KAAKoG,IAAIkM,GAAG,UAAWi1B,GACvBvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bi1B,GACzCvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bm1B,GAElClmB,CACT,EAEAwmB,GAAgB7nB,QAAU,SAAUqB,GAElC,IAAMjF,EAAMiF,EAAMmmB,WACZzrB,EAAMsF,EAAMomB,WAGlB,GAAIpmB,EAAMmV,sBAAwB,EAAG,CACnC,IAAMvH,EACJ5N,EAAM/d,QAAQjC,YAAY,GAAGggB,EAAMmV,sBAAwB,GAI7D,GAFAnV,EAAM4N,WAAaA,EAEfA,EAAW,KAAO7S,GAAO6S,EAAW,KAAOlT,EAC7C,OAAOjc,KAAKqf,WAAW4G,GAAMnQ,cAAe,CAC1CwD,WAAY,CAACiI,EAAM/d,QAAQN,KAGjC,CAIAu9B,GAAmBlf,EAAMnb,IAAKmb,EAAMmf,SAAU,CAAEpkB,IAAAA,EAAKL,IAAAA,IAErDsF,EAAM/d,QAAQsY,iBAAiB,KAADc,OAAM2E,EAAMmV,uBAAyBpa,EAAKL,GAExEsF,EAAMmV,wBAENnV,EAAM/d,QAAQsY,iBAAiB,KAADc,OAAM2E,EAAMmV,uBAAyBpa,EAAKL,EAC1E,EAEA8rB,GAAgB5nB,YAAc,SAAUoB,EAAO5T,GAC7C,IAAAi6B,EAAqBpC,GAAKjkB,EAAO5T,GAAzB2O,EAAGsrB,EAAHtrB,IAAKL,EAAG2rB,EAAH3rB,IAEbsF,EAAM/d,QAAQsY,iBAAiB,KAADc,OAAM2E,EAAMmV,uBAAyBpa,EAAKL,GACxEsF,EAAMmmB,WAAaprB,EACnBiF,EAAMomB,WAAa1rB,EAGjBsF,EAAM4N,YACN5N,EAAM4N,WAAW,KAAO7S,GACxBiF,EAAM4N,WAAW,KAAOlT,EAExBjc,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQI,UAStC9U,KAAKyf,gBAAgB,CAAEhG,MAAO/E,GAAQC,KAE1C,EAGAozB,GAAgB9mB,kBAAoB,SAAUM,EAAO9e,EAAS8xB,GACxD0S,GAAgB1lB,EAAO9e,IAG3Bg0B,GAAYxV,kBAAkBM,EAAO9e,EAAS8xB,EAChD,EAGAwT,GAAgBlnB,OAAS,SAAUU,GACjCvhB,KAAK2e,cAAc2hB,GAAIC,eAAgB,CAAE5c,QAAQ,IACjD3jB,KAAK2e,cAAc2hB,GAAIE,iBAAkB,CAAE7c,QAAQ,IAGnD3jB,KAAKoG,IAAI8e,IAAI,UAAW3D,EAAMgmB,gBAE9BvnC,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMgmB,gBAChDvnC,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMkmB,wBAEhD,IAAIQ,EAAc1mB,EAAM/d,QACxB,GAAI+d,EAAMve,QAAQglC,QAChBvR,GAAY5V,OAAO5U,KAAKjM,KAAMuhB,OADhC,CAMA,IAAI3f,EAAW5B,KAAKge,KAAKrL,MAAMwR,SAE/B,IACE,IAAI+jB,EAASD,EACbrmC,EAAS+F,SAAQ,SAAU7E,GACzB,GAAImlC,EAAY/kC,KAAOJ,EAAQI,GAAI,OAAO,EC1JjC,IAAqC25B,EAC5CC,GAD4CD,ED2JdqL,EC1J9BpL,GAAO,EACXtzB,GDyJyB1G,GCzJH,SAAUi6B,GAC5BvzB,GAAYqzB,GAAU,SAAUG,GAC5B,IAAa,IAATF,EACA,OAAO,EAEXA,GAAQ,GAAgBC,EAAS17B,SAAU27B,EAAS37B,SACxD,GACJ,IACOy7B,KDkJLoL,EAASC,KAAKC,WAAWF,EAAQplC,GACnC,IACAye,EAAM/d,QAAQjC,YACZ2mC,EAAO3mC,aAAe2mC,EAAO7mC,SAASE,WAC1C,CAAE,MAAO8mC,GAIP,OAFA5R,GAAY5V,OAAO5U,KAAKjM,KAAMuhB,QAC9BvhB,KAAK2e,cAAc,CAAC4C,EAAM/d,QAAQN,IAAK,CAAEygB,QAAQ,GAEnD,CAGA,IAAI2kB,EAAK/mB,EAAM/d,QAAQgZ,iBACvB+E,EAAM/d,QAAQgZ,iBAAmB,WAAO,EAExCia,GAAY5V,OAAO5U,KAAKjM,KAAMuhB,GAC9BA,EAAM/d,QAAQgZ,iBAAmB8rB,EAAG3qB,KAAK4D,EAAM/d,QA1B/C,CA2BF,EAEA,Y,i4DE7LA,IAAQ4sB,GAAoB0I,GAAWE,IAA/B5I,gBACF4E,GAAe8D,GAAW7S,MAAMoR,cAChCkR,GAAYzP,GAAWC,UACvByP,G,kWAAgBpB,CAAA,GAAQpS,IAE9BwT,GAAiBxoB,QAAU,SAAUpB,GAAM,IAAAyoB,EAAA,KACnC/9B,EAAYsV,EAAKtV,UACjBxG,EAAU9C,KAAKwe,WAAWlV,GAEhC,IAAKxG,EACH,MAAM,IAAIM,MAAM,4DAGlB,GAAIN,EAAQxB,OAASinC,GAAUpzB,aAAaD,MAC1C,MAAM,IAAIsI,UAAU,oDAGtB,IAA6E8pB,EAAArE,GAAhDhC,GAAejhC,KAAKoG,IAAKpG,KAAKge,KAAKia,IAAKn1B,GAAQ,GAAtEq+B,EAAQmG,EAAA,GAAE5G,EAAQ4G,EAAA,GAEnBT,EAAgB7mC,KAAK6f,WAAWknB,GAAgBzG,GAAIC,iBACpDuG,EAAkB9mC,KAAK6f,WAC3BknB,GAAgBzG,GAAIE,mBAGtBxgC,KAAK6e,WAAWgoB,GAChB7mC,KAAK6e,WAAWioB,GAEhB,IAAMvlB,EAAQ,CACZnb,IAAKpG,KAAKoG,IACVkD,UAAAA,EACAxG,QAAAA,EACAkvB,iBAAkBpT,EAAK0U,UAAY,KACnCjB,YAAY,EACZC,aAAa,EACb2C,mBAAoBrW,EAAKyU,UAAY,CAACzU,EAAKyU,WAAa,GACxDqN,SAAAA,EACAS,SAAAA,EACA0F,cAAAA,EACAC,gBAAAA,GAGFvlB,EAAMve,QAAUhD,KAAKge,KAAKhb,QAE1BhD,KAAKke,uBACHle,KAAKs1B,mBAAmBhsB,EAAWiY,EAAM0T,qBAE3Cj1B,KAAKie,YAAY3U,GACjB8mB,GAAgBzL,QAAQ3kB,MAExBA,KAAKif,mBAAmB,CACtB5L,OAAO,IAGT,IAAMk0B,EAAiB,WACrB,IAA6EC,EAAAvE,GAAhDhC,GAAeoG,EAAKjhC,IAAKihC,EAAKrpB,KAAKia,IAAKn1B,GAAQ,GAAtEq+B,EAAQqG,EAAA,GAAE9G,EAAQ8G,EAAA,GACzBjmB,EAAMmf,SAAWA,EACjBnf,EAAM4f,SAAWA,CACnB,EAEA5f,EAAsB,eAAIgmB,EAE1B,IAAME,EAAyB,SAACzkC,GAC9Bue,EAAMve,QAAUA,CAClB,EAOA,OAJAue,EAA8B,uBAAIkmB,EAClCznC,KAAKoG,IAAIkM,GAAG,4BAA6Bi1B,GACzCvnC,KAAKoG,IAAIkM,GAAG,4BAA6Bm1B,GAElClmB,CACT,EAEAinB,GAAiBvS,WAAa,SAAU1U,EAAO5T,EAAG2iB,GAChD,IAAAsX,EAAqBpC,GAAKjkB,EAAO5T,GAAzB2O,EAAGsrB,EAAHtrB,IAAKL,EAAG2rB,EAAH3rB,IAEbsF,EAAMze,QAAQgZ,iBAAiByF,EAAM0T,mBAAmB,GAAI3Y,EAAKL,EACnE,EAEAusB,GAAiB3nB,OAAS,SAAUU,GAClCvhB,KAAK2e,cAAc2hB,GAAIC,eAAgB,CAAE5c,QAAQ,IACjD3jB,KAAK2e,cAAc2hB,GAAIE,iBAAkB,CAAE7c,QAAQ,IAKnD3jB,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMgmB,gBAChDvnC,KAAKoG,IAAI8e,IAAI,4BAA6B3D,EAAMkmB,wBAGhDzS,GAAanU,OAAO5U,KAAKjM,KAAMuhB,EACjC,EAEA,Y,q8DC9FA,IAEMknB,GAFQ3P,GAAWE,IAAI0P,MAEOtiC,KAAI,SAAAuiC,GACtC,MAAwB,0BAApBA,EAAazlC,GACfkkC,GAAAA,GAAA,GACKuB,GAAY,IACfxvB,OAAQ,GAAFyD,OAAAgsB,GACDD,EAAaxvB,QAAM,CACtB,CAAC,KAAM,mBAAoB,YAK1BwvB,CACT,IAwBA,SAtByB,GAAH/rB,OAAAgsB,GACjBH,IAAqB,CACxB,CACEvlC,GAAI,QACJ5B,KAAM,OACN6X,OAAQ,CACN,MACA,CAAC,KAAM,QAAS,cAChB,CAAC,KAAM,mBAAoB,SAE7B0vB,OAAQ,CACN,WAAY,QACZ,YAAa,SAEfC,MAAO,CACL,aAAc,UACd,aAAc,EACd,iBAAkB,CAAC,EAAG,M","sources":["webpack://mapboxGlDrawSnapMode/webpack/universalModuleDefinition","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-area/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-normalize/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bbox/dist/js/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/helpers/dist/js/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/meta/dist/js/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/fast-deep-equal/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/rbush/rbush.min.js","webpack://mapboxGlDrawSnapMode/./node_modules/wgs84/index.js","webpack://mapboxGlDrawSnapMode/webpack/bootstrap","webpack://mapboxGlDrawSnapMode/webpack/runtime/define property getters","webpack://mapboxGlDrawSnapMode/webpack/runtime/hasOwnProperty shorthand","webpack://mapboxGlDrawSnapMode/webpack/runtime/make namespace object","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/constants.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/id.js","webpack://mapboxGlDrawSnapMode/./node_modules/nanoid/non-secure/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/render.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/store.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/ui.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/setup.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/events.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/point-geometry/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/options.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/api.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/helpers/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/invariant/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/meta/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-segment/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-intersect/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/polygon-to-line/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-disjoint/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/distance/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bearing/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/destination/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/nearest-point-on-line/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/clone/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/nearest-point/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/midpoint/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./src/utils/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bbox-polygon/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_point.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_line.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_polygon.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-intersects/dist/es/index.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_direct_select.js","webpack://mapboxGlDrawSnapMode/./src/utils/customDrawStyles.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mapboxGlDrawSnapMode\"] = factory();\n\telse\n\t\troot[\"mapboxGlDrawSnapMode\"] = factory();\n})(this, () => {\nreturn ","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","module.exports = normalize;\n\nvar types = {\n    Point: 'geometry',\n    MultiPoint: 'geometry',\n    LineString: 'geometry',\n    MultiLineString: 'geometry',\n    Polygon: 'geometry',\n    MultiPolygon: 'geometry',\n    GeometryCollection: 'geometry',\n    Feature: 'feature',\n    FeatureCollection: 'featurecollection'\n};\n\n/**\n * Normalize a GeoJSON feature into a FeatureCollection.\n *\n * @param {object} gj geojson data\n * @returns {object} normalized geojson data\n */\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nconst ModeHandler = function(mode, DrawContext) {\n\n  const handlers = {\n    drag: [],\n    click: [],\n    mousemove: [],\n    mousedown: [],\n    mouseup: [],\n    mouseout: [],\n    keydown: [],\n    keyup: [],\n    touchstart: [],\n    touchmove: [],\n    touchend: [],\n    tap: []\n  };\n\n  const ctx = {\n    on(event, selector, fn) {\n      if (handlers[event] === undefined) {\n        throw new Error(`Invalid event type: ${event}`);\n      }\n      handlers[event].push({\n        selector,\n        fn\n      });\n    },\n    render(id) {\n      DrawContext.store.featureChanged(id);\n    }\n  };\n\n  const delegate = function (eventName, event) {\n    const handles = handlers[eventName];\n    let iHandle = handles.length;\n    while (iHandle--) {\n      const handle = handles[iHandle];\n      if (handle.selector(event)) {\n        const skipRender = handle.fn.call(ctx, event);\n        if (!skipRender) {\n          DrawContext.store.render();\n        }\n        DrawContext.ui.updateMapClasses();\n\n        // ensure an event is only handled once\n        // we do this to let modes have multiple overlapping selectors\n        // and relay on order of oppertations to filter\n        break;\n      }\n    }\n  };\n\n  mode.start.call(ctx);\n\n  return {\n    render: mode.render,\n    stop() {\n      if (mode.stop) mode.stop();\n    },\n    trash() {\n      if (mode.trash) {\n        mode.trash();\n        DrawContext.store.render();\n      }\n    },\n    combineFeatures() {\n      if (mode.combineFeatures) {\n        mode.combineFeatures();\n      }\n    },\n    uncombineFeatures() {\n      if (mode.uncombineFeatures) {\n        mode.uncombineFeatures();\n      }\n    },\n    drag(event) {\n      delegate('drag', event);\n    },\n    click(event) {\n      delegate('click', event);\n    },\n    mousemove(event) {\n      delegate('mousemove', event);\n    },\n    mousedown(event) {\n      delegate('mousedown', event);\n    },\n    mouseup(event) {\n      delegate('mouseup', event);\n    },\n    mouseout(event) {\n      delegate('mouseout', event);\n    },\n    keydown(event) {\n      delegate('keydown', event);\n    },\n    keyup(event) {\n      delegate('keyup', event);\n    },\n    touchstart(event) {\n      delegate('touchstart', event);\n    },\n    touchmove(event) {\n      delegate('touchmove', event);\n    },\n    touchend(event) {\n      delegate('touchend', event);\n    },\n    tap(event) {\n      delegate('tap', event);\n    }\n  };\n};\n\nexport default ModeHandler;\n","export const classes = {\n  CANVAS: 'mapboxgl-canvas',\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_PROPERTIES: 'change_properties',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","import area from '@mapbox/geojson-area';\nimport * as Constants from '../constants.js';\n\nconst FEATURE_SORT_RANKS = {\n  Point: 0,\n  LineString: 1,\n  MultiLineString: 1,\n  Polygon: 2\n};\n\nfunction comparator(a, b) {\n  const score = FEATURE_SORT_RANKS[a.geometry.type] - FEATURE_SORT_RANKS[b.geometry.type];\n\n  if (score === 0 && a.geometry.type === Constants.geojsonTypes.POLYGON) {\n    return a.area - b.area;\n  }\n\n  return score;\n}\n\n// Sort in the order above, then sort polygons by area ascending.\nfunction sortFeatures(features) {\n  return features.map((feature) => {\n    if (feature.geometry.type === Constants.geojsonTypes.POLYGON) {\n      feature.area = area.geometry({\n        type: Constants.geojsonTypes.FEATURE,\n        property: {},\n        geometry: feature.geometry\n      });\n    }\n    return feature;\n  }).sort(comparator).map((feature) => {\n    delete feature.area;\n    return feature;\n  });\n}\n\nexport default sortFeatures;\n","/**\n * Returns a bounding box representing the event's location.\n *\n * @param {Event} mapEvent - Mapbox GL JS map event, with a point properties.\n * @return {Array<Array<number>>} Bounding box.\n */\nfunction mapEventToBoundingBox(mapEvent, buffer = 0) {\n  return [\n    [mapEvent.point.x - buffer, mapEvent.point.y - buffer],\n    [mapEvent.point.x + buffer, mapEvent.point.y + buffer]\n  ];\n}\n\nexport default mapEventToBoundingBox;\n","function StringSet(items) {\n  this._items = {};\n  this._nums = {};\n  this._length = items ? items.length : 0;\n  if (!items) return;\n  for (let i = 0, l = items.length; i < l; i++) {\n    this.add(items[i]);\n    if (items[i] === undefined) continue;\n    if (typeof items[i] === 'string') this._items[items[i]] = i;\n    else this._nums[items[i]] = i;\n\n  }\n}\n\nStringSet.prototype.add = function(x) {\n  if (this.has(x)) return this;\n  this._length++;\n  if (typeof x === 'string') this._items[x] = this._length;\n  else this._nums[x] = this._length;\n  return this;\n};\n\nStringSet.prototype.delete = function(x) {\n  if (this.has(x) === false) return this;\n  this._length--;\n  delete this._items[x];\n  delete this._nums[x];\n  return this;\n};\n\nStringSet.prototype.has = function(x) {\n  if (typeof x !== 'string' && typeof x !== 'number') return false;\n  return this._items[x] !== undefined || this._nums[x] !== undefined;\n};\n\nStringSet.prototype.values = function() {\n  const values = [];\n  Object.keys(this._items).forEach((k) => {\n    values.push({ k, v: this._items[k] });\n  });\n  Object.keys(this._nums).forEach((k) => {\n    values.push({ k: JSON.parse(k), v: this._nums[k] });\n  });\n\n  return values.sort((a, b) => a.v - b.v).map(a => a.k);\n};\n\nStringSet.prototype.clear = function() {\n  this._length = 0;\n  this._items = {};\n  this._nums = {};\n  return this;\n};\n\nexport default StringSet;\n","import sortFeatures from './sort_features.js';\nimport mapEventToBoundingBox from './map_event_to_bounding_box.js';\nimport * as Constants from '../constants.js';\nimport StringSet from './string_set.js';\n\nconst META_TYPES = [\n  Constants.meta.FEATURE,\n  Constants.meta.MIDPOINT,\n  Constants.meta.VERTEX\n];\n\n// Requires either event or bbox\nexport default {\n  click: featuresAtClick,\n  touch: featuresAtTouch\n};\n\nfunction featuresAtClick(event, bbox, ctx) {\n  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);\n}\n\nfunction featuresAtTouch(event, bbox, ctx) {\n  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);\n}\n\nfunction featuresAt(event, bbox, ctx, buffer) {\n  if (ctx.map === null) return [];\n\n  const box = (event) ? mapEventToBoundingBox(event, buffer) : bbox;\n\n  const queryParams = {};\n\n  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(s => s.id).filter(id => ctx.map.getLayer(id) != null);\n\n  const features = ctx.map.queryRenderedFeatures(box, queryParams)\n    .filter(feature => META_TYPES.indexOf(feature.properties.meta) !== -1);\n\n  const featureIds = new StringSet();\n  const uniqueFeatures = [];\n  features.forEach((feature) => {\n    const featureId = feature.properties.id;\n    if (featureIds.has(featureId)) return;\n    featureIds.add(featureId);\n    uniqueFeatures.push(feature);\n  });\n\n  return sortFeatures(uniqueFeatures);\n}\n","import featuresAt from './features_at.js';\nimport * as Constants from '../constants.js';\n\nexport default function getFeatureAtAndSetCursors(event, ctx) {\n  const features = featuresAt.click(event, null, ctx);\n  const classes = { mouse: Constants.cursors.NONE };\n\n  if (features[0]) {\n    classes.mouse = (features[0].properties.active === Constants.activeStates.ACTIVE) ?\n      Constants.cursors.MOVE : Constants.cursors.POINTER;\n    classes.feature = features[0].properties.meta;\n  }\n\n  if (ctx.events.currentModeName().indexOf('draw') !== -1) {\n    classes.mouse = Constants.cursors.ADD;\n  }\n\n  ctx.ui.queueMapClasses(classes);\n  ctx.ui.updateMapClasses();\n\n  return features[0];\n}\n","export default function(a, b) {\n  const x = a.x - b.x;\n  const y = a.y - b.y;\n  return Math.sqrt((x * x) + (y * y));\n}\n","import euclideanDistance from './euclidean_distance.js';\n\nconst FINE_TOLERANCE = 4;\nconst GROSS_TOLERANCE = 12;\nconst INTERVAL = 500;\n\nexport default function isClick(start, end, options = {}) {\n  const fineTolerance = (options.fineTolerance != null) ? options.fineTolerance : FINE_TOLERANCE;\n  const grossTolerance = (options.grossTolerance != null) ? options.grossTolerance : GROSS_TOLERANCE;\n  const interval = (options.interval != null) ? options.interval : INTERVAL;\n\n  start.point = start.point || end.point;\n  start.time = start.time || end.time;\n  const moveDistance = euclideanDistance(start.point, end.point);\n\n  return moveDistance < fineTolerance ||\n    (moveDistance < grossTolerance && (end.time - start.time) < interval);\n}\n","import euclideanDistance from './euclidean_distance.js';\n\nexport const TAP_TOLERANCE = 25;\nexport const TAP_INTERVAL = 250;\n\nexport default function isTap(start, end, options = {}) {\n  const tolerance = (options.tolerance != null) ? options.tolerance : TAP_TOLERANCE;\n  const interval = (options.interval != null) ? options.interval : TAP_INTERVAL;\n\n  start.point = start.point || end.point;\n  start.time = start.time || end.time;\n  const moveDistance = euclideanDistance(start.point, end.point);\n\n  return moveDistance < tolerance && (end.time - start.time) < interval;\n}\n","import {customAlphabet} from 'nanoid/non-secure';\n\nconst nanoid = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 32);\n\nexport function generateID() {\n  return nanoid();\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import {generateID} from '../lib/id.js';\nimport * as Constants from '../constants.js';\n\nconst Feature = function(ctx, geojson) {\n  this.ctx = ctx;\n  this.properties = geojson.properties || {};\n  this.coordinates = geojson.geometry.coordinates;\n  this.id = geojson.id || generateID();\n  this.type = geojson.geometry.type;\n};\n\nFeature.prototype.changed = function() {\n  this.ctx.store.featureChanged(this.id);\n};\n\nFeature.prototype.incomingCoords = function(coords) {\n  this.setCoordinates(coords);\n};\n\nFeature.prototype.setCoordinates = function(coords) {\n  this.coordinates = coords;\n  this.changed();\n};\n\nFeature.prototype.getCoordinates = function() {\n  return JSON.parse(JSON.stringify(this.coordinates));\n};\n\nFeature.prototype.setProperty = function(property, value) {\n  this.properties[property] = value;\n};\n\nFeature.prototype.toGeoJSON = function() {\n  return JSON.parse(JSON.stringify({\n    id: this.id,\n    type: Constants.geojsonTypes.FEATURE,\n    properties: this.properties,\n    geometry: {\n      coordinates: this.getCoordinates(),\n      type: this.type\n    }\n  }));\n};\n\nFeature.prototype.internal = function(mode) {\n  const properties = {\n    id: this.id,\n    meta: Constants.meta.FEATURE,\n    'meta:type': this.type,\n    active: Constants.activeStates.INACTIVE,\n    mode\n  };\n\n  if (this.ctx.options.userProperties) {\n    for (const name in this.properties) {\n      properties[`user_${name}`] = this.properties[name];\n    }\n  }\n\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties,\n    geometry: {\n      coordinates: this.getCoordinates(),\n      type: this.type\n    }\n  };\n};\n\nexport default Feature;\n","import Feature from './feature.js';\n\nconst Point = function(ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n};\n\nPoint.prototype = Object.create(Feature.prototype);\n\nPoint.prototype.isValid = function() {\n  return typeof this.coordinates[0] === 'number' &&\n    typeof this.coordinates[1] === 'number';\n};\n\nPoint.prototype.updateCoordinate = function(pathOrLng, lngOrLat, lat) {\n  if (arguments.length === 3) {\n    this.coordinates = [lngOrLat, lat];\n  } else {\n    this.coordinates = [pathOrLng, lngOrLat];\n  }\n  this.changed();\n};\n\nPoint.prototype.getCoordinate = function() {\n  return this.getCoordinates();\n};\n\nexport default Point;\n","import Feature from './feature.js';\n\nconst LineString = function(ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n};\n\nLineString.prototype = Object.create(Feature.prototype);\n\nLineString.prototype.isValid = function() {\n  return this.coordinates.length > 1;\n};\n\nLineString.prototype.addCoordinate = function(path, lng, lat) {\n  this.changed();\n  const id = parseInt(path, 10);\n  this.coordinates.splice(id, 0, [lng, lat]);\n};\n\nLineString.prototype.getCoordinate = function(path) {\n  const id = parseInt(path, 10);\n  return JSON.parse(JSON.stringify(this.coordinates[id]));\n};\n\nLineString.prototype.removeCoordinate = function(path) {\n  this.changed();\n  this.coordinates.splice(parseInt(path, 10), 1);\n};\n\nLineString.prototype.updateCoordinate = function(path, lng, lat) {\n  const id = parseInt(path, 10);\n  this.coordinates[id] = [lng, lat];\n  this.changed();\n};\n\nexport default LineString;\n","import Feature from './feature.js';\n\nconst Polygon = function(ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n  this.coordinates = this.coordinates.map(ring => ring.slice(0, -1));\n};\n\nPolygon.prototype = Object.create(Feature.prototype);\n\nPolygon.prototype.isValid = function() {\n  if (this.coordinates.length === 0) return false;\n  return this.coordinates.every(ring => ring.length > 2);\n};\n\n// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.\nPolygon.prototype.incomingCoords = function(coords) {\n  this.coordinates = coords.map(ring => ring.slice(0, -1));\n  this.changed();\n};\n\n// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.\nPolygon.prototype.setCoordinates = function(coords) {\n  this.coordinates = coords;\n  this.changed();\n};\n\nPolygon.prototype.addCoordinate = function(path, lng, lat) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n\n  const ring = this.coordinates[ids[0]];\n\n  ring.splice(ids[1], 0, [lng, lat]);\n};\n\nPolygon.prototype.removeCoordinate = function(path) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  if (ring) {\n    ring.splice(ids[1], 1);\n    if (ring.length < 3) {\n      this.coordinates.splice(ids[0], 1);\n    }\n  }\n};\n\nPolygon.prototype.getCoordinate = function(path) {\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  return JSON.parse(JSON.stringify(ring[ids[1]]));\n};\n\nPolygon.prototype.getCoordinates = function() {\n  return this.coordinates.map(coords => coords.concat([coords[0]]));\n};\n\nPolygon.prototype.updateCoordinate = function(path, lng, lat) {\n  this.changed();\n  const parts = path.split('.');\n  const ringId = parseInt(parts[0], 10);\n  const coordId = parseInt(parts[1], 10);\n\n  if (this.coordinates[ringId] === undefined) {\n    this.coordinates[ringId] = [];\n  }\n\n  this.coordinates[ringId][coordId] = [lng, lat];\n};\n\nexport default Polygon;\n","import {generateID} from '../lib/id.js';\nimport Feature from './feature.js';\nimport * as Constants from '../constants.js';\n\nimport MultiPoint from './point.js';\nimport MultiLineString from './line_string.js';\nimport MultiPolygon from './polygon.js';\n\nconst models = {\n  MultiPoint,\n  MultiLineString,\n  MultiPolygon\n};\n\nconst takeAction = (features, action, path, lng, lat) => {\n  const parts = path.split('.');\n  const idx = parseInt(parts[0], 10);\n  const tail = (!parts[1]) ? null : parts.slice(1).join('.');\n  return features[idx][action](tail, lng, lat);\n};\n\nconst MultiFeature = function(ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n\n  delete this.coordinates;\n  this.model = models[geojson.geometry.type];\n  if (this.model === undefined) throw new TypeError(`${geojson.geometry.type} is not a valid type`);\n  this.features = this._coordinatesToFeatures(geojson.geometry.coordinates);\n};\n\nMultiFeature.prototype = Object.create(Feature.prototype);\n\nMultiFeature.prototype._coordinatesToFeatures = function(coordinates) {\n  const Model = this.model.bind(this);\n  return coordinates.map(coords => new Model(this.ctx, {\n    id: generateID(),\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      coordinates: coords,\n      type: this.type.replace('Multi', '')\n    }\n  }));\n};\n\nMultiFeature.prototype.isValid = function() {\n  return this.features.every(f => f.isValid());\n};\n\nMultiFeature.prototype.setCoordinates = function(coords) {\n  this.features = this._coordinatesToFeatures(coords);\n  this.changed();\n};\n\nMultiFeature.prototype.getCoordinate = function(path) {\n  return takeAction(this.features, 'getCoordinate', path);\n};\n\nMultiFeature.prototype.getCoordinates = function() {\n  return JSON.parse(JSON.stringify(this.features.map((f) => {\n    if (f.type === Constants.geojsonTypes.POLYGON) return f.getCoordinates();\n    return f.coordinates;\n  })));\n};\n\nMultiFeature.prototype.updateCoordinate = function(path, lng, lat) {\n  takeAction(this.features, 'updateCoordinate', path, lng, lat);\n  this.changed();\n};\n\nMultiFeature.prototype.addCoordinate = function(path, lng, lat) {\n  takeAction(this.features, 'addCoordinate', path, lng, lat);\n  this.changed();\n};\n\nMultiFeature.prototype.removeCoordinate = function(path) {\n  takeAction(this.features, 'removeCoordinate', path);\n  this.changed();\n};\n\nMultiFeature.prototype.getFeatures = function() {\n  return this.features;\n};\n\nexport default MultiFeature;\n","import * as Constants from '../constants.js';\nimport featuresAt from '../lib/features_at.js';\nimport Point from '../feature_types/point.js';\nimport LineString from '../feature_types/line_string.js';\nimport Polygon from '../feature_types/polygon.js';\nimport MultiFeature from '../feature_types/multi_feature.js';\n\nexport default function ModeInterface(ctx) {\n  this.map = ctx.map;\n  this.drawConfig = JSON.parse(JSON.stringify(ctx.options || {}));\n  this._ctx = ctx;\n}\n\n/**\n * Sets Draw's interal selected state\n * @name this.setSelected\n * @param {DrawFeature[]} - whats selected as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js)\n */\nModeInterface.prototype.setSelected = function(features) {\n  return this._ctx.store.setSelected(features);\n};\n\n/**\n * Sets Draw's internal selected coordinate state\n * @name this.setSelectedCoordinates\n * @param {Object[]} coords - a array of {coord_path: 'string', feature_id: 'string'}\n */\nModeInterface.prototype.setSelectedCoordinates = function(coords) {\n  this._ctx.store.setSelectedCoordinates(coords);\n  coords.reduce((m, c) => {\n    if (m[c.feature_id] === undefined) {\n      m[c.feature_id] = true;\n      this._ctx.store.get(c.feature_id).changed();\n    }\n    return m;\n  }, {});\n};\n\n/**\n * Get all selected features as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js)\n * @name this.getSelected\n * @returns {DrawFeature[]}\n */\nModeInterface.prototype.getSelected = function() {\n  return this._ctx.store.getSelected();\n};\n\n/**\n * Get the ids of all currently selected features\n * @name this.getSelectedIds\n * @returns {String[]}\n */\nModeInterface.prototype.getSelectedIds = function() {\n  return this._ctx.store.getSelectedIds();\n};\n\n/**\n * Check if a feature is selected\n * @name this.isSelected\n * @param {String} id - a feature id\n * @returns {Boolean}\n */\nModeInterface.prototype.isSelected = function(id) {\n  return this._ctx.store.isSelected(id);\n};\n\n/**\n * Get a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js) by its id\n * @name this.getFeature\n * @param {String} id - a feature id\n * @returns {DrawFeature}\n */\nModeInterface.prototype.getFeature = function(id) {\n  return this._ctx.store.get(id);\n};\n\n/**\n * Add a feature to draw's internal selected state\n * @name this.select\n * @param {String} id\n */\nModeInterface.prototype.select = function(id) {\n  return this._ctx.store.select(id);\n};\n\n/**\n * Remove a feature from draw's internal selected state\n * @name this.delete\n * @param {String} id\n */\nModeInterface.prototype.deselect = function(id) {\n  return this._ctx.store.deselect(id);\n};\n\n/**\n * Delete a feature from draw\n * @name this.deleteFeature\n * @param {String} id - a feature id\n */\nModeInterface.prototype.deleteFeature = function(id, opts = {}) {\n  return this._ctx.store.delete(id, opts);\n};\n\n/**\n * Add a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js) to draw.\n * See `this.newFeature` for converting geojson into a DrawFeature\n * @name this.addFeature\n * @param {DrawFeature} feature - the feature to add\n */\nModeInterface.prototype.addFeature = function(feature, opts = {}) {\n  return this._ctx.store.add(feature, opts);\n};\n\n/**\n * Clear all selected features\n */\nModeInterface.prototype.clearSelectedFeatures = function() {\n  return this._ctx.store.clearSelected();\n};\n\n/**\n * Clear all selected coordinates\n */\nModeInterface.prototype.clearSelectedCoordinates = function() {\n  return this._ctx.store.clearSelectedCoordinates();\n};\n\n/**\n * Indicate if the different action are currently possible with your mode\n * See [draw.actionalbe](https://github.com/mapbox/mapbox-gl-draw/blob/main/API.md#drawactionable) for a list of possible actions. All undefined actions are set to **false** by default\n * @name this.setActionableState\n * @param {Object} actions\n */\nModeInterface.prototype.setActionableState = function(actions = {}) {\n  const newSet = {\n    trash: actions.trash || false,\n    combineFeatures: actions.combineFeatures || false,\n    uncombineFeatures: actions.uncombineFeatures || false\n  };\n  return this._ctx.events.actionable(newSet);\n};\n\n/**\n * Trigger a mode change\n * @name this.changeMode\n * @param {String} mode - the mode to transition into\n * @param {Object} opts - the options object to pass to the new mode\n * @param {Object} eventOpts - used to control what kind of events are emitted.\n */\nModeInterface.prototype.changeMode = function(mode, opts = {}, eventOpts = {}) {\n  return this._ctx.events.changeMode(mode, opts, eventOpts);\n};\n\n/**\n * Fire a map event\n * @name this.fire\n * @param {String} eventName - the event name.\n * @param {Object} eventData - the event data object.\n */\nModeInterface.prototype.fire = function(eventName, eventData) {\n  return this._ctx.events.fire(eventName, eventData);\n};\n\n/**\n * Update the state of draw map classes\n * @name this.updateUIClasses\n * @param {Object} opts\n */\nModeInterface.prototype.updateUIClasses = function(opts) {\n  return this._ctx.ui.queueMapClasses(opts);\n};\n\n/**\n * If a name is provided it makes that button active, else if makes all buttons inactive\n * @name this.activateUIButton\n * @param {String?} name - name of the button to make active, leave as undefined to set buttons to be inactive\n */\nModeInterface.prototype.activateUIButton = function(name) {\n  return this._ctx.ui.setActiveButton(name);\n};\n\n/**\n * Get the features at the location of an event object or in a bbox\n * @name this.featuresAt\n * @param {Event||NULL} event - a mapbox-gl event object\n * @param {BBOX||NULL} bbox - the area to get features from\n * @param {String} bufferType - is this `click` or `tap` event, defaults to click\n */\nModeInterface.prototype.featuresAt = function(event, bbox, bufferType = 'click') {\n  if (bufferType !== 'click' && bufferType !== 'touch') throw new Error('invalid buffer type');\n  return featuresAt[bufferType](event, bbox, this._ctx);\n};\n\n/**\n * Create a new [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js) from geojson\n * @name this.newFeature\n * @param {GeoJSONFeature} geojson\n * @returns {DrawFeature}\n */\nModeInterface.prototype.newFeature = function(geojson) {\n  const type = geojson.geometry.type;\n  if (type === Constants.geojsonTypes.POINT) return new Point(this._ctx, geojson);\n  if (type === Constants.geojsonTypes.LINE_STRING) return new LineString(this._ctx, geojson);\n  if (type === Constants.geojsonTypes.POLYGON) return new Polygon(this._ctx, geojson);\n  return new MultiFeature(this._ctx, geojson);\n};\n\n/**\n * Check is an object is an instance of a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/main/src/feature_types/feature.js)\n * @name this.isInstanceOf\n * @param {String} type - `Point`, `LineString`, `Polygon`, `MultiFeature`\n * @param {Object} feature - the object that needs to be checked\n * @returns {Boolean}\n */\nModeInterface.prototype.isInstanceOf = function(type, feature) {\n  if (type === Constants.geojsonTypes.POINT) return feature instanceof Point;\n  if (type === Constants.geojsonTypes.LINE_STRING) return feature instanceof LineString;\n  if (type === Constants.geojsonTypes.POLYGON) return feature instanceof Polygon;\n  if (type === 'MultiFeature') return feature instanceof MultiFeature;\n  throw new Error(`Unknown feature class: ${type}`);\n};\n\n/**\n * Force draw to rerender the feature of the provided id\n * @name this.doRender\n * @param {String} id - a feature id\n */\nModeInterface.prototype.doRender = function(id) {\n  return this._ctx.store.featureChanged(id);\n};\n\n","import ModeInterface from './mode_interface_accessors.js';\nexport default ModeInterface;\n\n/**\n * Triggered while a mode is being transitioned into.\n * @param opts {Object} - this is the object passed via `draw.changeMode('mode', opts)`;\n * @name MODE.onSetup\n * @returns {Object} - this object will be passed to all other life cycle functions\n */\nModeInterface.prototype.onSetup = function() {};\n\n/**\n * Triggered when a drag event is detected on the map\n * @name MODE.onDrag\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onDrag = function() {};\n\n/**\n * Triggered when the mouse is clicked\n * @name MODE.onClick\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onClick = function() {};\n\n/**\n * Triggered with the mouse is moved\n * @name MODE.onMouseMove\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onMouseMove = function() {};\n\n/**\n * Triggered when the mouse button is pressed down\n * @name MODE.onMouseDown\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onMouseDown = function() {};\n\n/**\n * Triggered when the mouse button is released\n * @name MODE.onMouseUp\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onMouseUp = function() {};\n\n/**\n * Triggered when the mouse leaves the map's container\n * @name MODE.onMouseOut\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onMouseOut = function() {};\n\n/**\n * Triggered when a key up event is detected\n * @name MODE.onKeyUp\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onKeyUp = function() {};\n\n/**\n * Triggered when a key down event is detected\n * @name MODE.onKeyDown\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onKeyDown = function() {};\n\n/**\n * Triggered when a touch event is started\n * @name MODE.onTouchStart\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onTouchStart = function() {};\n\n/**\n * Triggered when one drags thier finger on a mobile device\n * @name MODE.onTouchMove\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onTouchMove = function() {};\n\n/**\n * Triggered when one removes their finger from the map\n * @name MODE.onTouchEnd\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onTouchEnd = function() {};\n\n/**\n * Triggered when one quicly taps the map\n * @name MODE.onTap\n * @param state {Object} - a mutible state object created by onSetup\n * @param e {Object} - the captured event that is triggering this life cycle event\n */\nModeInterface.prototype.onTap = function() {};\n\n/**\n * Triggered when the mode is being exited, to be used for cleaning up artifacts such as invalid features\n * @name MODE.onStop\n * @param state {Object} - a mutible state object created by onSetup\n */\nModeInterface.prototype.onStop = function() {};\n\n/**\n * Triggered when [draw.trash()](https://github.com/mapbox/mapbox-gl-draw/blob/main/API.md#trash-draw) is called.\n * @name MODE.onTrash\n * @param state {Object} - a mutible state object created by onSetup\n */\nModeInterface.prototype.onTrash = function() {};\n\n/**\n * Triggered when [draw.combineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/main/API.md#combinefeatures-draw) is called.\n * @name MODE.onCombineFeature\n * @param state {Object} - a mutible state object created by onSetup\n */\nModeInterface.prototype.onCombineFeature = function() {};\n\n/**\n * Triggered when [draw.uncombineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/main/API.md#uncombinefeatures-draw) is called.\n * @name MODE.onUncombineFeature\n * @param state {Object} - a mutible state object created by onSetup\n */\nModeInterface.prototype.onUncombineFeature = function() {};\n\n/**\n * Triggered per feature on render to convert raw features into set of features for display on the map\n * See [styling draw](https://github.com/mapbox/mapbox-gl-draw/blob/main/API.md#styling-draw) for information about what geojson properties Draw uses as part of rendering.\n * @name MODE.toDisplayFeatures\n * @param state {Object} - a mutible state object created by onSetup\n * @param geojson {Object} - a geojson being evaulated. To render, pass to `display`.\n * @param display {Function} - all geojson objects passed to this be rendered onto the map\n */\nModeInterface.prototype.toDisplayFeatures = function() {\n  throw new Error('You must overwrite toDisplayFeatures');\n};\n\n","import ModeInterface from './mode_interface.js';\n\nconst eventMapper = {\n  drag: 'onDrag',\n  click: 'onClick',\n  mousemove: 'onMouseMove',\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseout: 'onMouseOut',\n  keyup: 'onKeyUp',\n  keydown: 'onKeyDown',\n  touchstart: 'onTouchStart',\n  touchmove: 'onTouchMove',\n  touchend: 'onTouchEnd',\n  tap: 'onTap'\n};\n\nconst eventKeys = Object.keys(eventMapper);\n\nexport default function(modeObject) {\n  const modeObjectKeys = Object.keys(modeObject);\n\n  return function(ctx, startOpts = {}) {\n    let state = {};\n\n    const mode = modeObjectKeys.reduce((m, k) => {\n      m[k] = modeObject[k];\n      return m;\n    }, new ModeInterface(ctx));\n\n    function wrapper(eh) {\n      return e => mode[eh](state, e);\n    }\n\n    return {\n      start() {\n        state = mode.onSetup(startOpts); // this should set ui buttons\n\n        // Adds event handlers for all event options\n        // add sets the selector to false for all\n        // handlers that are not present in the mode\n        // to reduce on render calls for functions that\n        // have no logic\n        eventKeys.forEach((key) => {\n          const modeHandler = eventMapper[key];\n          let selector = () => false;\n          if (modeObject[modeHandler]) {\n            selector = () => true;\n          }\n          this.on(key, selector, wrapper(modeHandler));\n        });\n\n      },\n      stop() {\n        mode.onStop(state);\n      },\n      trash() {\n        mode.onTrash(state);\n      },\n      combineFeatures() {\n        mode.onCombineFeatures(state);\n      },\n      uncombineFeatures() {\n        mode.onUncombineFeatures(state);\n      },\n      render(geojson, push) {\n        mode.toDisplayFeatures(state, geojson, push);\n      }\n    };\n  };\n}\n","/**\n * Derive a dense array (no `undefined`s) from a single value or array.\n *\n * @param {any} x\n * @return {Array<any>}\n */\nfunction toDenseArray(x) {\n  return [].concat(x).filter(y => y !== undefined);\n}\n\nexport default toDenseArray;\n","import * as Constants from './constants.js';\n\nexport default function render() {\n  // eslint-disable-next-line no-invalid-this\n  const store = this;\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n\n  const mode = store.ctx.events.currentModeName();\n\n  store.ctx.ui.queueMapClasses({ mode });\n\n  let newHotIds = [];\n  let newColdIds = [];\n\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\n    newColdIds = store.sources.hot.filter(geojson => geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined).map(geojson => geojson.properties.id);\n  }\n\n  store.sources.hot = [];\n  const lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {\n    const id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\n\n  function renderFeature(id, source) {\n    const feature = store.get(id);\n    const featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, (geojson) => {\n      geojson.properties.mode = mode;\n      store.sources[source].push(geojson);\n    });\n  }\n\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n\n  cleanup();\n\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n}\n","import toDenseArray from './lib/to_dense_array.js';\nimport StringSet from './lib/string_set.js';\nimport render from './render.js';\nimport * as Constants from './constants.js';\n\nexport default function Store(ctx) {\n  this._features = {};\n  this._featureIds = new StringSet();\n  this._selectedFeatureIds = new StringSet();\n  this._selectedCoordinates = [];\n  this._changedFeatureIds = new StringSet();\n  this._emitSelectionChange = false;\n  this._mapInitialConfig = {};\n  this.ctx = ctx;\n  this.sources = {\n    hot: [],\n    cold: []\n  };\n\n  // Deduplicate requests to render and tie them to animation frames.\n  let renderRequest;\n  this.render = () => {\n    if (!renderRequest) {\n      renderRequest = requestAnimationFrame(() => {\n        renderRequest = null;\n        render.call(this);\n\n        // Fire deduplicated selection change event\n        if (this._emitSelectionChange) {\n          this.ctx.events.fire(Constants.events.SELECTION_CHANGE, {\n            features: this.getSelected().map(feature => feature.toGeoJSON()),\n            points: this.getSelectedCoordinates().map(coordinate => ({\n              type: Constants.geojsonTypes.FEATURE,\n              properties: {},\n              geometry: {\n                type: Constants.geojsonTypes.POINT,\n                coordinates: coordinate.coordinates\n              }\n            }))\n          });\n\n          this._emitSelectionChange = false;\n        }\n\n        // Fire render event\n        this.ctx.events.fire(Constants.events.RENDER, {});\n      });\n    }\n  };\n\n  this.isDirty = false;\n}\n\n/**\n * Delays all rendering until the returned function is invoked\n * @return {Function} renderBatch\n */\nStore.prototype.createRenderBatch = function() {\n  const holdRender = this.render;\n  let numRenders = 0;\n  this.render = function() {\n    numRenders++;\n  };\n\n  return () => {\n    this.render = holdRender;\n    if (numRenders > 0) {\n      this.render();\n    }\n  };\n};\n\n/**\n * Sets the store's state to dirty.\n * @return {Store} this\n */\nStore.prototype.setDirty = function() {\n  this.isDirty = true;\n  return this;\n};\n\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\nStore.prototype.featureCreated = function(featureId, options = {}) {\n  this._changedFeatureIds.add(featureId);\n\n  const silent = options.silent != null ? options.silent : this.ctx.options.suppressAPIEvents;\n  if (silent !== true) {\n    const feature = this.get(featureId);\n    this.ctx.events.fire(Constants.events.CREATE, {\n      features: [feature.toGeoJSON()]\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\nStore.prototype.featureChanged = function(featureId, options = {}) {\n  this._changedFeatureIds.add(featureId);\n\n  const silent = options.silent != null ? options.silent : this.ctx.options.suppressAPIEvents;\n  if (silent !== true) {\n    this.ctx.events.fire(Constants.events.UPDATE, {\n      action: options.action ? options.action : Constants.updateActions.CHANGE_COORDINATES,\n      features: [this.get(featureId).toGeoJSON()]\n    });\n  }\n\n  return this;\n};\n\n/**\n * Gets the ids of all features currently in changed state.\n * @return {Store} this\n */\nStore.prototype.getChangedIds = function() {\n  return this._changedFeatureIds.values();\n};\n\n/**\n * Sets all features to unchanged state.\n * @return {Store} this\n */\nStore.prototype.clearChangedIds = function() {\n  this._changedFeatureIds.clear();\n  return this;\n};\n\n/**\n * Gets the ids of all features in the store.\n * @return {Store} this\n */\nStore.prototype.getAllIds = function() {\n  return this._featureIds.values();\n};\n\n/**\n * Adds a feature to the store.\n * @param {Object} feature\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n *\n * @return {Store} this\n */\nStore.prototype.add = function(feature, options = {}) {\n  this._features[feature.id] = feature;\n  this._featureIds.add(feature.id);\n  this.featureCreated(feature.id, {silent: options.silent});\n  return this;\n};\n\n/**\n * Deletes a feature or array of features from the store.\n * Cleans up after the deletion by deselecting the features.\n * If changes were made, sets the state to the dirty\n * and fires an event.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.delete = function(featureIds, options = {}) {\n  const deletedFeaturesToEmit = [];\n  toDenseArray(featureIds).forEach((id) => {\n    if (!this._featureIds.has(id)) return;\n    this._featureIds.delete(id);\n    this._selectedFeatureIds.delete(id);\n    if (!options.silent) {\n      if (deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {\n        deletedFeaturesToEmit.push(this._features[id].toGeoJSON());\n      }\n    }\n    delete this._features[id];\n    this.isDirty = true;\n  });\n\n  if (deletedFeaturesToEmit.length) {\n    this.ctx.events.fire(Constants.events.DELETE, {features: deletedFeaturesToEmit});\n  }\n\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n\n/**\n * Returns a feature in the store matching the specified value.\n * @return {Object | undefined} feature\n */\nStore.prototype.get = function(id) {\n  return this._features[id];\n};\n\n/**\n * Returns all features in the store.\n * @return {Array<Object>}\n */\nStore.prototype.getAll = function() {\n  return Object.keys(this._features).map(id => this._features[id]);\n};\n\n/**\n * Adds features to the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.select = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach((id) => {\n    if (this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.add(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  return this;\n};\n\n/**\n * Deletes features from the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.deselect = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach((id) => {\n    if (!this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.delete(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n\n/**\n * Clears the current selection.\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.clearSelected = function(options = {}) {\n  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });\n  return this;\n};\n\n/**\n * Sets the store's selection, clearing any prior values.\n * If no feature ids are passed, the store is just cleared.\n * @param {string | Array<string> | undefined} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.setSelected = function(featureIds, options = {}) {\n  featureIds = toDenseArray(featureIds);\n\n  // Deselect any features not in the new selection\n  this.deselect(this._selectedFeatureIds.values().filter(id => featureIds.indexOf(id) === -1), { silent: options.silent });\n\n  // Select any features in the new selection that were not already selected\n  this.select(featureIds.filter(id => !this._selectedFeatureIds.has(id)), { silent: options.silent });\n\n  return this;\n};\n\n/**\n * Sets the store's coordinates selection, clearing any prior values.\n * @param {Array<Array<string>>} coordinates\n * @return {Store} this\n */\nStore.prototype.setSelectedCoordinates = function(coordinates) {\n  this._selectedCoordinates = coordinates;\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Clears the current coordinates selection.\n * @param {Object} [options]\n * @return {Store} this\n */\nStore.prototype.clearSelectedCoordinates = function() {\n  this._selectedCoordinates = [];\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Returns the ids of features in the current selection.\n * @return {Array<string>} Selected feature ids.\n */\nStore.prototype.getSelectedIds = function() {\n  return this._selectedFeatureIds.values();\n};\n\n/**\n * Returns features in the current selection.\n * @return {Array<Object>} Selected features.\n */\nStore.prototype.getSelected = function() {\n  return this.getSelectedIds().map(id => this.get(id));\n};\n\n/**\n * Returns selected coordinates in the currently selected feature.\n * @return {Array<Object>} Selected coordinates.\n */\nStore.prototype.getSelectedCoordinates = function() {\n  const selected = this._selectedCoordinates.map((coordinate) => {\n    const feature = this.get(coordinate.feature_id);\n    return {\n      coordinates: feature.getCoordinate(coordinate.coord_path)\n    };\n  });\n  return selected;\n};\n\n/**\n * Indicates whether a feature is selected.\n * @param {string} featureId\n * @return {boolean} `true` if the feature is selected, `false` if not.\n */\nStore.prototype.isSelected = function(featureId) {\n  return this._selectedFeatureIds.has(featureId);\n};\n\n/**\n * Sets a property on the given feature\n * @param {string} featureId\n * @param {string} property property\n * @param {string} property value\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n*/\nStore.prototype.setFeatureProperty = function(featureId, property, value, options = {}) {\n  this.get(featureId).setProperty(property, value);\n\n  this.featureChanged(featureId, {\n    silent: options.silent,\n    action: Constants.updateActions.CHANGE_PROPERTIES\n  });\n};\n\nfunction refreshSelectedCoordinates(store, options = {}) {\n  const newSelectedCoordinates = store._selectedCoordinates.filter(point => store._selectedFeatureIds.has(point.feature_id));\n  if (store._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {\n    store._emitSelectionChange = true;\n  }\n  store._selectedCoordinates = newSelectedCoordinates;\n}\n\n/**\n * Stores the initial config for a map, so that we can set it again after we're done.\n*/\nStore.prototype.storeMapConfig = function() {\n  Constants.interactions.forEach((interaction) => {\n    const interactionSet = this.ctx.map[interaction];\n    if (interactionSet) {\n      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();\n    }\n  });\n};\n\n/**\n * Restores the initial config for a map, ensuring all is well.\n*/\nStore.prototype.restoreMapConfig = function() {\n  Object.keys(this._mapInitialConfig).forEach((key) => {\n    const value = this._mapInitialConfig[key];\n    if (value) {\n      this.ctx.map[key].enable();\n    } else {\n      this.ctx.map[key].disable();\n    }\n  });\n};\n\n/**\n * Returns the initial state of an interaction setting.\n * @param {string} interaction\n * @return {boolean} `true` if the interaction is enabled, `false` if not.\n * Defaults to `true`. (Todo: include defaults.)\n*/\nStore.prototype.getInitialConfigValue = function(interaction) {\n  if (this._mapInitialConfig[interaction] !== undefined) {\n    return this._mapInitialConfig[interaction];\n  } else {\n    // This needs to be set to whatever the default is for that interaction\n    // It seems to be true for all cases currently, so let's send back `true`.\n    return true;\n  }\n};\n","import * as Constants from './constants.js';\n\nconst classTypes = ['mode', 'feature', 'mouse'];\n\nexport default function(ctx) {\n\n\n  const buttonElements = {};\n  let activeButton = null;\n\n  let currentMapClasses = {\n    mode: null, // e.g. mode-direct_select\n    feature: null, // e.g. feature-vertex\n    mouse: null // e.g. mouse-move\n  };\n\n  let nextMapClasses = {\n    mode: null,\n    feature: null,\n    mouse: null\n  };\n\n  function clearMapClasses() {\n    queueMapClasses({mode:null, feature:null, mouse:null});\n    updateMapClasses();\n  }\n\n  function queueMapClasses(options) {\n    nextMapClasses = Object.assign(nextMapClasses, options);\n  }\n\n  function updateMapClasses() {\n    if (!ctx.container) return;\n\n    const classesToRemove = [];\n    const classesToAdd = [];\n\n    classTypes.forEach((type) => {\n      if (nextMapClasses[type] === currentMapClasses[type]) return;\n\n      classesToRemove.push(`${type}-${currentMapClasses[type]}`);\n      if (nextMapClasses[type] !== null) {\n        classesToAdd.push(`${type}-${nextMapClasses[type]}`);\n      }\n    });\n\n    if (classesToRemove.length > 0) {\n      ctx.container.classList.remove(...classesToRemove);\n    }\n\n    if (classesToAdd.length > 0) {\n      ctx.container.classList.add(...classesToAdd);\n    }\n\n    currentMapClasses = Object.assign(currentMapClasses, nextMapClasses);\n  }\n\n  function createControlButton(id, options = {}) {\n    const button = document.createElement('button');\n    button.className = `${Constants.classes.CONTROL_BUTTON} ${options.className}`;\n    button.setAttribute('title', options.title);\n    options.container.appendChild(button);\n\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const clickedButton = e.target;\n      if (clickedButton === activeButton) {\n        deactivateButtons();\n        options.onDeactivate();\n        return;\n      }\n\n      setActiveButton(id);\n      options.onActivate();\n    }, true);\n\n    return button;\n  }\n\n  function deactivateButtons() {\n    if (!activeButton) return;\n    activeButton.classList.remove(Constants.classes.ACTIVE_BUTTON);\n    activeButton = null;\n  }\n\n  function setActiveButton(id) {\n    deactivateButtons();\n\n    const button = buttonElements[id];\n    if (!button) return;\n\n    if (button && id !== 'trash') {\n      button.classList.add(Constants.classes.ACTIVE_BUTTON);\n      activeButton = button;\n    }\n  }\n\n  function addButtons() {\n    const controls = ctx.options.controls;\n    const controlGroup = document.createElement('div');\n    controlGroup.className = `${Constants.classes.CONTROL_GROUP} ${Constants.classes.CONTROL_BASE}`;\n\n    if (!controls) return controlGroup;\n\n    if (controls[Constants.types.LINE]) {\n      buttonElements[Constants.types.LINE] = createControlButton(Constants.types.LINE, {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_LINE,\n        title: `LineString tool ${ctx.options.keybindings ? '(l)' : ''}`,\n        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_LINE_STRING),\n        onDeactivate: () => ctx.events.trash()\n      });\n    }\n\n    if (controls[Constants.types.POLYGON]) {\n      buttonElements[Constants.types.POLYGON] = createControlButton(Constants.types.POLYGON, {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_POLYGON,\n        title: `Polygon tool ${ctx.options.keybindings ? '(p)' : ''}`,\n        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_POLYGON),\n        onDeactivate: () => ctx.events.trash()\n      });\n    }\n\n    if (controls[Constants.types.POINT]) {\n      buttonElements[Constants.types.POINT] = createControlButton(Constants.types.POINT, {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_POINT,\n        title: `Marker tool ${ctx.options.keybindings ? '(m)' : ''}`,\n        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_POINT),\n        onDeactivate: () => ctx.events.trash()\n      });\n    }\n\n    if (controls.trash) {\n      buttonElements.trash = createControlButton('trash', {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_TRASH,\n        title: 'Delete',\n        onActivate: () => {\n          ctx.events.trash();\n        }\n      });\n    }\n\n    if (controls.combine_features) {\n      buttonElements.combine_features = createControlButton('combineFeatures', {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_COMBINE_FEATURES,\n        title: 'Combine',\n        onActivate: () => {\n          ctx.events.combineFeatures();\n        }\n      });\n    }\n\n    if (controls.uncombine_features) {\n      buttonElements.uncombine_features = createControlButton('uncombineFeatures', {\n        container: controlGroup,\n        className: Constants.classes.CONTROL_BUTTON_UNCOMBINE_FEATURES,\n        title: 'Uncombine',\n        onActivate: () => {\n          ctx.events.uncombineFeatures();\n        }\n      });\n    }\n\n    return controlGroup;\n  }\n\n  function removeButtons() {\n    Object.keys(buttonElements).forEach((buttonId) => {\n      const button = buttonElements[buttonId];\n      if (button.parentNode) {\n        button.parentNode.removeChild(button);\n      }\n      delete buttonElements[buttonId];\n    });\n  }\n\n  return {\n    setActiveButton,\n    queueMapClasses,\n    updateMapClasses,\n    clearMapClasses,\n    addButtons,\n    removeButtons\n  };\n}\n","import events from './events.js';\nimport Store from './store.js';\nimport ui from './ui.js';\nimport * as Constants from './constants.js';\n\nexport default function(ctx) {\n\n  let controlContainer = null;\n  let mapLoadedInterval = null;\n\n  const setup = {\n    onRemove() {\n      // Stop connect attempt in the event that control is removed before map is loaded\n      ctx.map.off('load', setup.connect);\n      clearInterval(mapLoadedInterval);\n\n      setup.removeLayers();\n      ctx.store.restoreMapConfig();\n      ctx.ui.removeButtons();\n      ctx.events.removeEventListeners();\n      ctx.ui.clearMapClasses();\n      if (ctx.boxZoomInitial) ctx.map.boxZoom.enable();\n      ctx.map = null;\n      ctx.container = null;\n      ctx.store = null;\n\n      if (controlContainer && controlContainer.parentNode) controlContainer.parentNode.removeChild(controlContainer);\n      controlContainer = null;\n\n      return this;\n    },\n    connect() {\n      ctx.map.off('load', setup.connect);\n      clearInterval(mapLoadedInterval);\n      setup.addLayers();\n      ctx.store.storeMapConfig();\n      ctx.events.addEventListeners();\n    },\n    onAdd(map) {\n      ctx.map = map;\n      ctx.events = events(ctx);\n      ctx.ui = ui(ctx);\n      ctx.container = map.getContainer();\n      ctx.store = new Store(ctx);\n\n\n      controlContainer = ctx.ui.addButtons();\n\n      if (ctx.options.boxSelect) {\n        ctx.boxZoomInitial = map.boxZoom.isEnabled();\n        map.boxZoom.disable();\n        const dragPanIsEnabled = map.dragPan.isEnabled();\n        // Need to toggle dragPan on and off or else first\n        // dragPan disable attempt in simple_select doesn't work\n        map.dragPan.disable();\n        map.dragPan.enable();\n        if (!dragPanIsEnabled) {\n          map.dragPan.disable();\n        }\n      }\n\n      if (map.loaded()) {\n        setup.connect();\n      } else {\n        map.on('load', setup.connect);\n        mapLoadedInterval = setInterval(() => { if (map.loaded()) setup.connect(); }, 16);\n      }\n\n      ctx.events.start();\n      return controlContainer;\n    },\n    addLayers() {\n      // drawn features style\n      ctx.map.addSource(Constants.sources.COLD, {\n        data: {\n          type: Constants.geojsonTypes.FEATURE_COLLECTION,\n          features: []\n        },\n        type: 'geojson'\n      });\n\n      // hot features style\n      ctx.map.addSource(Constants.sources.HOT, {\n        data: {\n          type: Constants.geojsonTypes.FEATURE_COLLECTION,\n          features: []\n        },\n        type: 'geojson'\n      });\n\n      ctx.options.styles.forEach((style) => {\n        ctx.map.addLayer(style);\n      });\n\n      ctx.store.setDirty(true);\n      ctx.store.render();\n    },\n    // Check for layers and sources before attempting to remove\n    // If user adds draw control and removes it before the map is loaded, layers and sources will be missing\n    removeLayers() {\n      ctx.options.styles.forEach((style) => {\n        if (ctx.map.getLayer(style.id)) {\n          ctx.map.removeLayer(style.id);\n        }\n      });\n\n      if (ctx.map.getSource(Constants.sources.COLD)) {\n        ctx.map.removeSource(Constants.sources.COLD);\n      }\n\n      if (ctx.map.getSource(Constants.sources.HOT)) {\n        ctx.map.removeSource(Constants.sources.HOT);\n      }\n    }\n  };\n\n  ctx.setup = setup;\n\n  return setup;\n}\n","import setupModeHandler from './lib/mode_handler.js';\nimport getFeaturesAndSetCursor from './lib/get_features_and_set_cursor.js';\nimport featuresAt from './lib/features_at.js';\nimport isClick from './lib/is_click.js';\nimport isTap from './lib/is_tap.js';\nimport * as Constants from './constants.js';\nimport objectToMode from './modes/object_to_mode.js';\n\nexport default function(ctx) {\n\n  const modes = Object.keys(ctx.options.modes).reduce((m, k) => {\n    m[k] = objectToMode(ctx.options.modes[k]);\n    return m;\n  }, {});\n\n  let mouseDownInfo = {};\n  let touchStartInfo = {};\n  const events = {};\n  let currentModeName = null;\n  let currentMode = null;\n\n  events.drag = function(event, isDrag) {\n    if (isDrag({\n      point: event.point,\n      time: new Date().getTime()\n    })) {\n      ctx.ui.queueMapClasses({ mouse: Constants.cursors.DRAG });\n      currentMode.drag(event);\n    } else {\n      event.originalEvent.stopPropagation();\n    }\n  };\n\n  events.mousedrag = function(event) {\n    events.drag(event, endInfo => !isClick(mouseDownInfo, endInfo));\n  };\n\n  events.touchdrag = function(event) {\n    events.drag(event, endInfo => !isTap(touchStartInfo, endInfo));\n  };\n\n  events.mousemove = function(event) {\n    const button = event.originalEvent.buttons !== undefined ? event.originalEvent.buttons : event.originalEvent.which;\n    if (button === 1) {\n      return events.mousedrag(event);\n    }\n    const target = getFeaturesAndSetCursor(event, ctx);\n    event.featureTarget = target;\n    currentMode.mousemove(event);\n  };\n\n  events.mousedown = function(event) {\n    mouseDownInfo = {\n      time: new Date().getTime(),\n      point: event.point\n    };\n    const target = getFeaturesAndSetCursor(event, ctx);\n    event.featureTarget = target;\n    currentMode.mousedown(event);\n  };\n\n  events.mouseup = function(event) {\n    const target = getFeaturesAndSetCursor(event, ctx);\n    event.featureTarget = target;\n\n    if (isClick(mouseDownInfo, {\n      point: event.point,\n      time: new Date().getTime()\n    })) {\n      currentMode.click(event);\n    } else {\n      currentMode.mouseup(event);\n    }\n  };\n\n  events.mouseout = function(event) {\n    currentMode.mouseout(event);\n  };\n\n  events.touchstart = function(event) {\n    if (!ctx.options.touchEnabled) {\n      return;\n    }\n\n    touchStartInfo = {\n      time: new Date().getTime(),\n      point: event.point\n    };\n    const target = featuresAt.touch(event, null, ctx)[0];\n    event.featureTarget = target;\n    currentMode.touchstart(event);\n  };\n\n  events.touchmove = function(event) {\n    if (!ctx.options.touchEnabled) {\n      return;\n    }\n\n    currentMode.touchmove(event);\n    return events.touchdrag(event);\n  };\n\n  events.touchend = function(event) {\n    // Prevent emulated mouse events because we will fully handle the touch here.\n    // This does not stop the touch events from propogating to mapbox though.\n    event.originalEvent.preventDefault();\n    if (!ctx.options.touchEnabled) {\n      return;\n    }\n\n    const target = featuresAt.touch(event, null, ctx)[0];\n    event.featureTarget = target;\n    if (isTap(touchStartInfo, {\n      time: new Date().getTime(),\n      point: event.point\n    })) {\n      currentMode.tap(event);\n    } else {\n      currentMode.touchend(event);\n    }\n  };\n\n  // 8 - Backspace\n  // 46 - Delete\n  const isKeyModeValid = code => !(code === 8 || code === 46 || (code >= 48 && code <= 57));\n\n  events.keydown = function(event) {\n    const isMapElement = (event.srcElement || event.target).classList.contains(Constants.classes.CANVAS);\n    if (!isMapElement) return; // we only handle events on the map\n\n    if ((event.keyCode === 8 || event.keyCode === 46) && ctx.options.controls.trash) {\n      event.preventDefault();\n      currentMode.trash();\n    } else if (isKeyModeValid(event.keyCode)) {\n      currentMode.keydown(event);\n    } else if (event.keyCode === 49 && ctx.options.controls.point) {\n      changeMode(Constants.modes.DRAW_POINT);\n    } else if (event.keyCode === 50 && ctx.options.controls.line_string) {\n      changeMode(Constants.modes.DRAW_LINE_STRING);\n    } else if (event.keyCode === 51 && ctx.options.controls.polygon) {\n      changeMode(Constants.modes.DRAW_POLYGON);\n    }\n  };\n\n  events.keyup = function(event) {\n    if (isKeyModeValid(event.keyCode)) {\n      currentMode.keyup(event);\n    }\n  };\n\n  events.zoomend = function() {\n    ctx.store.changeZoom();\n  };\n\n  events.data = function(event) {\n    if (event.dataType === 'style') {\n      const { setup, map, options, store } = ctx;\n      const hasLayers = options.styles.some(style => map.getLayer(style.id));\n      if (!hasLayers) {\n        setup.addLayers();\n        store.setDirty();\n        store.render();\n      }\n    }\n  };\n\n  function changeMode(modename, nextModeOptions, eventOptions = {}) {\n    currentMode.stop();\n\n    const modebuilder = modes[modename];\n    if (modebuilder === undefined) {\n      throw new Error(`${modename} is not valid`);\n    }\n    currentModeName = modename;\n    const mode = modebuilder(ctx, nextModeOptions);\n    currentMode = setupModeHandler(mode, ctx);\n\n    if (!eventOptions.silent) {\n      ctx.map.fire(Constants.events.MODE_CHANGE, { mode: modename});\n    }\n\n    ctx.store.setDirty();\n    ctx.store.render();\n  }\n\n  const actionState = {\n    trash: false,\n    combineFeatures: false,\n    uncombineFeatures: false\n  };\n\n  function actionable(actions) {\n    let changed = false;\n    Object.keys(actions).forEach((action) => {\n      if (actionState[action] === undefined) throw new Error('Invalid action type');\n      if (actionState[action] !== actions[action]) changed = true;\n      actionState[action] = actions[action];\n    });\n    if (changed) ctx.map.fire(Constants.events.ACTIONABLE, { actions: actionState });\n  }\n\n  const api = {\n    start() {\n      currentModeName = ctx.options.defaultMode;\n      currentMode = setupModeHandler(modes[currentModeName](ctx), ctx);\n    },\n    changeMode,\n    actionable,\n    currentModeName() {\n      return currentModeName;\n    },\n    currentModeRender(geojson, push) {\n      return currentMode.render(geojson, push);\n    },\n    fire(eventName, eventData) {\n      if (!ctx.map) return;\n      ctx.map.fire(eventName, eventData);\n    },\n    addEventListeners() {\n      ctx.map.on('mousemove', events.mousemove);\n      ctx.map.on('mousedown', events.mousedown);\n      ctx.map.on('mouseup', events.mouseup);\n      ctx.map.on('data', events.data);\n\n      ctx.map.on('touchmove', events.touchmove);\n      ctx.map.on('touchstart', events.touchstart);\n      ctx.map.on('touchend', events.touchend);\n\n      ctx.container.addEventListener('mouseout', events.mouseout);\n\n      if (ctx.options.keybindings) {\n        ctx.container.addEventListener('keydown', events.keydown);\n        ctx.container.addEventListener('keyup', events.keyup);\n      }\n    },\n    removeEventListeners() {\n      ctx.map.off('mousemove', events.mousemove);\n      ctx.map.off('mousedown', events.mousedown);\n      ctx.map.off('mouseup', events.mouseup);\n      ctx.map.off('data', events.data);\n\n      ctx.map.off('touchmove', events.touchmove);\n      ctx.map.off('touchstart', events.touchstart);\n      ctx.map.off('touchend', events.touchend);\n\n      ctx.container.removeEventListener('mouseout', events.mouseout);\n\n      if (ctx.options.keybindings) {\n        ctx.container.removeEventListener('keydown', events.keydown);\n        ctx.container.removeEventListener('keyup', events.keyup);\n      }\n    },\n    trash(options) {\n      currentMode.trash(options);\n    },\n    combineFeatures() {\n      currentMode.combineFeatures();\n    },\n    uncombineFeatures() {\n      currentMode.uncombineFeatures();\n    },\n    getMode() {\n      return currentModeName;\n    }\n  };\n\n  return api;\n}\n","/* eslint comma-dangle: [\"error\", \"always-multiline\"] */\n\nconst blue = '#3bb2d0';\nconst orange = '#fbb03b';\nconst white = '#fff';\n\nexport default [\n  // Polygons\n  //   Solid fill\n  //   Active state defines color\n  {\n    'id': 'gl-draw-polygon-fill',\n    'type': 'fill',\n    'filter': [\n      'all',\n      ['==', '$type', 'Polygon'],\n    ],\n    'paint': {\n      'fill-color': [\n        'case',\n        ['==', ['get', 'active'], 'true'], orange,\n        blue,\n      ],\n      'fill-opacity': 0.1,\n    },\n  },\n  // Lines\n  // Polygon\n  //   Matches Lines AND Polygons\n  //   Active state defines color\n  {\n    'id': 'gl-draw-lines',\n    'type': 'line',\n    'filter': [\n      'any',\n      ['==', '$type', 'LineString'],\n      ['==', '$type', 'Polygon'],\n    ],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round',\n    },\n    'paint': {\n      'line-color': [\n        'case',\n        ['==', ['get', 'active'], 'true'], orange,\n        blue,\n      ],\n      'line-dasharray': [\n        'case',\n        ['==', ['get', 'active'], 'true'], [0.2, 2],\n        [2, 0],\n      ],\n      'line-width': 2,\n    },\n  },\n  // Points\n  //   Circle with an outline\n  //   Active state defines size and color\n  {\n    'id': 'gl-draw-point-outer',\n    'type': 'circle',\n    'filter': [\n      'all',\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'feature'],\n    ],\n    'paint': {\n      'circle-radius': [\n        'case',\n        ['==', ['get', 'active'], 'true'], 7,\n        5,\n      ],\n      'circle-color': white,\n    },\n  },\n  {\n    'id': 'gl-draw-point-inner',\n    'type': 'circle',\n    'filter': [\n      'all',\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'feature'],\n    ],\n    'paint': {\n      'circle-radius': [\n        'case',\n        ['==', ['get', 'active'], 'true'], 5,\n        3,\n      ],\n      'circle-color': [\n        'case',\n        ['==', ['get', 'active'], 'true'], orange,\n        blue,\n      ],\n    },\n  },\n  // Vertex\n  //   Visible when editing polygons and lines\n  //   Similar behaviour to Points\n  //   Active state defines size\n  {\n    'id': 'gl-draw-vertex-outer',\n    'type': 'circle',\n    'filter': [\n      'all',\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'vertex'],\n      ['!=', 'mode', 'simple_select'],\n    ],\n    'paint': {\n      'circle-radius': [\n        'case',\n        ['==', ['get', 'active'], 'true'], 7,\n        5,\n      ],\n      'circle-color': white,\n    },\n  },\n  {\n    'id': 'gl-draw-vertex-inner',\n    'type': 'circle',\n    'filter': [\n      'all',\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'vertex'],\n      ['!=', 'mode', 'simple_select'],\n    ],\n    'paint': {\n      'circle-radius': [\n        'case',\n        ['==', ['get', 'active'], 'true'], 5,\n        3,\n      ],\n      'circle-color': orange,\n    },\n  },\n  // Midpoint\n  //   Visible when editing polygons and lines\n  //   Tapping or dragging them adds a new vertex to the feature\n  {\n    'id': 'gl-draw-midpoint',\n    'type': 'circle',\n    'filter': [\n      'all',\n      ['==', 'meta', 'midpoint'],\n    ],\n    'paint': {\n      'circle-radius': 3,\n      'circle-color': orange,\n    },\n  },\n];\n","import * as Constants from '../constants.js';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin() for .\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n","import Point from '@mapbox/point-geometry';\n\n/**\n * Returns a Point representing a mouse event's position\n * relative to a containing element.\n *\n * @param {MouseEvent} mouseEvent\n * @param {Node} container\n * @returns {Point}\n */\nfunction mouseEventPoint(mouseEvent, container) {\n  const rect = container.getBoundingClientRect();\n  return new Point(\n    mouseEvent.clientX - rect.left - (container.clientLeft || 0),\n    mouseEvent.clientY - rect.top - (container.clientTop || 0)\n  );\n}\n\nexport default mouseEventPoint;\n","import * as Constants from '../constants.js';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\n\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import * as Constants from '../constants.js';\n\nexport default function(parent, startVertex, endVertex) {\n  const startCoord = startVertex.geometry.coordinates;\n  const endCoord = endVertex.geometry.coordinates;\n\n  // If a coordinate exceeds the projection, we can't calculate a midpoint,\n  // so run away\n  if (startCoord[1] > Constants.LAT_RENDERED_MAX ||\n    startCoord[1] < Constants.LAT_RENDERED_MIN ||\n    endCoord[1] > Constants.LAT_RENDERED_MAX ||\n    endCoord[1] < Constants.LAT_RENDERED_MIN) {\n    return null;\n  }\n\n  const mid = {\n    lng: (startCoord[0] + endCoord[0]) / 2,\n    lat: (startCoord[1] + endCoord[1]) / 2\n  };\n\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.MIDPOINT,\n      parent,\n      lng: mid.lng,\n      lat: mid.lat,\n      coord_path: endVertex.properties.coord_path\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: [mid.lng, mid.lat]\n    }\n  };\n}\n","import createVertex from './create_vertex.js';\nimport createMidpoint from './create_midpoint.js';\nimport * as Constants from '../constants.js';\n\nfunction createSupplementaryPoints(geojson, options = {}, basePath = null) {\n  const { type, coordinates } = geojson.geometry;\n  const featureId = geojson.properties && geojson.properties.id;\n\n  let supplementaryPoints = [];\n\n  if (type === Constants.geojsonTypes.POINT) {\n    // For points, just create a vertex\n    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));\n  } else if (type === Constants.geojsonTypes.POLYGON) {\n    // Cycle through a Polygon's rings and\n    // process each line\n    coordinates.forEach((line, lineIndex) => {\n      processLine(line, (basePath !== null) ? `${basePath}.${lineIndex}` : String(lineIndex));\n    });\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\n    processLine(coordinates, basePath);\n  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\n    processMultiGeometry();\n  }\n\n  function processLine(line, lineBasePath) {\n    let firstPointString = '';\n    let lastVertex = null;\n    line.forEach((point, pointIndex) => {\n      const pointPath = (lineBasePath !== undefined && lineBasePath !== null) ? `${lineBasePath}.${pointIndex}` : String(pointIndex);\n      const vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath));\n\n      // If we're creating midpoints, check if there was a\n      // vertex before this one. If so, add a midpoint\n      // between that vertex and this one.\n      if (options.midpoints && lastVertex) {\n        const midpoint = createMidpoint(featureId, lastVertex, vertex);\n        if (midpoint) {\n          supplementaryPoints.push(midpoint);\n        }\n      }\n      lastVertex = vertex;\n\n      // A Polygon line's last point is the same as the first point. If we're on the last\n      // point, we want to draw a midpoint before it but not another vertex on it\n      // (since we already a vertex there, from the first point).\n      const stringifiedPoint = JSON.stringify(point);\n      if (firstPointString !== stringifiedPoint) {\n        supplementaryPoints.push(vertex);\n      }\n      if (pointIndex === 0) {\n        firstPointString = stringifiedPoint;\n      }\n    });\n  }\n\n  function isSelectedPath(path) {\n    if (!options.selectedPaths) return false;\n    return options.selectedPaths.indexOf(path) !== -1;\n  }\n\n  // Split a multi-geometry into constituent\n  // geometries, and accumulate the supplementary points\n  // for each of those constituents\n  function processMultiGeometry() {\n    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\n    coordinates.forEach((subCoordinates, index) => {\n      const subFeature = {\n        type: Constants.geojsonTypes.FEATURE,\n        properties: geojson.properties,\n        geometry: {\n          type: subType,\n          coordinates: subCoordinates\n        }\n      };\n      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));\n    });\n  }\n\n  return supplementaryPoints;\n}\n\nexport default createSupplementaryPoints;\n","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","import * as Constants from '../constants.js';\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX,\n} = Constants;\nfunction extent(feature) {\n  const depth = {\n    Point: 0,\n    LineString: 1,\n    Polygon: 2,\n    MultiPoint: 1,\n    MultiLineString: 2,\n    MultiPolygon: 3,\n  }[feature.geometry.type];\n\n  const coords = [feature.geometry.coordinates].flat(depth);\n  const lngs = coords.map(coord => coord[0]);\n  const lats = coords.map(coord => coord[1]);\n  const min = vals => Math.min.apply(null, vals);\n  const max = vals => Math.max.apply(null, vals);\n  return [min(lngs), min(lats), max(lngs), max(lats)];\n}\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nexport default function(geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n\n  geojsonFeatures.forEach((feature) => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n}\n","import constrainFeatureMovement from './constrain_feature_movement.js';\nimport * as Constants from '../constants.js';\n\nexport default function(features, delta) {\n  const constrainedDelta = constrainFeatureMovement(features.map(feature => feature.toGeoJSON()), delta);\n\n  features.forEach((feature) => {\n    const currentCoordinates = feature.getCoordinates();\n\n    const moveCoordinate = (coord) => {\n      const point = {\n        lng: coord[0] + constrainedDelta.lng,\n        lat: coord[1] + constrainedDelta.lat\n      };\n      return [point.lng, point.lat];\n    };\n    const moveRing = ring => ring.map(coord => moveCoordinate(coord));\n    const moveMultiPolygon = multi => multi.map(ring => moveRing(ring));\n\n    let nextCoordinates;\n    if (feature.type === Constants.geojsonTypes.POINT) {\n      nextCoordinates = moveCoordinate(currentCoordinates);\n    } else if (feature.type === Constants.geojsonTypes.LINE_STRING || feature.type === Constants.geojsonTypes.MULTI_POINT) {\n      nextCoordinates = currentCoordinates.map(moveCoordinate);\n    } else if (feature.type === Constants.geojsonTypes.POLYGON || feature.type === Constants.geojsonTypes.MULTI_LINE_STRING) {\n      nextCoordinates = currentCoordinates.map(moveRing);\n    } else if (feature.type === Constants.geojsonTypes.MULTI_POLYGON) {\n      nextCoordinates = currentCoordinates.map(moveMultiPolygon);\n    }\n\n    feature.incomingCoords(nextCoordinates);\n  });\n}\n","import * as CommonSelectors from '../lib/common_selectors.js';\nimport mouseEventPoint from '../lib/mouse_event_point.js';\nimport createSupplementaryPoints from '../lib/create_supplementary_points.js';\nimport StringSet from '../lib/string_set.js';\nimport doubleClickZoom from '../lib/double_click_zoom.js';\nimport moveFeatures from '../lib/move_features.js';\nimport * as Constants from '../constants.js';\n\nconst SimpleSelect = {};\n\nSimpleSelect.onSetup = function(opts) {\n  // turn the opts into state.\n  const state = {\n    dragMoveLocation: null,\n    boxSelectStartLocation: null,\n    boxSelectElement: undefined,\n    boxSelecting: false,\n    canBoxSelect: false,\n    dragMoving: false,\n    canDragMove: false,\n    initialDragPanState: this.map.dragPan.isEnabled(),\n    initiallySelectedFeatureIds: opts.featureIds || []\n  };\n\n  this.setSelected(state.initiallySelectedFeatureIds.filter(id => this.getFeature(id) !== undefined));\n  this.fireActionable();\n\n  this.setActionableState({\n    combineFeatures: true,\n    uncombineFeatures: true,\n    trash: true\n  });\n\n  return state;\n};\n\nSimpleSelect.fireUpdate = function() {\n  this.fire(Constants.events.UPDATE, {\n    action: Constants.updateActions.MOVE,\n    features: this.getSelected().map(f => f.toGeoJSON())\n  });\n};\n\nSimpleSelect.fireActionable = function() {\n  const selectedFeatures = this.getSelected();\n\n  const multiFeatures = selectedFeatures.filter(\n    feature => this.isInstanceOf('MultiFeature', feature)\n  );\n\n  let combineFeatures = false;\n\n  if (selectedFeatures.length > 1) {\n    combineFeatures = true;\n    const featureType = selectedFeatures[0].type.replace('Multi', '');\n    selectedFeatures.forEach((feature) => {\n      if (feature.type.replace('Multi', '') !== featureType) {\n        combineFeatures = false;\n      }\n    });\n  }\n\n  const uncombineFeatures = multiFeatures.length > 0;\n  const trash = selectedFeatures.length > 0;\n\n  this.setActionableState({\n    combineFeatures, uncombineFeatures, trash\n  });\n};\n\nSimpleSelect.getUniqueIds = function(allFeatures) {\n  if (!allFeatures.length) return [];\n  const ids = allFeatures.map(s => s.properties.id)\n    .filter(id => id !== undefined)\n    .reduce((memo, id) => {\n      memo.add(id);\n      return memo;\n    }, new StringSet());\n\n  return ids.values();\n};\n\nSimpleSelect.stopExtendedInteractions = function(state) {\n  if (state.boxSelectElement) {\n    if (state.boxSelectElement.parentNode) state.boxSelectElement.parentNode.removeChild(state.boxSelectElement);\n    state.boxSelectElement = null;\n  }\n\n  if ((state.canDragMove || state.canBoxSelect) && state.initialDragPanState === true) {\n    this.map.dragPan.enable();\n  }\n\n  state.boxSelecting = false;\n  state.canBoxSelect = false;\n  state.dragMoving = false;\n  state.canDragMove = false;\n};\n\nSimpleSelect.onStop = function() {\n  doubleClickZoom.enable(this);\n};\n\nSimpleSelect.onMouseMove = function(state, e) {\n  const isFeature = CommonSelectors.isFeature(e);\n  if (isFeature && state.dragMoving) this.fireUpdate();\n\n  // On mousemove that is not a drag, stop extended interactions.\n  // This is useful if you drag off the canvas, release the button,\n  // then move the mouse back over the canvas --- we don't allow the\n  // interaction to continue then, but we do let it continue if you held\n  // the mouse button that whole time\n  this.stopExtendedInteractions(state);\n\n  // Skip render\n  return true;\n};\n\nSimpleSelect.onMouseOut = function(state) {\n  // As soon as you mouse leaves the canvas, update the feature\n  if (state.dragMoving) return this.fireUpdate();\n\n  // Skip render\n  return true;\n};\n\nSimpleSelect.onTap = SimpleSelect.onClick = function(state, e) {\n  // Click (with or without shift) on no feature\n  if (CommonSelectors.noTarget(e)) return this.clickAnywhere(state, e); // also tap\n  if (CommonSelectors.isOfMetaType(Constants.meta.VERTEX)(e)) return this.clickOnVertex(state, e); //tap\n  if (CommonSelectors.isFeature(e)) return this.clickOnFeature(state, e);\n};\n\nSimpleSelect.clickAnywhere = function (state) {\n  // Clear the re-render selection\n  const wasSelected = this.getSelectedIds();\n  if (wasSelected.length) {\n    this.clearSelectedFeatures();\n    wasSelected.forEach(id => this.doRender(id));\n  }\n  doubleClickZoom.enable(this);\n  this.stopExtendedInteractions(state);\n};\n\nSimpleSelect.clickOnVertex = function(state, e) {\n  // Enter direct select mode\n  this.changeMode(Constants.modes.DIRECT_SELECT, {\n    featureId: e.featureTarget.properties.parent,\n    coordPath: e.featureTarget.properties.coord_path,\n    startPos: e.lngLat\n  });\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n};\n\nSimpleSelect.startOnActiveFeature = function(state, e) {\n  // Stop any already-underway extended interactions\n  this.stopExtendedInteractions(state);\n\n  // Disable map.dragPan immediately so it can't start\n  this.map.dragPan.disable();\n\n  // Re-render it and enable drag move\n  this.doRender(e.featureTarget.properties.id);\n\n  // Set up the state for drag moving\n  state.canDragMove = true;\n  state.dragMoveLocation = e.lngLat;\n};\n\nSimpleSelect.clickOnFeature = function(state, e) {\n  // Stop everything\n  doubleClickZoom.disable(this);\n  this.stopExtendedInteractions(state);\n\n  const isShiftClick = CommonSelectors.isShiftDown(e);\n  const selectedFeatureIds = this.getSelectedIds();\n  const featureId = e.featureTarget.properties.id;\n  const isFeatureSelected = this.isSelected(featureId);\n\n  // Click (without shift) on any selected feature but a point\n  if (!isShiftClick && isFeatureSelected && this.getFeature(featureId).type !== Constants.geojsonTypes.POINT) {\n    // Enter direct select mode\n    return this.changeMode(Constants.modes.DIRECT_SELECT, {\n      featureId\n    });\n  }\n\n  // Shift-click on a selected feature\n  if (isFeatureSelected && isShiftClick) {\n    // Deselect it\n    this.deselect(featureId);\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n    if (selectedFeatureIds.length === 1) {\n      doubleClickZoom.enable(this);\n    }\n  // Shift-click on an unselected feature\n  } else if (!isFeatureSelected && isShiftClick) {\n    // Add it to the selection\n    this.select(featureId);\n    this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  // Click (without shift) on an unselected feature\n  } else if (!isFeatureSelected && !isShiftClick) {\n    // Make it the only selected feature\n    selectedFeatureIds.forEach(id => this.doRender(id));\n    this.setSelected(featureId);\n    this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  }\n\n  // No matter what, re-render the clicked feature\n  this.doRender(featureId);\n};\n\nSimpleSelect.onMouseDown = function(state, e) {\n  state.initialDragPanState = this.map.dragPan.isEnabled();\n  if (CommonSelectors.isActiveFeature(e)) return this.startOnActiveFeature(state, e);\n  if (this.drawConfig.boxSelect && CommonSelectors.isShiftMousedown(e)) return this.startBoxSelect(state, e);\n};\n\nSimpleSelect.startBoxSelect = function(state, e) {\n  this.stopExtendedInteractions(state);\n  this.map.dragPan.disable();\n  // Enable box select\n  state.boxSelectStartLocation = mouseEventPoint(e.originalEvent, this.map.getContainer());\n  state.canBoxSelect = true;\n};\n\nSimpleSelect.onTouchStart = function(state, e) {\n  if (CommonSelectors.isActiveFeature(e)) return this.startOnActiveFeature(state, e);\n};\n\nSimpleSelect.onDrag = function(state, e) {\n  if (state.canDragMove) return this.dragMove(state, e);\n  if (this.drawConfig.boxSelect && state.canBoxSelect) return this.whileBoxSelect(state, e);\n};\n\nSimpleSelect.whileBoxSelect = function(state, e) {\n  state.boxSelecting = true;\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n\n  // Create the box node if it doesn't exist\n  if (!state.boxSelectElement) {\n    state.boxSelectElement = document.createElement('div');\n    state.boxSelectElement.classList.add(Constants.classes.BOX_SELECT);\n    this.map.getContainer().appendChild(state.boxSelectElement);\n  }\n\n  // Adjust the box node's width and xy position\n  const current = mouseEventPoint(e.originalEvent, this.map.getContainer());\n  const minX = Math.min(state.boxSelectStartLocation.x, current.x);\n  const maxX = Math.max(state.boxSelectStartLocation.x, current.x);\n  const minY = Math.min(state.boxSelectStartLocation.y, current.y);\n  const maxY = Math.max(state.boxSelectStartLocation.y, current.y);\n  const translateValue = `translate(${minX}px, ${minY}px)`;\n  state.boxSelectElement.style.transform = translateValue;\n  state.boxSelectElement.style.WebkitTransform = translateValue;\n  state.boxSelectElement.style.width = `${maxX - minX}px`;\n  state.boxSelectElement.style.height = `${maxY - minY}px`;\n};\n\nSimpleSelect.dragMove = function(state, e) {\n  // Dragging when drag move is enabled\n  state.dragMoving = true;\n  e.originalEvent.stopPropagation();\n\n  const delta = {\n    lng: e.lngLat.lng - state.dragMoveLocation.lng,\n    lat: e.lngLat.lat - state.dragMoveLocation.lat\n  };\n\n  moveFeatures(this.getSelected(), delta);\n\n  state.dragMoveLocation = e.lngLat;\n};\n\nSimpleSelect.onTouchEnd = SimpleSelect.onMouseUp = function(state, e) {\n  // End any extended interactions\n  if (state.dragMoving) {\n    this.fireUpdate();\n  } else if (state.boxSelecting) {\n    const bbox = [\n      state.boxSelectStartLocation,\n      mouseEventPoint(e.originalEvent, this.map.getContainer())\n    ];\n    const featuresInBox = this.featuresAt(null, bbox, 'click');\n    const idsToSelect = this.getUniqueIds(featuresInBox)\n      .filter(id => !this.isSelected(id));\n\n    if (idsToSelect.length) {\n      this.select(idsToSelect);\n      idsToSelect.forEach(id => this.doRender(id));\n      this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n    }\n  }\n  this.stopExtendedInteractions(state);\n};\n\nSimpleSelect.toDisplayFeatures = function(state, geojson, display) {\n  geojson.properties.active = (this.isSelected(geojson.properties.id)) ?\n    Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  display(geojson);\n  this.fireActionable();\n  if (geojson.properties.active !== Constants.activeStates.ACTIVE ||\n    geojson.geometry.type === Constants.geojsonTypes.POINT) return;\n  createSupplementaryPoints(geojson).forEach(display);\n};\n\nSimpleSelect.onTrash = function() {\n  this.deleteFeature(this.getSelectedIds());\n  this.fireActionable();\n};\n\nSimpleSelect.onCombineFeatures = function() {\n  const selectedFeatures = this.getSelected();\n\n  if (selectedFeatures.length === 0 || selectedFeatures.length < 2) return;\n\n  const coordinates = [], featuresCombined = [];\n  const featureType = selectedFeatures[0].type.replace('Multi', '');\n\n  for (let i = 0; i < selectedFeatures.length; i++) {\n    const feature = selectedFeatures[i];\n\n    if (feature.type.replace('Multi', '') !== featureType) {\n      return;\n    }\n    if (feature.type.includes('Multi')) {\n      feature.getCoordinates().forEach((subcoords) => {\n        coordinates.push(subcoords);\n      });\n    } else {\n      coordinates.push(feature.getCoordinates());\n    }\n\n    featuresCombined.push(feature.toGeoJSON());\n  }\n\n  if (featuresCombined.length > 1) {\n    const multiFeature = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: featuresCombined[0].properties,\n      geometry: {\n        type: `Multi${featureType}`,\n        coordinates\n      }\n    });\n\n    this.addFeature(multiFeature);\n    this.deleteFeature(this.getSelectedIds(), { silent: true });\n    this.setSelected([multiFeature.id]);\n\n    this.fire(Constants.events.COMBINE_FEATURES, {\n      createdFeatures: [multiFeature.toGeoJSON()],\n      deletedFeatures: featuresCombined\n    });\n  }\n  this.fireActionable();\n};\n\nSimpleSelect.onUncombineFeatures = function() {\n  const selectedFeatures = this.getSelected();\n  if (selectedFeatures.length === 0) return;\n\n  const createdFeatures = [];\n  const featuresUncombined = [];\n\n  for (let i = 0; i < selectedFeatures.length; i++) {\n    const feature = selectedFeatures[i];\n\n    if (this.isInstanceOf('MultiFeature', feature)) {\n      feature.getFeatures().forEach((subFeature) => {\n        this.addFeature(subFeature);\n        subFeature.properties = feature.properties;\n        createdFeatures.push(subFeature.toGeoJSON());\n        this.select([subFeature.id]);\n      });\n      this.deleteFeature(feature.id, { silent: true });\n      featuresUncombined.push(feature.toGeoJSON());\n    }\n  }\n\n  if (createdFeatures.length > 1) {\n    this.fire(Constants.events.UNCOMBINE_FEATURES, {\n      createdFeatures,\n      deletedFeatures: featuresUncombined\n    });\n  }\n  this.fireActionable();\n};\n\nexport default SimpleSelect;\n","import { noTarget, isOfMetaType, isActiveFeature, isInactiveFeature, isShiftDown } from '../lib/common_selectors.js';\nimport createSupplementaryPoints from '../lib/create_supplementary_points.js';\nimport constrainFeatureMovement from '../lib/constrain_feature_movement.js';\nimport doubleClickZoom from '../lib/double_click_zoom.js';\nimport * as Constants from '../constants.js';\nimport moveFeatures from '../lib/move_features.js';\n\nconst isVertex = isOfMetaType(Constants.meta.VERTEX);\nconst isMidpoint = isOfMetaType(Constants.meta.MIDPOINT);\n\nconst DirectSelect = {};\n\n// INTERNAL FUCNTIONS\n\nDirectSelect.fireUpdate = function() {\n  this.fire(Constants.events.UPDATE, {\n    action: Constants.updateActions.CHANGE_COORDINATES,\n    features: this.getSelected().map(f => f.toGeoJSON())\n  });\n};\n\nDirectSelect.fireActionable = function(state) {\n  this.setActionableState({\n    combineFeatures: false,\n    uncombineFeatures: false,\n    trash: state.selectedCoordPaths.length > 0\n  });\n};\n\nDirectSelect.startDragging = function(state, e) {\n  state.initialDragPanState = this.map.dragPan.isEnabled();\n\n  this.map.dragPan.disable();\n  state.canDragMove = true;\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.stopDragging = function(state) {\n  if (state.canDragMove && state.initialDragPanState === true) {\n    this.map.dragPan.enable();\n  }\n  state.dragMoving = false;\n  state.canDragMove = false;\n  state.dragMoveLocation = null;\n};\n\nDirectSelect.onVertex = function (state, e) {\n  this.startDragging(state, e);\n  const about = e.featureTarget.properties;\n  const selectedIndex = state.selectedCoordPaths.indexOf(about.coord_path);\n  if (!isShiftDown(e) && selectedIndex === -1) {\n    state.selectedCoordPaths = [about.coord_path];\n  } else if (isShiftDown(e) && selectedIndex === -1) {\n    state.selectedCoordPaths.push(about.coord_path);\n  }\n\n  const selectedCoordinates = this.pathsToCoordinates(state.featureId, state.selectedCoordPaths);\n  this.setSelectedCoordinates(selectedCoordinates);\n};\n\nDirectSelect.onMidpoint = function(state, e) {\n  this.startDragging(state, e);\n  const about = e.featureTarget.properties;\n  state.feature.addCoordinate(about.coord_path, about.lng, about.lat);\n  this.fireUpdate();\n  state.selectedCoordPaths = [about.coord_path];\n};\n\nDirectSelect.pathsToCoordinates = function(featureId, paths) {\n  return paths.map(coord_path => ({ feature_id: featureId, coord_path }));\n};\n\nDirectSelect.onFeature = function(state, e) {\n  if (state.selectedCoordPaths.length === 0) this.startDragging(state, e);\n  else this.stopDragging(state);\n};\n\nDirectSelect.dragFeature = function(state, e, delta) {\n  moveFeatures(this.getSelected(), delta);\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.dragVertex = function(state, e, delta) {\n  const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));\n  const selectedCoordPoints = selectedCoords.map(coords => ({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: coords\n    }\n  }));\n\n  const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);\n  for (let i = 0; i < selectedCoords.length; i++) {\n    const coord = selectedCoords[i];\n    state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);\n  }\n};\n\nDirectSelect.clickNoTarget = function () {\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDirectSelect.clickInactive = function () {\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDirectSelect.clickActiveFeature = function (state) {\n  state.selectedCoordPaths = [];\n  this.clearSelectedCoordinates();\n  state.feature.changed();\n};\n\n// EXTERNAL FUNCTIONS\n\nDirectSelect.onSetup = function(opts) {\n  const featureId = opts.featureId;\n  const feature = this.getFeature(featureId);\n\n  if (!feature) {\n    throw new Error('You must provide a featureId to enter direct_select mode');\n  }\n\n  if (feature.type === Constants.geojsonTypes.POINT) {\n    throw new TypeError('direct_select mode doesn\\'t handle point features');\n  }\n\n  const state = {\n    featureId,\n    feature,\n    dragMoveLocation: opts.startPos || null,\n    dragMoving: false,\n    canDragMove: false,\n    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : [],\n  };\n\n  this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));\n  this.setSelected(featureId);\n  doubleClickZoom.disable(this);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return state;\n};\n\nDirectSelect.onStop = function() {\n  doubleClickZoom.enable(this);\n  this.clearSelectedCoordinates();\n};\n\nDirectSelect.toDisplayFeatures = function(state, geojson, push) {\n  if (state.featureId === geojson.properties.id) {\n    geojson.properties.active = Constants.activeStates.ACTIVE;\n    push(geojson);\n    createSupplementaryPoints(geojson, {\n      map: this.map,\n      midpoints: true,\n      selectedPaths: state.selectedCoordPaths\n    }).forEach(push);\n  } else {\n    geojson.properties.active = Constants.activeStates.INACTIVE;\n    push(geojson);\n  }\n  this.fireActionable(state);\n};\n\nDirectSelect.onTrash = function(state) {\n  // Uses number-aware sorting to make sure '9' < '10'. Comparison is reversed because we want them\n  // in reverse order so that we can remove by index safely.\n  state.selectedCoordPaths\n    .sort((a, b) => b.localeCompare(a, 'en', { numeric: true }))\n    .forEach(id => state.feature.removeCoordinate(id));\n  this.fireUpdate();\n  state.selectedCoordPaths = [];\n  this.clearSelectedCoordinates();\n  this.fireActionable(state);\n  if (state.feature.isValid() === false) {\n    this.deleteFeature([state.featureId]);\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {});\n  }\n};\n\nDirectSelect.onMouseMove = function(state, e) {\n  // On mousemove that is not a drag, stop vertex movement.\n  const isFeature = isActiveFeature(e);\n  const onVertex = isVertex(e);\n  const isMidPoint = isMidpoint(e);\n  const noCoords = state.selectedCoordPaths.length === 0;\n  if (isFeature && noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  else if (onVertex && !noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  else this.updateUIClasses({ mouse: Constants.cursors.NONE });\n\n  const isDraggableItem = onVertex || isFeature || isMidPoint;\n  if (isDraggableItem && state.dragMoving) this.fireUpdate();\n\n  this.stopDragging(state);\n\n  // Skip render\n  return true;\n};\n\nDirectSelect.onMouseOut = function(state) {\n  // As soon as you mouse leaves the canvas, update the feature\n  if (state.dragMoving) this.fireUpdate();\n\n  // Skip render\n  return true;\n};\n\nDirectSelect.onTouchStart = DirectSelect.onMouseDown = function(state, e) {\n  if (isVertex(e)) return this.onVertex(state, e);\n  if (isActiveFeature(e)) return this.onFeature(state, e);\n  if (isMidpoint(e)) return this.onMidpoint(state, e);\n};\n\nDirectSelect.onDrag = function(state, e) {\n  if (state.canDragMove !== true) return;\n  state.dragMoving = true;\n  e.originalEvent.stopPropagation();\n\n  const delta = {\n    lng: e.lngLat.lng - state.dragMoveLocation.lng,\n    lat: e.lngLat.lat - state.dragMoveLocation.lat\n  };\n  if (state.selectedCoordPaths.length > 0) this.dragVertex(state, e, delta);\n  else this.dragFeature(state, e, delta);\n\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.onClick = function(state, e) {\n  if (noTarget(e)) return this.clickNoTarget(state, e);\n  if (isActiveFeature(e)) return this.clickActiveFeature(state, e);\n  if (isInactiveFeature(e)) return this.clickInactive(state, e);\n  this.stopDragging(state);\n};\n\nDirectSelect.onTap = function(state, e) {\n  if (noTarget(e)) return this.clickNoTarget(state, e);\n  if (isActiveFeature(e)) return this.clickActiveFeature(state, e);\n  if (isInactiveFeature(e)) return this.clickInactive(state, e);\n};\n\nDirectSelect.onTouchEnd = DirectSelect.onMouseUp = function(state) {\n  if (state.dragMoving) {\n    this.fireUpdate();\n  }\n  this.stopDragging(state);\n};\n\nexport default DirectSelect;\n\n","import * as CommonSelectors from '../lib/common_selectors.js';\nimport * as Constants from '../constants.js';\n\nconst DrawPoint = {};\n\nDrawPoint.onSetup = function() {\n  const point = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: []\n    }\n  });\n\n  this.addFeature(point);\n\n  this.clearSelectedFeatures();\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POINT);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return { point };\n};\n\nDrawPoint.stopDrawingAndRemove = function(state) {\n  this.deleteFeature([state.point.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawPoint.onTap = DrawPoint.onClick = function(state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);\n  this.fire(Constants.events.CREATE, {\n    features: [state.point.toGeoJSON()]\n  });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });\n};\n\nDrawPoint.onStop = function(state) {\n  this.activateUIButton();\n  if (!state.point.getCoordinate().length) {\n    this.deleteFeature([state.point.id], { silent: true });\n  }\n};\n\nDrawPoint.toDisplayFeatures = function(state, geojson, display) {\n  // Never render the point we're drawing\n  const isActivePoint = geojson.properties.id === state.point.id;\n  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePoint) return display(geojson);\n};\n\nDrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;\n\nDrawPoint.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {\n    return this.stopDrawingAndRemove(state, e);\n  }\n};\n\nexport default DrawPoint;\n","function isEventAtCoordinates(event, coordinates) {\n  if (!event.lngLat) return false;\n  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];\n}\n\nexport default isEventAtCoordinates;\n","import * as CommonSelectors from '../lib/common_selectors.js';\nimport doubleClickZoom from '../lib/double_click_zoom.js';\nimport * as Constants from '../constants.js';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates.js';\nimport createVertex from '../lib/create_vertex.js';\n\nconst DrawPolygon = {};\n\nDrawPolygon.onSetup = function() {\n  const polygon = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[]]\n    }\n  });\n\n  this.addFeature(polygon);\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POLYGON);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    polygon,\n    currentVertexPosition: 0\n  };\n};\n\nDrawPolygon.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  state.currentVertexPosition++;\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n};\n\nDrawPolygon.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n};\n\nDrawPolygon.onMouseMove = function(state, e) {\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  return this.clickAnywhere(state, e);\n};\n\nDrawPolygon.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n};\n\nDrawPolygon.onStop = function(state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.polygon.id) === undefined) return;\n\n  //remove last added coordinate\n  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);\n  if (state.polygon.isValid()) {\n    this.fire(Constants.events.CREATE, {\n      features: [state.polygon.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawPolygon.toDisplayFeatures = function(state, geojson, display) {\n  const isActivePolygon = geojson.properties.id === state.polygon.id;\n  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePolygon) return display(geojson);\n\n  // Don't render a polygon until it has two positions\n  // (and a 3rd which is just the first repeated)\n  if (geojson.geometry.coordinates.length === 0) return;\n\n  const coordinateCount = geojson.geometry.coordinates[0].length;\n  // 2 coordinates after selecting a draw type\n  // 3 after creating the first point\n  if (coordinateCount < 3) {\n    return;\n  }\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));\n  if (coordinateCount > 3) {\n    // Add a start position marker to the map, clicking on this will finish the feature\n    // This should only be shown when we're in a valid spot\n    const endPos = geojson.geometry.coordinates[0].length - 3;\n    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));\n  }\n  if (coordinateCount <= 4) {\n    // If we've only drawn two positions (plus the closer),\n    // make a LineString instead of a Polygon\n    const lineCoordinates = [\n      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]\n    ];\n    // create an initial vertex so that we can track the first point on mobile devices\n    display({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: geojson.properties,\n      geometry: {\n        coordinates: lineCoordinates,\n        type: Constants.geojsonTypes.LINE_STRING\n      }\n    });\n    if (coordinateCount === 3) {\n      return;\n    }\n  }\n  // render the Polygon\n  return display(geojson);\n};\n\nDrawPolygon.onTrash = function(state) {\n  this.deleteFeature([state.polygon.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nexport default DrawPolygon;\n","import * as CommonSelectors from '../lib/common_selectors.js';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates.js';\nimport doubleClickZoom from '../lib/double_click_zoom.js';\nimport * as Constants from '../constants.js';\nimport createVertex from '../lib/create_vertex.js';\n\nconst DrawLineString = {};\n\nDrawLineString.onSetup = function(opts) {\n  opts = opts || {};\n  const featureId = opts.featureId;\n\n  let line, currentVertexPosition;\n  let direction = 'forward';\n  if (featureId) {\n    line = this.getFeature(featureId);\n    if (!line) {\n      throw new Error('Could not find a feature with the provided featureId');\n    }\n    let from = opts.from;\n    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {\n      from = from.geometry;\n    }\n    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {\n      from = from.coordinates;\n    }\n    if (!from || !Array.isArray(from)) {\n      throw new Error('Please use the `from` property to indicate which point to continue the line from');\n    }\n    const lastCoord = line.coordinates.length - 1;\n    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {\n      currentVertexPosition = lastCoord + 1;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);\n    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {\n      direction = 'backwards';\n      currentVertexPosition = 0;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);\n    } else {\n      throw new Error('`from` should match the point at either the start or the end of the provided LineString');\n    }\n  } else {\n    line = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: {},\n      geometry: {\n        type: Constants.geojsonTypes.LINE_STRING,\n        coordinates: []\n      }\n    });\n    currentVertexPosition = 0;\n    this.addFeature(line);\n  }\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.LINE);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    line,\n    currentVertexPosition,\n    direction\n  };\n};\n\nDrawLineString.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||\n      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (state.direction === 'forward') {\n    state.currentVertexPosition++;\n    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  } else {\n    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);\n  }\n};\n\nDrawLineString.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n};\n\nDrawLineString.onMouseMove = function(state, e) {\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawLineString.onTap = DrawLineString.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  this.clickAnywhere(state, e);\n};\n\nDrawLineString.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  } else if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nDrawLineString.onStop = function(state) {\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.line.id) === undefined) return;\n\n  //remove last added coordinate\n  state.line.removeCoordinate(`${state.currentVertexPosition}`);\n  if (state.line.isValid()) {\n    this.fire(Constants.events.CREATE, {\n      features: [state.line.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawLineString.onTrash = function(state) {\n  this.deleteFeature([state.line.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawLineString.toDisplayFeatures = function(state, geojson, display) {\n  const isActiveLine = geojson.properties.id === state.line.id;\n  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActiveLine) return display(geojson);\n  // Only render the line if it has at least one real coordinate\n  if (geojson.geometry.coordinates.length < 2) return;\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(\n    state.line.id,\n    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],\n    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,\n    false\n  ));\n\n  display(geojson);\n};\n\nexport default DrawLineString;\n","\nimport simple_select from './simple_select.js';\nimport direct_select from './direct_select.js';\nimport draw_point from './draw_point.js';\nimport draw_polygon from './draw_polygon.js';\nimport draw_line_string from './draw_line_string.js';\n\nexport default {\n  simple_select,\n  direct_select,\n  draw_point,\n  draw_polygon,\n  draw_line_string,\n};\n","import * as Constants from './constants.js';\n\nimport styles from './lib/theme.js';\nimport modes from './modes/index.js';\n\nconst defaultOptions = {\n  defaultMode: Constants.modes.SIMPLE_SELECT,\n  keybindings: true,\n  touchEnabled: true,\n  clickBuffer: 2,\n  touchBuffer: 25,\n  boxSelect: true,\n  displayControlsDefault: true,\n  styles,\n  modes,\n  controls: {},\n  userProperties: false,\n  suppressAPIEvents: true\n};\n\nconst showControls = {\n  point: true,\n  line_string: true,\n  polygon: true,\n  trash: true,\n  combine_features: true,\n  uncombine_features: true\n};\n\nconst hideControls = {\n  point: false,\n  line_string: false,\n  polygon: false,\n  trash: false,\n  combine_features: false,\n  uncombine_features: false\n};\n\nfunction addSources(styles, sourceBucket) {\n  return styles.map((style) => {\n    if (style.source) return style;\n    return Object.assign({}, style, {\n      id: `${style.id}.${sourceBucket}`,\n      source: (sourceBucket === 'hot') ? Constants.sources.HOT : Constants.sources.COLD\n    });\n  });\n}\n\nexport default function(options = {}) {\n  let withDefaults = Object.assign({}, options);\n\n  if (!options.controls) {\n    withDefaults.controls = {};\n  }\n\n  if (options.displayControlsDefault === false) {\n    withDefaults.controls = Object.assign({}, hideControls, options.controls);\n  } else {\n    withDefaults.controls = Object.assign({}, showControls, options.controls);\n  }\n\n  withDefaults = Object.assign({}, defaultOptions, withDefaults);\n\n  // Layers with a shared source should be adjacent for performance reasons\n  withDefaults.styles = addSources(withDefaults.styles, 'cold').concat(addSources(withDefaults.styles, 'hot'));\n\n  return withDefaults;\n}\n","export default function(a, b) {\n  if (a.length !== b.length) return false;\n  return JSON.stringify(a.map(id => id).sort()) === JSON.stringify(b.map(id => id).sort());\n}\n","import isEqual from 'fast-deep-equal';\nimport normalize from '@mapbox/geojson-normalize';\nimport {generateID} from './lib/id.js';\nimport featuresAt from './lib/features_at.js';\nimport stringSetsAreEqual from './lib/string_sets_are_equal.js';\nimport * as Constants from './constants.js';\nimport StringSet from './lib/string_set.js';\n\nimport Polygon from './feature_types/polygon.js';\nimport LineString from './feature_types/line_string.js';\nimport Point from './feature_types/point.js';\nimport MultiFeature from './feature_types/multi_feature.js';\n\nconst featureTypes = {\n  Polygon,\n  LineString,\n  Point,\n  MultiPolygon: MultiFeature,\n  MultiLineString: MultiFeature,\n  MultiPoint: MultiFeature\n};\n\nexport default function(ctx, api) {\n  api.modes = Constants.modes;\n\n  // API doesn't emit events by default\n  const silent = ctx.options.suppressAPIEvents !== undefined ? !!ctx.options.suppressAPIEvents : true;\n\n  api.getFeatureIdsAt = function(point) {\n    const features = featuresAt.click({ point }, null, ctx);\n    return features.map(feature => feature.properties.id);\n  };\n\n  api.getSelectedIds = function() {\n    return ctx.store.getSelectedIds();\n  };\n\n  api.getSelected = function() {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.getSelectedPoints = function() {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedCoordinates().map(coordinate => ({\n        type: Constants.geojsonTypes.FEATURE,\n        properties: {},\n        geometry: {\n          type: Constants.geojsonTypes.POINT,\n          coordinates: coordinate.coordinates\n        }\n      }))\n    };\n  };\n\n  api.set = function(featureCollection) {\n    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {\n      throw new Error('Invalid FeatureCollection');\n    }\n    const renderBatch = ctx.store.createRenderBatch();\n    let toDelete = ctx.store.getAllIds().slice();\n    const newIds = api.add(featureCollection);\n    const newIdsLookup = new StringSet(newIds);\n\n    toDelete = toDelete.filter(id => !newIdsLookup.has(id));\n    if (toDelete.length) {\n      api.delete(toDelete);\n    }\n\n    renderBatch();\n    return newIds;\n  };\n\n  api.add = function(geojson) {\n    const featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));\n\n    const ids = featureCollection.features.map((feature) => {\n      feature.id = feature.id || generateID();\n\n      if (feature.geometry === null) {\n        throw new Error('Invalid geometry: null');\n      }\n\n      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {\n        // If the feature has not yet been created ...\n        const Model = featureTypes[feature.geometry.type];\n        if (Model === undefined) {\n          throw new Error(`Invalid geometry type: ${feature.geometry.type}.`);\n        }\n        const internalFeature = new Model(ctx, feature);\n        ctx.store.add(internalFeature, { silent });\n      } else {\n        // If a feature of that id has already been created, and we are swapping it out ...\n        const internalFeature = ctx.store.get(feature.id);\n        const originalProperties = internalFeature.properties;\n        internalFeature.properties = feature.properties;\n        if (!isEqual(originalProperties, feature.properties)) {\n          ctx.store.featureChanged(internalFeature.id, { silent });\n        }\n        if (!isEqual(internalFeature.getCoordinates(), feature.geometry.coordinates)) {\n          internalFeature.incomingCoords(feature.geometry.coordinates);\n        }\n      }\n      return feature.id;\n    });\n\n    ctx.store.render();\n    return ids;\n  };\n\n\n  api.get = function(id) {\n    const feature = ctx.store.get(id);\n    if (feature) {\n      return feature.toGeoJSON();\n    }\n  };\n\n  api.getAll = function() {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getAll().map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.delete = function(featureIds) {\n    ctx.store.delete(featureIds, { silent });\n    // If we were in direct select mode and our selected feature no longer exists\n    // (because it was deleted), we need to get out of that mode.\n    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.deleteAll = function() {\n    ctx.store.delete(ctx.store.getAllIds(), { silent });\n    // If we were in direct select mode, now our selected feature no longer exists,\n    // so escape that mode.\n    if (api.getMode() === Constants.modes.DIRECT_SELECT) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.changeMode = function(mode, modeOptions = {}) {\n    // Avoid changing modes just to re-select what's already selected\n    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {\n      if (stringSetsAreEqual((modeOptions.featureIds || []), ctx.store.getSelectedIds())) return api;\n      // And if we are changing the selection within simple_select mode, just change the selection,\n      // instead of stopping and re-starting the mode\n      ctx.store.setSelected(modeOptions.featureIds, { silent });\n      ctx.store.render();\n      return api;\n    }\n\n    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT &&\n      modeOptions.featureId === ctx.store.getSelectedIds()[0]) {\n      return api;\n    }\n\n    ctx.events.changeMode(mode, modeOptions, { silent });\n    return api;\n  };\n\n  api.getMode = function() {\n    return ctx.events.getMode();\n  };\n\n  api.trash = function() {\n    ctx.events.trash({ silent });\n    return api;\n  };\n\n  api.combineFeatures = function() {\n    ctx.events.combineFeatures({ silent });\n    return api;\n  };\n\n  api.uncombineFeatures = function() {\n    ctx.events.uncombineFeatures({ silent });\n    return api;\n  };\n\n  api.setFeatureProperty = function(featureId, property, value) {\n    ctx.store.setFeatureProperty(featureId, property, value, { silent });\n    return api;\n  };\n\n  return api;\n}\n","import runSetup from './src/setup.js';\nimport setupOptions from './src/options.js';\nimport setupAPI from './src/api.js';\nimport modes from './src/modes/index.js';\nimport * as Constants from './src/constants.js';\nimport * as lib from './src/lib/index.js';\n\nconst setupDraw = function(options, api) {\n  options = setupOptions(options);\n\n  const ctx = {\n    options\n  };\n\n  api = setupAPI(ctx, api);\n  ctx.api = api;\n\n  const setup = runSetup(ctx);\n\n  api.onAdd = setup.onAdd;\n  api.onRemove = setup.onRemove;\n  api.types = Constants.types;\n  api.options = options;\n\n  return api;\n};\n\nfunction MapboxDraw(options) {\n  setupDraw(options, this);\n}\n\nMapboxDraw.modes = modes;\nMapboxDraw.constants = Constants;\nMapboxDraw.lib = lib;\n\nexport default MapboxDraw;\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity,\n    });\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop_1 = point(coords[i + 1]);\n            stop_1.properties.dist = distance(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing(start, stop_1);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(lineString([\n                perpendicularPt1.geometry.coordinates,\n                perpendicularPt2.geometry.coordinates,\n            ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location =\n                    length + distance(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt &&\n                intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexport default nearestPointOnLine;\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Takes a reference {@link Point|point} and a FeatureCollection of Features\n * with Point geometries and returns the\n * point from the FeatureCollection closest to the reference. This calculation\n * is geodesic.\n *\n * @name nearestPoint\n * @param {Coord} targetPoint the reference point\n * @param {FeatureCollection<Point>} points against input point set\n * @returns {Feature<Point>} the closest point in the set to the reference point\n * @example\n * var targetPoint = turf.point([28.965797, 41.010086], {\"marker-color\": \"#0F0\"});\n * var points = turf.featureCollection([\n *     turf.point([28.973865, 41.011122]),\n *     turf.point([28.948459, 41.024204]),\n *     turf.point([28.938674, 41.013324])\n * ]);\n *\n * var nearest = turf.nearestPoint(targetPoint, points);\n *\n * //addToMap\n * var addToMap = [targetPoint, points, nearest];\n * nearest.properties['marker-color'] = '#F00';\n */\nfunction nearestPoint(targetPoint, points) {\n    // Input validation\n    if (!targetPoint)\n        throw new Error(\"targetPoint is required\");\n    if (!points)\n        throw new Error(\"points is required\");\n    var nearest;\n    var minDist = Infinity;\n    var bestFeatureIndex = 0;\n    featureEach(points, function (pt, featureIndex) {\n        var distanceToPoint = distance(targetPoint, pt);\n        if (distanceToPoint < minDist) {\n            bestFeatureIndex = featureIndex;\n            minDist = distanceToPoint;\n        }\n    });\n    nearest = clone(points.features[bestFeatureIndex]);\n    nearest.properties.featureIndex = bestFeatureIndex;\n    nearest.properties.distanceToPoint = minDist;\n    return nearest;\n}\nexport default nearestPoint;\n","import bearing from '@turf/bearing';\nimport destination from '@turf/destination';\nimport distance from '@turf/distance';\n\n/**\n * Takes two {@link Point|points} and returns a point midway between them.\n * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.\n *\n * @name midpoint\n * @param {Coord} point1 first point\n * @param {Coord} point2 second point\n * @returns {Feature<Point>} a point midway between `pt1` and `pt2`\n * @example\n * var point1 = turf.point([144.834823, -37.771257]);\n * var point2 = turf.point([145.14244, -37.830937]);\n *\n * var midpoint = turf.midpoint(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2, midpoint];\n * midpoint.properties['marker-color'] = '#f00';\n */\nfunction midpoint(point1, point2) {\n  var dist = distance(point1, point2);\n  var heading = bearing(point1, point2);\n  var midpoint = destination(point1, dist / 2, heading);\n\n  return midpoint;\n}\n\nexport default midpoint;\n","// Heavily inspired from work of @davidgilbertson on Github and `leaflet-geoman` project.\nimport MapboxDraw from \"@mapbox/mapbox-gl-draw\";\n\nconst { geojsonTypes } = MapboxDraw.constants;\n\nimport bboxPolygon from \"@turf/bbox-polygon\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { getCoords } from \"@turf/invariant\";\nimport distance from \"@turf/distance\";\nimport polygonToLine from \"@turf/polygon-to-line\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport nearestPointInPointSet from \"@turf/nearest-point\";\nimport midpoint from \"@turf/midpoint\";\nimport {\n  featureCollection,\n  lineString as turfLineString,\n  point as turfPoint,\n} from \"@turf/helpers\";\n\nexport const IDS = {\n  VERTICAL_GUIDE: \"VERTICAL_GUIDE\",\n  HORIZONTAL_GUIDE: \"HORIZONTAL_GUIDE\",\n};\n\nexport const addPointTovertices = (\n  map,\n  vertices,\n  coordinates,\n  forceInclusion\n) => {\n  const { width: w, height: h } = map.getCanvas();\n  // Just add verteices of features currently visible in viewport\n  const { x, y } = map.project(coordinates);\n  const pointIsOnTheScreen = x > 0 && x < w && y > 0 && y < h;\n\n  // But do add off-screen points if forced (e.g. for the current feature)\n  // So features will always snap to their own points\n  if (pointIsOnTheScreen || forceInclusion) {\n    vertices.push(coordinates);\n  }\n};\n\nexport const createSnapList = (map, draw, currentFeature) => {\n  // Get all drawn features\n  const features = draw.getAll().features;\n  const snapList = [];\n\n  // Get current bbox as polygon\n  const bboxAsPolygon = (() => {\n    const canvas = map.getCanvas(),\n      w = canvas.width,\n      h = canvas.height,\n      cUL = map.unproject([0, 0]).toArray(),\n      cUR = map.unproject([w, 0]).toArray(),\n      cLR = map.unproject([w, h]).toArray(),\n      cLL = map.unproject([0, h]).toArray();\n\n    return bboxPolygon([cLL, cUR].flat());\n  })();\n\n  const vertices = [];\n\n  // Keeps vertices for drwing guides\n  const addVerticesTovertices = (coordinates, isCurrentFeature = false) => {\n    if (!Array.isArray(coordinates)) throw Error(\"Your array is not an array\");\n\n    if (Array.isArray(coordinates[0])) {\n      // coordinates is an array of arrays, we must go deeper\n      coordinates.forEach((coord) => {\n        addVerticesTovertices(coord);\n      });\n    } else {\n      // If not an array of arrays, only consider arrays with two items\n      if (coordinates.length === 2) {\n        addPointTovertices(map, vertices, coordinates, isCurrentFeature);\n      }\n    }\n  };\n\n  features.forEach((feature) => {\n    // For currentfeature\n    if (feature.id === currentFeature.id) {\n      if (currentFeature.type === geojsonTypes.POLYGON) {\n        // For the current polygon, the last two points are the mouse position and back home\n        // so we chop those off (else we get vertices showing where the user clicked, even\n        // if they were just panning the map)\n        addVerticesTovertices(\n          feature.geometry.coordinates[0].slice(0, -2),\n          true\n        );\n      }\n      return;\n    }\n\n    // If this is re-running because a user is moving the map, the features might include\n    // vertices or the last leg of a polygon\n    if (\n      feature.id === IDS.HORIZONTAL_GUIDE ||\n      feature.id === IDS.VERTICAL_GUIDE\n    )\n      return;\n\n    addVerticesTovertices(feature.geometry.coordinates);\n\n    // If feature is currently on viewport add to snap list\n    if (!booleanDisjoint(bboxAsPolygon, feature)) {\n      snapList.push(feature);\n    }\n  });\n\n  return [snapList, vertices];\n};\n\nconst getNearbyvertices = (vertices, coords) => {\n  const verticals = [];\n  const horizontals = [];\n\n  vertices.forEach((vertex) => {\n    verticals.push(vertex[0]);\n    horizontals.push(vertex[1]);\n  });\n\n  const nearbyVerticalGuide = verticals.find(\n    (px) => Math.abs(px - coords.lng) < 0.009\n  );\n\n  const nearbyHorizontalGuide = horizontals.find(\n    (py) => Math.abs(py - coords.lat) < 0.009\n  );\n\n  return {\n    verticalPx: nearbyVerticalGuide,\n    horizontalPx: nearbyHorizontalGuide,\n  };\n};\n\nconst calcLayerDistances = (lngLat, layer) => {\n  // the point P which we want to snap (probpably the marker that is dragged)\n  const P = [lngLat.lng, lngLat.lat];\n\n  // is this a marker?\n  const isMarker = layer.geometry.type === \"Point\";\n  // is it a polygon?\n  const isPolygon = layer.geometry.type === \"Polygon\";\n  // is it a multiPolygon?\n  const isMultiPolygon = layer.geometry.type === \"MultiPolygon\";\n  // is it a multiPoint?\n  const isMultiPoint = layer.geometry.type === \"MultiPoint\";\n\n  let lines = undefined;\n\n  // the coords of the layer\n  const latlngs = getCoords(layer);\n\n  if (isMarker) {\n    const [lng, lat] = latlngs;\n    // return the info for the marker, no more calculations needed\n    return {\n      latlng: { lng, lat },\n      distance: distance(latlngs, P),\n    };\n  }\n\n  if (isMultiPoint) {\n    const np = nearestPointInPointSet(\n      P,\n      featureCollection(latlngs.map((x) => turfPoint(x)))\n    );\n    const c = np.geometry.coordinates;\n    return {\n      latlng: { lng: c[0], lat: c[1] },\n      distance: np.properties.distanceToPoint,\n    };\n  }\n\n  if (isPolygon || isMultiPolygon) {\n    lines = polygonToLine(layer);\n  } else {\n    lines = layer;\n  }\n\n  let nearestPoint;\n  if (isPolygon) {\n    let lineStrings;\n    if (lines.geometry.type === \"LineString\") {\n      lineStrings = [turfLineString(lines.geometry.coordinates)];\n    } else {\n      lineStrings = lines.geometry.coordinates.map((coords) =>\n        turfLineString(coords)\n      );\n    }\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n  } else if (isMultiPolygon) {\n    const lineStrings = lines.features\n      .map((feat) => {\n        if (feat.geometry.type === \"LineString\") {\n          return [feat.geometry.coordinates];\n        } else {\n          return feat.geometry.coordinates;\n        }\n      })\n      .flatMap((coords) => coords)\n      .map((coords) => turfLineString(coords));\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n  } else {\n    nearestPoint = nearestPointOnLine(lines, P);\n  }\n\n  const [lng, lat] = nearestPoint.geometry.coordinates;\n\n  let segmentIndex = nearestPoint.properties.index;\n  if (segmentIndex + 1 === lines.geometry.coordinates.length) segmentIndex--;\n\n  return {\n    latlng: { lng, lat },\n    segment: lines.geometry.coordinates.slice(segmentIndex, segmentIndex + 2),\n    distance: nearestPoint.properties.dist,\n    isMarker,\n  };\n};\n\nfunction getFeatureWithNearestPoint(lineStrings, P) {\n  const nearestPointsOfEachFeature = lineStrings.map((feat) => ({\n    feature: feat,\n    point: nearestPointOnLine(feat, P),\n  }));\n\n  nearestPointsOfEachFeature.sort(\n    (a, b) => a.point.properties.dist - b.point.properties.dist\n  );\n\n  return {\n    feature: nearestPointsOfEachFeature[0].feature,\n    point: nearestPointsOfEachFeature[0].point,\n  };\n}\n\nconst calcClosestLayer = (lngLat, layers) => {\n  let closestLayer = {};\n\n  // loop through the layers\n  layers.forEach((layer, index) => {\n    // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n    const results = calcLayerDistances(lngLat, layer);\n\n    // save the info if it doesn't exist or if the distance is smaller than the previous one\n    if (\n      closestLayer.distance === undefined ||\n      results.distance < closestLayer.distance\n    ) {\n      closestLayer = results;\n      closestLayer.layer = layer;\n    }\n  });\n\n  // return the closest layer and it's data\n  // if there is no closest layer, return undefined\n  return closestLayer;\n};\n\n// minimal distance before marker snaps (in pixels)\nconst metersPerPixel = function (latitude, zoomLevel) {\n  const earthCircumference = 40075017;\n  const latitudeRadians = latitude * (Math.PI / 180);\n  return (\n    (earthCircumference * Math.cos(latitudeRadians)) /\n    Math.pow(2, zoomLevel + 8)\n  );\n};\n\n// we got the point we want to snap to (C), but we need to check if a coord of the polygon\nfunction snapToLineOrPolygon(\n  closestLayer,\n  snapOptions,\n  lngLat\n) {\n  const { \n    snapToMidPoints = false,\n    snapToNodal = true,\n    snapToEndPoints = true,\n    snapToLines = true,\n    snapVertexPriorityDistance = 1.25\n  } = snapOptions ?? {};\n  const geometry = closestLayer.layer.geometry;\n  \n  // A and B are the points of the closest segment to P (the marker position we want to snap)\n  const A = closestLayer.segment[0];\n  const B = closestLayer.segment[1];\n\n  // C is the point we would snap to on the segment.\n  // The closest point on the closest segment of the closest polygon to P. That's right.\n  const C = [closestLayer.latlng.lng, closestLayer.latlng.lat];\n\n  // distances from A to C and B to C to check which one is closer to C\n  const distanceAC = distance(A, C);\n  const distanceBC = distance(B, C);\n\n  // closest latlng of A and B to C\n  let closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n  // distance between closestVertexLatLng and C\n  let shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n  // snap to middle (M) of segment if option is enabled\n  let isMiddlePoint = false;\n  if (snapToMidPoints) {\n    const M = midpoint(A, B).geometry.coordinates;\n    const distanceMC = distance(M, C);\n\n    if (distanceMC < distanceAC && distanceMC < distanceBC) {\n      // M is the nearest vertex\n      closestVertexLatLng = M;\n      shortestDistance = distanceMC;\n      isMiddlePoint = true\n    }\n  }\n\n  // the distance that needs to be undercut to trigger priority\n  const priorityDistance = snapVertexPriorityDistance;\n\n  // Coordinates of the endpoints of the line\n  const endPoints = geometry.type === \"LineString\" ? [geometry.coordinates[0], geometry.coordinates[geometry.coordinates.length - 1]] : [];\n  // Determine if it is an endpoint\n  const isEndPoint = endPoints.find((point) => {\n    return point[0] === closestVertexLatLng[0] && point[1] === closestVertexLatLng[1];\n  })\n\n  // the latlng we ultemately want to snap to\n  let snapLatlng;\n\n  // if C is closer to the closestVertexLatLng (A, B or M) than the snapDistance,\n  // the closestVertexLatLng has priority over C as the snapping point.\n  // C-points are used when the shortest distance is greater than or equal to the optimal distance and snapToLines is true, otherwise the lines are not snapped\n  if (shortestDistance >= priorityDistance) {\n    snapLatlng = snapToLines ? C : lngLat;\n  } else {\n    // If snapToNodal and snapToMidPoints and snapToEndPoints are not turned on, then no snapping is performed\n    // If snapToNodal and snapToMidPoints are not turned on, and if snapToEndPoints is turned on, then snap to endpoints\n    const shouldSnapToLngLat = !isMiddlePoint && !snapToNodal && \n      (snapToEndPoints && !isEndPoint || \n      !snapToEndPoints);\n    snapLatlng = shouldSnapToLngLat ? lngLat : closestVertexLatLng;\n  }\n\n  // return the copy of snapping point\n  const [lng, lat] = snapLatlng;\n  return { lng, lat };\n}\n\nfunction snapToPoint(closestLayer) {\n  return closestLayer.latlng;\n}\n\nconst checkPrioritiySnapping = (\n  closestLayer,\n  snapOptions,\n  lngLat\n) => {\n  let snappingToPoint = !Array.isArray(closestLayer.segment);\n  if (snappingToPoint) {\n    return snapToPoint(closestLayer);\n  } else {\n    return snapToLineOrPolygon(\n      closestLayer,\n      snapOptions,\n      lngLat\n    );\n  }\n};\n\n/**\n * Returns snap points if there are any, otherwise the original lng/lat of the event\n * Also, defines if vertices should show on the state object\n *\n * Mutates the state object\n *\n * @param state\n * @param e\n * @returns {{lng: number, lat: number}}\n */\nexport const snap = (state, e) => {\n  let lng = e.lngLat.lng;\n  let lat = e.lngLat.lat;\n\n  // Holding alt bypasses all snapping\n  if (e.originalEvent.altKey) {\n    state.showVerticalSnapLine = false;\n    state.showHorizontalSnapLine = false;\n\n    return { lng, lat };\n  }\n\n  if (state.snapList.length <= 0) {\n    return { lng, lat };\n  }\n\n  // snapping is on\n  let closestLayer, minDistance, snapLatLng;\n  if (state.options.snap) {\n    closestLayer = calcClosestLayer({ lng, lat }, state.snapList);\n\n    // if no layers found. Can happen when circle is the only visible layer on the map and the hidden snapping-border circle layer is also on the map\n    if (Object.keys(closestLayer).length === 0) {\n      return false;\n    }\n\n    const isMarker = closestLayer.isMarker;\n    if (!isMarker) {\n      snapLatLng = checkPrioritiySnapping(\n        closestLayer,\n        state.options.snapOptions,\n        [ lng, lat ]\n      );\n      // snapLatLng = closestLayer.latlng;\n    } else {\n      snapLatLng = closestLayer.latlng;\n    }\n\n    minDistance =\n      ((state.options.snapOptions && state.options.snapOptions.snapPx) || 15) *\n      metersPerPixel(snapLatLng.lat, state.map.getZoom());\n  }\n\n  let verticalPx, horizontalPx;\n  if (state.options.guides) {\n    const nearestGuidline = getNearbyvertices(state.vertices, e.lngLat);\n\n    verticalPx = nearestGuidline.verticalPx;\n    horizontalPx = nearestGuidline.horizontalPx;\n\n    if (verticalPx) {\n      // Draw a line from top to bottom\n\n      const lngLatTop = { lng: verticalPx, lat: e.lngLat.lat + 10 };\n      const lngLatBottom = { lng: verticalPx, lat: e.lngLat.lat - 10 };\n\n      state.verticalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.verticalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    if (horizontalPx) {\n      // Draw a line from left to right\n\n      const lngLatTop = { lng: e.lngLat.lng + 10, lat: horizontalPx };\n      const lngLatBottom = { lng: e.lngLat.lng - 10, lat: horizontalPx };\n\n      state.horizontalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.horizontalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    state.showVerticalSnapLine = !!verticalPx;\n    state.showHorizontalSnapLine = !!horizontalPx;\n  }\n\n  if (closestLayer && closestLayer.distance * 1000 < minDistance) {\n    return snapLatLng;\n  } else if (verticalPx || horizontalPx) {\n    if (verticalPx) {\n      lng = verticalPx;\n    }\n    if (horizontalPx) {\n      lat = horizontalPx;\n    }\n    return { lng, lat };\n  } else {\n    return { lng, lat };\n  }\n};\n\nexport const getGuideFeature = (id) => ({\n  id,\n  type: geojsonTypes.FEATURE,\n  properties: {\n    isSnapGuide: \"true\", // for styling\n  },\n  geometry: {\n    type: geojsonTypes.LINE_STRING,\n    coordinates: [],\n  },\n});\n\nexport const shouldHideGuide = (state, geojson) => {\n  if (\n    geojson.properties.id === IDS.VERTICAL_GUIDE &&\n    (!state.options.guides || !state.showVerticalSnapLine)\n  ) {\n    return true;\n  }\n\n  if (\n    geojson.properties.id === IDS.HORIZONTAL_GUIDE &&\n    (!state.options.guides || !state.showHorizontalSnapLine)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n","import { polygon } from \"@turf/helpers\";\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @name bboxPolygon\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @param {Object} [options={}] Optional parameters\n * @param {Properties} [options.properties={}] Translate properties to Polygon\n * @param {string|number} [options.id={}] Translate Id to Polygon\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nexport default function bboxPolygon(bbox, options) {\n    if (options === void 0) { options = {}; }\n    // Convert BBox positions to Numbers\n    // No performance loss for including Number()\n    // https://github.com/Turfjs/turf/issues/1119\n    var west = Number(bbox[0]);\n    var south = Number(bbox[1]);\n    var east = Number(bbox[2]);\n    var north = Number(bbox[3]);\n    if (bbox.length === 6) {\n        throw new Error(\"@turf/bbox-polygon does not support BBox with 6 positions\");\n    }\n    var lowLeft = [west, south];\n    var topLeft = [west, north];\n    var topRight = [east, north];\n    var lowRight = [east, south];\n    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox, id: options.id });\n}\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DrawPoint = MapboxDraw.modes.draw_point;\nconst { geojsonTypes, cursors } = MapboxDraw.constants;\n\nconst SnapPointMode = { ...DrawPoint };\n\nSnapPointMode.onSetup = function (options) {\n  const point = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POINT,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(point);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n\n  const state = {\n    map: this.map,\n    point,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  state.options = this._ctx.options;\n\n  const updateSnapList = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"updateSnapList\"] = updateSnapList;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", updateSnapList);\n  this.map.on(\"draw.snap.update_snapList\", updateSnapList);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPointMode.onClick = function (state) {\n  // We mock out e with the rounded lng/lat then call DrawPoint with it\n  DrawPoint.onClick.call(this, state, {\n    lngLat: {\n      lng: state.snappedLng,\n      lat: state.snappedLat,\n    },\n  });\n};\n\nSnapPointMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPoint.toDisplayFeatures\nSnapPointMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPoint.onStop\nSnapPointMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.updateSnapList);\n  // remove draw.snap.update_snapList callback\n  this.map.off(\"draw.snap.update_snapList\", state.updateSnapList);\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.onStop.call(this, state);\n};\n\nexport default SnapPointMode;\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nconst {\n  geojsonTypes,\n  modes,\n  cursors,\n} = MapboxDraw.constants;\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DrawLine = MapboxDraw.modes.draw_line_string;\n\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapLineMode = { ...DrawLine };\n\nSnapLineMode.onSetup = function (options) {\n  const line = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.LINE_STRING,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(line);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n\n  const state = {\n    map: this.map,\n    line,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n    direction: \"forward\", // expected by DrawLineString\n  };\n\n  state.options = this._ctx.options;\n\n  const updateSnapList = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"updateSnapList\"] = updateSnapList;\n\n  const optionsChangedCallBAck = (options) => {  \n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", updateSnapList);\n  this.map.on(\"draw.snap.update_snapList\", updateSnapList);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapLineMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  // Note: not bothering with 'direction'\n  if (state.currentVertexPosition > 0) {\n    const lastVertex = state.line.coordinates[state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.line.id],\n      });\n    }\n  }\n\n  // const point = state.map.project({ lng: lng, lat: lat });\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n};\n\nSnapLineMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawLine.toDisplayFeatures\nSnapLineMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawLine.onStop\nSnapLineMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.updateSnapList);\n  // remove draw.snap.update_snapList callback\n  this.map.off(\"draw.snap.update_snapList\", state.updateSnapList);\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.onStop.call(this, state);\n};\n\nexport default SnapLineMode;\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nconst { geojsonTypes, modes, cursors } = MapboxDraw.constants;\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DrawPolygon = MapboxDraw.modes.draw_polygon;\n\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\n\nconst SnapPolygonMode = { ...DrawPolygon };\n\nSnapPolygonMode.onSetup = function (options) {\n  const polygon = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POLYGON,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(polygon);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, polygon);\n\n  const state = {\n    map: this.map,\n    polygon,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  /// Adding default options\n  state.options = Object.assign(this._ctx.options, {\n    overlap: true,\n  });\n\n  const updateSnapList = () => {\n    const [snapList, vertices] = createSnapList(\n      this.map,\n      this._ctx.api,\n      polygon\n    );\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"updateSnapList\"] = updateSnapList;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", updateSnapList);\n  this.map.on(\"draw.snap.update_snapList\", updateSnapList);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPolygonMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  if (state.currentVertexPosition > 0) {\n    const lastVertex =\n      state.polygon.coordinates[0][state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.polygon.id],\n      });\n    }\n  }\n\n  // const point = state.map.project();\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n};\n\nSnapPolygonMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPolygon.toDisplayFeatures\nSnapPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPolygon.onStop\nSnapPolygonMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.updateSnapList);\n  // remove draw.snap.update_snapList callback\n  this.map.off(\"draw.snap.update_snapList\", state.updateSnapList);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  var userPolygon = state.polygon;\n  if (state.options.overlap) {\n    DrawPolygon.onStop.call(this, state);\n    return;\n  }\n  // if overlap is false, mutate polygon so it doesnt overlap with existing ones\n  // get all editable features to check for intersections\n  var features = this._ctx.store.getAll();\n\n  try {\n    var edited = userPolygon;\n    features.forEach(function (feature) {\n      if (userPolygon.id === feature.id) return false;\n      if (!booleanIntersects(feature, edited)) return;\n      edited = turf.difference(edited, feature);\n    });\n    state.polygon.coordinates =\n      edited.coordinates || edited.geometry.coordinates;\n  } catch (err) {\n    // cancel this polygon if a difference cannot be calculated\n    DrawPolygon.onStop.call(this, state);\n    this.deleteFeature([state.polygon.id], { silent: true });\n    return;\n  }\n\n  // monkeypatch so DrawPolygon.onStop doesn't error\n  var rc = state.polygon.removeCoordinate;\n  state.polygon.removeCoordinate = () => {};\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.onStop.call(this, state);\n  state.polygon.removeCoordinate = rc.bind(state.polygon);\n};\n\nexport default SnapPolygonMode;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nimport { createSnapList, getGuideFeature, IDS, snap } from \"./../utils\";\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DirectSelect = MapboxDraw.modes.direct_select;\nconst Constants = MapboxDraw.constants;\nconst SnapDirectSelect = { ...DirectSelect };\n\nSnapDirectSelect.onSetup = function (opts) {\n  const featureId = opts.featureId;\n  const feature = this.getFeature(featureId);\n\n  if (!feature) {\n    throw new Error(\"You must provide a featureId to enter direct_select mode\");\n  }\n\n  if (feature.type === Constants.geojsonTypes.POINT) {\n    throw new TypeError(\"direct_select mode doesn't handle point features\");\n  }\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, feature);\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const state = {\n    map: this.map,\n    featureId,\n    feature,\n    dragMoveLocation: opts.startPos || null,\n    dragMoving: false,\n    canDragMove: false,\n    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : [],\n    vertices,\n    snapList,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  state.options = this._ctx.options;\n\n  this.setSelectedCoordinates(\n    this.pathsToCoordinates(featureId, state.selectedCoordPaths)\n  );\n  this.setSelected(featureId);\n  doubleClickZoom.disable(this);\n\n  this.setActionableState({\n    trash: true,\n  });\n\n  const updateSnapList = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, feature);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"updateSnapList\"] = updateSnapList;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n  this.map.on(\"draw.snap.update_snapList\", updateSnapList);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapDirectSelect.dragVertex = function (state, e, delta) {\n  const { lng, lat } = snap(state, e);\n\n  state.feature.updateCoordinate(state.selectedCoordPaths[0], lng, lat);\n};\n\nSnapDirectSelect.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  //   this.map.off(\"moveend\", state.moveendCallback);\n  // remove draw.snap.update_snapList callback\n  this.map.off(\"draw.snap.update_snapList\", state.updateSnapList);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DirectSelect.onStop.call(this, state);\n};\n\nexport default SnapDirectSelect;\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nconst theme = MapboxDraw.lib.theme;\n\nconst modifiedDefaultStyles = theme.map(defaultStyle => {\n  if (defaultStyle.id === 'gl-draw-line-inactive') {\n    return {\n      ...defaultStyle,\n      filter: [\n        ...defaultStyle.filter,\n        ['!=', 'user_isSnapGuide', 'true'],\n      ],\n    };\n  }\n\n  return defaultStyle;\n});\n\nconst customDrawStyles = [\n  ...modifiedDefaultStyles,\n  {\n    id: \"guide\",\n    type: \"line\",\n    filter: [\n      \"all\",\n      [\"==\", \"$type\", \"LineString\"],\n      [\"==\", \"user_isSnapGuide\", \"true\"],\n    ],\n    layout: {\n      \"line-cap\": \"round\",\n      \"line-join\": \"round\",\n    },\n    paint: {\n      \"line-color\": \"#c00c00\",\n      \"line-width\": 1,\n      \"line-dasharray\": [5, 5],\n    },\n  },\n];\n\nexport default customDrawStyles;\n"],"names":["root","factory","exports","module","define","amd","this","wgs84","polygonArea","coords","area","length","Math","abs","ringArea","i","p1","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","_","PI","geometry","type","coordinates","geometries","ring","gj","types","features","properties","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","Feature","FeatureCollection","meta_1","bbox","geojson","result","Infinity","coordEach","coord","feature","geom","options","feat","id","point","Error","Array","isArray","isNumber","polygon","_i","coordinates_1","j","lineString","featureCollection","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","num","isNaN","Object","defineProperty","value","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","hectares","_options","points","map","polygons","lineStrings","geometryCollection","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","indexOf","helpers","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","g","featureProperties","featureBBox","featureId","undefined","flattenEach","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordAll","push","coordReduce","initialValue","previousValue","featureReduce","currentFeature","findPoint","findSegment","flattenReduce","geomReduce","currentGeometry","lineReduce","currentLine","propReduce","currentProperties","segmentReduce","started","equal","a","b","keys","RegExp","source","flags","valueOf","prototype","toString","hasOwnProperty","call","key","rbush","meta","turfBBox","geojsonRbush","maxEntries","tree","insert","load","remove","equals","clear","search","toBBox","collides","all","toJSON","fromJSON","json","minX","minY","maxX","maxY","t","r","e","h","n","o","s","log","f","exp","u","sqrt","max","floor","min","p","d","x","_maxEntries","_minEntries","ceil","children","leaf","m","c","height","pop","_all","data","_build","slice","_splitRoot","_insert","splice","_condense","compareMinX","compareMinY","apply","_chooseSubtree","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","v","M","_allDistMargin","sort","FLATTENING","POLAR_RADIUS","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","definition","enumerable","get","obj","prop","Symbol","toStringTag","mode","DrawContext","handlers","drag","click","mousemove","mousedown","mouseup","mouseout","keydown","keyup","touchstart","touchmove","touchend","tap","ctx","on","event","selector","fn","render","store","featureChanged","delegate","eventName","handles","iHandle","handle","ui","updateMapClasses","start","trash","combineFeatures","uncombineFeatures","classes","CANVAS","CONTROL_BASE","CONTROL_PREFIX","CONTROL_BUTTON","CONTROL_BUTTON_LINE","CONTROL_BUTTON_POLYGON","CONTROL_BUTTON_POINT","CONTROL_BUTTON_TRASH","CONTROL_BUTTON_COMBINE_FEATURES","CONTROL_BUTTON_UNCOMBINE_FEATURES","CONTROL_GROUP","ATTRIBUTION","ACTIVE_BUTTON","BOX_SELECT","sources","HOT","COLD","cursors","ADD","MOVE","DRAG","POINTER","NONE","POLYGON","LINE","POINT","geojsonTypes","FEATURE","LINE_STRING","FEATURE_COLLECTION","MULTI_PREFIX","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","DRAW_LINE_STRING","DRAW_POLYGON","DRAW_POINT","SIMPLE_SELECT","DIRECT_SELECT","CREATE","DELETE","UPDATE","SELECTION_CHANGE","MODE_CHANGE","ACTIONABLE","RENDER","COMBINE_FEATURES","UNCOMBINE_FEATURES","updateActions","CHANGE_PROPERTIES","CHANGE_COORDINATES","MIDPOINT","VERTEX","activeStates","ACTIVE","INACTIVE","interactions","LAT_MIN","LAT_RENDERED_MIN","LAT_MAX","LAT_RENDERED_MAX","LNG_MIN","LNG_MAX","FEATURE_SORT_RANKS","comparator","score","property","mapEvent","buffer","y","StringSet","items","_items","_nums","_length","add","has","delete","values","JSON","parse","META_TYPES","featuresAt","clickBuffer","touch","touchBuffer","box","queryParams","styles","layers","filter","getLayer","queryRenderedFeatures","featureIds","uniqueFeatures","getFeatureAtAndSetCursors","mouse","active","events","currentModeName","queueMapClasses","FINE_TOLERANCE","GROSS_TOLERANCE","INTERVAL","isClick","end","fineTolerance","grossTolerance","interval","time","moveDistance","TAP_TOLERANCE","TAP_INTERVAL","isTap","tolerance","alphabet","defaultSize","size","random","customAlphabet","generateID","changed","incomingCoords","setCoordinates","getCoordinates","stringify","setProperty","toGeoJSON","internal","userProperties","name","create","isValid","updateCoordinate","pathOrLng","lngOrLat","lat","arguments","getCoordinate","addCoordinate","path","lng","parseInt","removeCoordinate","every","ids","split","concat","parts","ringId","coordId","models","takeAction","action","idx","tail","join","MultiFeature","model","TypeError","_coordinatesToFeatures","Model","bind","replace","getFeatures","ModeInterface","drawConfig","_ctx","setSelected","setSelectedCoordinates","reduce","feature_id","getSelected","getSelectedIds","isSelected","getFeature","select","deselect","deleteFeature","opts","addFeature","clearSelectedFeatures","clearSelected","clearSelectedCoordinates","setActionableState","actions","newSet","actionable","changeMode","eventOpts","fire","eventData","updateUIClasses","activateUIButton","setActiveButton","bufferType","newFeature","isInstanceOf","doRender","onSetup","onDrag","onClick","onMouseMove","onMouseDown","onMouseUp","onMouseOut","onKeyUp","onKeyDown","onTouchStart","onTouchMove","onTouchEnd","onTap","onStop","onTrash","onCombineFeature","onUncombineFeature","toDisplayFeatures","eventMapper","eventKeys","modeObject","modeObjectKeys","startOpts","state","modeHandler","eh","onCombineFeatures","onUncombineFeatures","getSource","cleanup","newHotIds","newColdIds","isDirty","getAllIds","getChangedIds","hot","lastColdCount","cold","parent","coldChanged","renderFeature","featureInternal","currentModeRender","clearChangedIds","setData","Store","renderRequest","_features","_featureIds","_selectedFeatureIds","_selectedCoordinates","_changedFeatureIds","_emitSelectionChange","_mapInitialConfig","requestAnimationFrame","getSelectedCoordinates","coordinate","refreshSelectedCoordinates","newSelectedCoordinates","silent","createRenderBatch","holdRender","numRenders","setDirty","featureCreated","suppressAPIEvents","deletedFeaturesToEmit","getAll","coord_path","setFeatureProperty","storeMapConfig","interaction","isEnabled","restoreMapConfig","enable","disable","getInitialConfigValue","classTypes","controlContainer","mapLoadedInterval","setup","onRemove","off","connect","clearInterval","removeLayers","removeButtons","removeEventListeners","clearMapClasses","boxZoomInitial","boxZoom","container","parentNode","removeChild","addLayers","addEventListeners","onAdd","modes","mouseDownInfo","touchStartInfo","currentMode","isDrag","Date","getTime","originalEvent","stopPropagation","mousedrag","endInfo","touchdrag","buttons","which","target","featureTarget","touchEnabled","preventDefault","isKeyModeValid","code","modename","nextModeOptions","eventOptions","modebuilder","srcElement","classList","contains","keyCode","controls","line_string","zoomend","changeZoom","dataType","some","style","actionState","defaultMode","addEventListener","keybindings","removeEventListener","getMode","buttonElements","activeButton","currentMapClasses","nextMapClasses","assign","classesToRemove","classesToAdd","createControlButton","button","document","createElement","className","setAttribute","title","appendChild","deactivateButtons","onDeactivate","onActivate","addButtons","controlGroup","combine_features","uncombine_features","buttonId","getContainer","boxSelect","dragPanIsEnabled","dragPan","loaded","setInterval","addSource","addLayer","removeLayer","removeSource","blue","orange","white","isOfMetaType","isShiftMousedown","shiftKey","isActiveFeature","isInactiveFeature","noTarget","isVertex","isShiftDown","isEscapeKey","isEnterKey","isTrue","clone","_add","sub","_sub","multByPoint","_multByPoint","divByPoint","_divByPoint","mult","_mult","div","_div","rotate","_rotate","rotateAround","_rotateAround","matMult","_matMult","unit","_unit","perp","_perp","_round","mag","other","dist","distSqr","dx","dy","atan2","angleTo","angleWith","angleWithSep","cos","convert","mouseEvent","rect","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","parentId","selected","startVertex","endVertex","startCoord","endCoord","mid","createSupplementaryPoints","basePath","supplementaryPoints","processLine","line","lineBasePath","firstPointString","lastVertex","pointIndex","pointPath","String","vertex","isSelectedPath","midpoints","midpoint","stringifiedPoint","selectedPaths","lineIndex","subType","subCoordinates","index","subFeature","processMultiGeometry","setTimeout","doubleClickZoom","geojsonFeatures","delta","northInnerEdge","southInnerEdge","northOuterEdge","southOuterEdge","westEdge","eastEdge","bounds","depth","flat","lngs","lats","vals","extent","featureSouthEdge","featureNorthEdge","featureWestEdge","featureEastEdge","constrainedDelta","currentCoordinates","moveCoordinate","moveRing","moveMultiPolygon","multi","nextCoordinates","SimpleSelect","dragMoveLocation","boxSelectStartLocation","boxSelectElement","boxSelecting","canBoxSelect","dragMoving","canDragMove","initialDragPanState","initiallySelectedFeatureIds","fireActionable","selectedFeatures","multiFeatures","featureType","allFeatures","memo","fireUpdate","stopExtendedInteractions","clickAnywhere","clickOnVertex","clickOnFeature","wasSelected","coordPath","startPos","lngLat","startOnActiveFeature","isShiftClick","selectedFeatureIds","isFeatureSelected","startBoxSelect","dragMove","whileBoxSelect","current","translateValue","transform","WebkitTransform","width","featuresInBox","idsToSelect","getUniqueIds","display","featuresCombined","includes","subcoords","multiFeature","createdFeatures","deletedFeatures","featuresUncombined","isMidpoint","DirectSelect","selectedCoordPaths","startDragging","about","selectedIndex","selectedCoordinates","pathsToCoordinates","paths","stopDragging","selectedCoords","localeCompare","numeric","onVertex","isMidPoint","noCoords","onFeature","onMidpoint","dragVertex","dragFeature","clickNoTarget","clickActiveFeature","clickInactive","DrawPoint","isActivePoint","stopDrawingAndRemove","DrawPolygon","currentVertexPosition","isActivePolygon","coordinateCount","endPos","lineCoordinates","DrawLineString","direction","from","lastCoord","isActiveLine","simple_select","direct_select","draw_point","draw_polygon","draw_line_string","defaultOptions","displayControlsDefault","showControls","hideControls","addSources","sourceBucket","featureTypes","setupDraw","api","withDefaults","getFeatureIdsAt","getSelectedPoints","set","renderBatch","toDelete","newIds","newIdsLookup","internalFeature","originalProperties","deleteAll","modeOptions","MapboxDraw","constants","lib","getCoord","getCoords","getGeom","booleanPointInPolygon","pt","polys","inBBox","insidePoly","inRing","ignoreBoundary","inHole","isInside","xi","yi","xj","yj","results","segments","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","intersects","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","unique","intersect","match","poly","coordsToLine","polygonToLine","multiPoly","lines","multiPolygonToLine","isPointOnLine","isPointOnLineSegment","isLineInPoly","_a","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","lineString1","lineString2","isLineOnLine","_b","_c","doLinesIntersect","isPolyInPoly","disjoint","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","final","bear","calculateFinalBearing","lon1","lon2","destination","origin","longitude1","latitude1","bearingRad","latitude2","asin","closestPt","stop_1","sectionLength","heightDistance","perpendicularPt1","perpendicularPt2","intersectPt","location","cloneFeature","cloned","cloneProperties","cloneGeometry","item","deepSlice","cloneFeatureCollection","targetPoint","nearest","minDist","bestFeatureIndex","distanceToPoint","point1","point2","IDS","VERTICAL_GUIDE","HORIZONTAL_GUIDE","addPointTovertices","vertices","forceInclusion","_map$getCanvas","getCanvas","w","_map$project","project","createSnapList","draw","snapList","bboxAsPolygon","canvas","cUR","unproject","toArray","west","Number","south","east","north","lowLeft","bboxPolygon","addVerticesTovertices","isCurrentFeature","booleanDisjoint","getFeatureWithNearestPoint","P","nearestPointsOfEachFeature","nearestPointOnLine","calcClosestLayer","closestLayer","layer","nearestPoint","isMarker","isPolygon","isMultiPolygon","isMultiPoint","latlngs","_latlngs","_slicedToArray","latlng","np","nearestPointInPointSet","turfPoint","closestFeature","turfLineString","flatMap","_nearestPoint$geometr","calcLayerDistances","checkPrioritiySnapping","snapOptions","snapToPoint","_ref","_ref$snapToMidPoints","snapToMidPoints","_ref$snapToNodal","snapToNodal","_ref$snapToEndPoints","snapToEndPoints","_ref$snapToLines","snapToLines","_ref$snapVertexPriori","snapVertexPriorityDistance","A","B","C","distanceAC","distanceBC","closestVertexLatLng","shortestDistance","isMiddlePoint","distanceMC","snapLatlng","priorityDistance","isEndPoint","find","_snapLatlng2","snapToLineOrPolygon","snap","minDistance","snapLatLng","latitude","zoomLevel","latitudeRadians","verticalPx","horizontalPx","verticals","horizontals","altKey","showVerticalSnapLine","showHorizontalSnapLine","snapPx","getZoom","guides","nearestGuidline","px","py","lngLatTop","lngLatBottom","verticalGuide","horizontalGuide","getGuideFeature","isSnapGuide","shouldHideGuide","_MapboxDraw$constants","SnapPointMode","_objectSpread","_this","_createSnapList2","updateSnapList","_createSnapList4","optionsChangedCallBAck","snappedLng","snappedLat","_snap","DrawLine","SnapLineMode","SnapPolygonMode","overlap","userPolygon","edited","turf","difference","err","rc","Constants","SnapDirectSelect","modifiedDefaultStyles","theme","defaultStyle","_toConsumableArray","layout","paint"],"sourceRoot":""}